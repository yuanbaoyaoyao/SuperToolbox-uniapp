"use strict";
!function(e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).fontkit = t();
}(globalThis, function() {
  var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
  function t(e2, t2) {
    return e2(t2 = { exports: {} }, t2.exports), t2.exports;
  }
  function r(e2) {
    return e2 && e2.default || e2;
  }
  for (var n = function(e2) {
    var t2 = h(e2), r2 = t2[0], n2 = t2[1];
    return 3 * (r2 + n2) / 4 - n2;
  }, i = function(e2) {
    var t2, r2, n2 = h(e2), i2 = n2[0], a2 = n2[1], o2 = new u(function(e3, t3, r3) {
      return 3 * (t3 + r3) / 4 - r3;
    }(0, i2, a2)), l2 = 0, c2 = a2 > 0 ? i2 - 4 : i2;
    for (r2 = 0; r2 < c2; r2 += 4)
      t2 = s[e2.charCodeAt(r2)] << 18 | s[e2.charCodeAt(r2 + 1)] << 12 | s[e2.charCodeAt(r2 + 2)] << 6 | s[e2.charCodeAt(r2 + 3)], o2[l2++] = t2 >> 16 & 255, o2[l2++] = t2 >> 8 & 255, o2[l2++] = 255 & t2;
    2 === a2 && (t2 = s[e2.charCodeAt(r2)] << 2 | s[e2.charCodeAt(r2 + 1)] >> 4, o2[l2++] = 255 & t2);
    1 === a2 && (t2 = s[e2.charCodeAt(r2)] << 10 | s[e2.charCodeAt(r2 + 1)] << 4 | s[e2.charCodeAt(r2 + 2)] >> 2, o2[l2++] = t2 >> 8 & 255, o2[l2++] = 255 & t2);
    return o2;
  }, a = function(e2) {
    for (var t2, r2 = e2.length, n2 = r2 % 3, i2 = [], a2 = 0, s2 = r2 - n2; a2 < s2; a2 += 16383)
      i2.push(d(e2, a2, a2 + 16383 > s2 ? s2 : a2 + 16383));
    1 === n2 ? (t2 = e2[r2 - 1], i2.push(o[t2 >> 2] + o[t2 << 4 & 63] + "==")) : 2 === n2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], i2.push(o[t2 >> 10] + o[t2 >> 4 & 63] + o[t2 << 2 & 63] + "="));
    return i2.join("");
  }, o = [], s = [], u = "undefined" != typeof Uint8Array ? Uint8Array : Array, l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = 0, f = l.length; c < f; ++c)
    o[c] = l[c], s[l.charCodeAt(c)] = c;
  function h(e2) {
    var t2 = e2.length;
    if (t2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r2 = e2.indexOf("=");
    return -1 === r2 && (r2 = t2), [r2, r2 === t2 ? 0 : 4 - r2 % 4];
  }
  function d(e2, t2, r2) {
    for (var n2, i2, a2 = [], s2 = t2; s2 < r2; s2 += 3)
      n2 = (e2[s2] << 16 & 16711680) + (e2[s2 + 1] << 8 & 65280) + (255 & e2[s2 + 2]), a2.push(o[(i2 = n2) >> 18 & 63] + o[i2 >> 12 & 63] + o[i2 >> 6 & 63] + o[63 & i2]);
    return a2.join("");
  }
  s["-".charCodeAt(0)] = 62, s["_".charCodeAt(0)] = 63;
  var p = { byteLength: n, toByteArray: i, fromByteArray: a }, y = function(e2, t2, r2, n2, i2) {
    var a2, o2, s2 = 8 * i2 - n2 - 1, u2 = (1 << s2) - 1, l2 = u2 >> 1, c2 = -7, f2 = r2 ? i2 - 1 : 0, h2 = r2 ? -1 : 1, d2 = e2[t2 + f2];
    for (f2 += h2, a2 = d2 & (1 << -c2) - 1, d2 >>= -c2, c2 += s2; c2 > 0; a2 = 256 * a2 + e2[t2 + f2], f2 += h2, c2 -= 8)
      ;
    for (o2 = a2 & (1 << -c2) - 1, a2 >>= -c2, c2 += n2; c2 > 0; o2 = 256 * o2 + e2[t2 + f2], f2 += h2, c2 -= 8)
      ;
    if (0 === a2)
      a2 = 1 - l2;
    else {
      if (a2 === u2)
        return o2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
      o2 += Math.pow(2, n2), a2 -= l2;
    }
    return (d2 ? -1 : 1) * o2 * Math.pow(2, a2 - n2);
  }, g = function(e2, t2, r2, n2, i2, a2) {
    var o2, s2, u2, l2 = 8 * a2 - i2 - 1, c2 = (1 << l2) - 1, f2 = c2 >> 1, h2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = n2 ? 0 : a2 - 1, p2 = n2 ? 1 : -1, y2 = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
    for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = c2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (u2 = Math.pow(2, -o2)) < 1 && (o2--, u2 *= 2), (t2 += o2 + f2 >= 1 ? h2 / u2 : h2 * Math.pow(2, 1 - f2)) * u2 >= 2 && (o2++, u2 /= 2), o2 + f2 >= c2 ? (s2 = 0, o2 = c2) : o2 + f2 >= 1 ? (s2 = (t2 * u2 - 1) * Math.pow(2, i2), o2 += f2) : (s2 = t2 * Math.pow(2, f2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; e2[r2 + d2] = 255 & s2, d2 += p2, s2 /= 256, i2 -= 8)
      ;
    for (o2 = o2 << i2 | s2, l2 += i2; l2 > 0; e2[r2 + d2] = 255 & o2, d2 += p2, o2 /= 256, l2 -= 8)
      ;
    e2[r2 + d2 - p2] |= 128 * y2;
  }, v = t(function(e2, t2) {
    var r2 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    t2.Buffer = i2, t2.SlowBuffer = function(e3) {
      +e3 != e3 && (e3 = 0);
      return i2.alloc(+e3);
    }, t2.INSPECT_MAX_BYTES = 50;
    function n2(e3) {
      if (e3 > 2147483647)
        throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
      var t3 = new Uint8Array(e3);
      return Object.setPrototypeOf(t3, i2.prototype), t3;
    }
    function i2(e3, t3, r3) {
      if ("number" == typeof e3) {
        if ("string" == typeof t3)
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return s2(e3);
      }
      return a2(e3, t3, r3);
    }
    function a2(e3, t3, r3) {
      if ("string" == typeof e3)
        return function(e4, t4) {
          "string" == typeof t4 && "" !== t4 || (t4 = "utf8");
          if (!i2.isEncoding(t4))
            throw new TypeError("Unknown encoding: " + t4);
          var r4 = 0 | f2(e4, t4), a4 = n2(r4), o4 = a4.write(e4, t4);
          o4 !== r4 && (a4 = a4.slice(0, o4));
          return a4;
        }(e3, t3);
      if (ArrayBuffer.isView(e3))
        return u2(e3);
      if (null == e3)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
      if (N2(e3, ArrayBuffer) || e3 && N2(e3.buffer, ArrayBuffer))
        return l2(e3, t3, r3);
      if ("undefined" != typeof SharedArrayBuffer && (N2(e3, SharedArrayBuffer) || e3 && N2(e3.buffer, SharedArrayBuffer)))
        return l2(e3, t3, r3);
      if ("number" == typeof e3)
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      var a3 = e3.valueOf && e3.valueOf();
      if (null != a3 && a3 !== e3)
        return i2.from(a3, t3, r3);
      var o3 = function(e4) {
        if (i2.isBuffer(e4)) {
          var t4 = 0 | c2(e4.length), r4 = n2(t4);
          return 0 === r4.length || e4.copy(r4, 0, 0, t4), r4;
        }
        if (void 0 !== e4.length)
          return "number" != typeof e4.length || q2(e4.length) ? n2(0) : u2(e4);
        if ("Buffer" === e4.type && Array.isArray(e4.data))
          return u2(e4.data);
      }(e3);
      if (o3)
        return o3;
      if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive])
        return i2.from(e3[Symbol.toPrimitive]("string"), t3, r3);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
    }
    function o2(e3) {
      if ("number" != typeof e3)
        throw new TypeError('"size" argument must be of type number');
      if (e3 < 0)
        throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
    }
    function s2(e3) {
      return o2(e3), n2(e3 < 0 ? 0 : 0 | c2(e3));
    }
    function u2(e3) {
      for (var t3 = e3.length < 0 ? 0 : 0 | c2(e3.length), r3 = n2(t3), i3 = 0; i3 < t3; i3 += 1)
        r3[i3] = 255 & e3[i3];
      return r3;
    }
    function l2(e3, t3, r3) {
      if (t3 < 0 || e3.byteLength < t3)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e3.byteLength < t3 + (r3 || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var n3;
      return n3 = void 0 === t3 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n3, i2.prototype), n3;
    }
    function c2(e3) {
      if (e3 >= 2147483647)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
      return 0 | e3;
    }
    function f2(e3, t3) {
      if (i2.isBuffer(e3))
        return e3.length;
      if (ArrayBuffer.isView(e3) || N2(e3, ArrayBuffer))
        return e3.byteLength;
      if ("string" != typeof e3)
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
      var r3 = e3.length, n3 = arguments.length > 2 && true === arguments[2];
      if (!n3 && 0 === r3)
        return 0;
      for (var a3 = false; ; )
        switch (t3) {
          case "ascii":
          case "latin1":
          case "binary":
            return r3;
          case "utf8":
          case "utf-8":
            return M2(e3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * r3;
          case "hex":
            return r3 >>> 1;
          case "base64":
            return F2(e3).length;
          default:
            if (a3)
              return n3 ? -1 : M2(e3).length;
            t3 = ("" + t3).toLowerCase(), a3 = true;
        }
    }
    function h2(e3, t3, r3) {
      var n3 = false;
      if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length)
        return "";
      if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0)
        return "";
      if ((r3 >>>= 0) <= (t3 >>>= 0))
        return "";
      for (e3 || (e3 = "utf8"); ; )
        switch (e3) {
          case "hex":
            return E2(this, t3, r3);
          case "utf8":
          case "utf-8":
            return P2(this, t3, r3);
          case "ascii":
            return I2(this, t3, r3);
          case "latin1":
          case "binary":
            return O2(this, t3, r3);
          case "base64":
            return C2(this, t3, r3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return B2(this, t3, r3);
          default:
            if (n3)
              throw new TypeError("Unknown encoding: " + e3);
            e3 = (e3 + "").toLowerCase(), n3 = true;
        }
    }
    function d2(e3, t3, r3) {
      var n3 = e3[t3];
      e3[t3] = e3[r3], e3[r3] = n3;
    }
    function v2(e3, t3, r3, n3, a3) {
      if (0 === e3.length)
        return -1;
      if ("string" == typeof r3 ? (n3 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), q2(r3 = +r3) && (r3 = a3 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
        if (a3)
          return -1;
        r3 = e3.length - 1;
      } else if (r3 < 0) {
        if (!a3)
          return -1;
        r3 = 0;
      }
      if ("string" == typeof t3 && (t3 = i2.from(t3, n3)), i2.isBuffer(t3))
        return 0 === t3.length ? -1 : b2(e3, t3, r3, n3, a3);
      if ("number" == typeof t3)
        return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? a3 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : b2(e3, [t3], r3, n3, a3);
      throw new TypeError("val must be string, number or Buffer");
    }
    function b2(e3, t3, r3, n3, i3) {
      var a3, o3 = 1, s3 = e3.length, u3 = t3.length;
      if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
        if (e3.length < 2 || t3.length < 2)
          return -1;
        o3 = 2, s3 /= 2, u3 /= 2, r3 /= 2;
      }
      function l3(e4, t4) {
        return 1 === o3 ? e4[t4] : e4.readUInt16BE(t4 * o3);
      }
      if (i3) {
        var c3 = -1;
        for (a3 = r3; a3 < s3; a3++)
          if (l3(e3, a3) === l3(t3, -1 === c3 ? 0 : a3 - c3)) {
            if (-1 === c3 && (c3 = a3), a3 - c3 + 1 === u3)
              return c3 * o3;
          } else
            -1 !== c3 && (a3 -= a3 - c3), c3 = -1;
      } else
        for (r3 + u3 > s3 && (r3 = s3 - u3), a3 = r3; a3 >= 0; a3--) {
          for (var f3 = true, h3 = 0; h3 < u3; h3++)
            if (l3(e3, a3 + h3) !== l3(t3, h3)) {
              f3 = false;
              break;
            }
          if (f3)
            return a3;
        }
      return -1;
    }
    function m2(e3, t3, r3, n3) {
      r3 = Number(r3) || 0;
      var i3 = e3.length - r3;
      n3 ? (n3 = Number(n3)) > i3 && (n3 = i3) : n3 = i3;
      var a3 = t3.length;
      n3 > a3 / 2 && (n3 = a3 / 2);
      for (var o3 = 0; o3 < n3; ++o3) {
        var s3 = parseInt(t3.substr(2 * o3, 2), 16);
        if (q2(s3))
          return o3;
        e3[r3 + o3] = s3;
      }
      return o3;
    }
    function w2(e3, t3, r3, n3) {
      return R2(M2(t3, e3.length - r3), e3, r3, n3);
    }
    function S2(e3, t3, r3, n3) {
      return R2(function(e4) {
        for (var t4 = [], r4 = 0; r4 < e4.length; ++r4)
          t4.push(255 & e4.charCodeAt(r4));
        return t4;
      }(t3), e3, r3, n3);
    }
    function x2(e3, t3, r3, n3) {
      return S2(e3, t3, r3, n3);
    }
    function A2(e3, t3, r3, n3) {
      return R2(F2(t3), e3, r3, n3);
    }
    function k2(e3, t3, r3, n3) {
      return R2(function(e4, t4) {
        for (var r4, n4, i3, a3 = [], o3 = 0; o3 < e4.length && !((t4 -= 2) < 0); ++o3)
          r4 = e4.charCodeAt(o3), n4 = r4 >> 8, i3 = r4 % 256, a3.push(i3), a3.push(n4);
        return a3;
      }(t3, e3.length - r3), e3, r3, n3);
    }
    function C2(e3, t3, r3) {
      return 0 === t3 && r3 === e3.length ? p.fromByteArray(e3) : p.fromByteArray(e3.slice(t3, r3));
    }
    function P2(e3, t3, r3) {
      r3 = Math.min(e3.length, r3);
      for (var n3 = [], i3 = t3; i3 < r3; ) {
        var a3, o3, s3, u3, l3 = e3[i3], c3 = null, f3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
        if (i3 + f3 <= r3)
          switch (f3) {
            case 1:
              l3 < 128 && (c3 = l3);
              break;
            case 2:
              128 == (192 & (a3 = e3[i3 + 1])) && (u3 = (31 & l3) << 6 | 63 & a3) > 127 && (c3 = u3);
              break;
            case 3:
              a3 = e3[i3 + 1], o3 = e3[i3 + 2], 128 == (192 & a3) && 128 == (192 & o3) && (u3 = (15 & l3) << 12 | (63 & a3) << 6 | 63 & o3) > 2047 && (u3 < 55296 || u3 > 57343) && (c3 = u3);
              break;
            case 4:
              a3 = e3[i3 + 1], o3 = e3[i3 + 2], s3 = e3[i3 + 3], 128 == (192 & a3) && 128 == (192 & o3) && 128 == (192 & s3) && (u3 = (15 & l3) << 18 | (63 & a3) << 12 | (63 & o3) << 6 | 63 & s3) > 65535 && u3 < 1114112 && (c3 = u3);
          }
        null === c3 ? (c3 = 65533, f3 = 1) : c3 > 65535 && (c3 -= 65536, n3.push(c3 >>> 10 & 1023 | 55296), c3 = 56320 | 1023 & c3), n3.push(c3), i3 += f3;
      }
      return function(e4) {
        var t4 = e4.length;
        if (t4 <= 4096)
          return String.fromCharCode.apply(String, e4);
        var r4 = "", n4 = 0;
        for (; n4 < t4; )
          r4 += String.fromCharCode.apply(String, e4.slice(n4, n4 += 4096));
        return r4;
      }(n3);
    }
    t2.kMaxLength = 2147483647, i2.TYPED_ARRAY_SUPPORT = function() {
      try {
        var e3 = new Uint8Array(1), t3 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
      } catch (e4) {
        return false;
      }
    }(), i2.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(i2.prototype, "parent", { enumerable: true, get: function() {
      if (i2.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(i2.prototype, "offset", { enumerable: true, get: function() {
      if (i2.isBuffer(this))
        return this.byteOffset;
    } }), i2.poolSize = 8192, i2.from = function(e3, t3, r3) {
      return a2(e3, t3, r3);
    }, Object.setPrototypeOf(i2.prototype, Uint8Array.prototype), Object.setPrototypeOf(i2, Uint8Array), i2.alloc = function(e3, t3, r3) {
      return function(e4, t4, r4) {
        return o2(e4), e4 <= 0 ? n2(e4) : void 0 !== t4 ? "string" == typeof r4 ? n2(e4).fill(t4, r4) : n2(e4).fill(t4) : n2(e4);
      }(e3, t3, r3);
    }, i2.allocUnsafe = function(e3) {
      return s2(e3);
    }, i2.allocUnsafeSlow = function(e3) {
      return s2(e3);
    }, i2.isBuffer = function(e3) {
      return null != e3 && true === e3._isBuffer && e3 !== i2.prototype;
    }, i2.compare = function(e3, t3) {
      if (N2(e3, Uint8Array) && (e3 = i2.from(e3, e3.offset, e3.byteLength)), N2(t3, Uint8Array) && (t3 = i2.from(t3, t3.offset, t3.byteLength)), !i2.isBuffer(e3) || !i2.isBuffer(t3))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e3 === t3)
        return 0;
      for (var r3 = e3.length, n3 = t3.length, a3 = 0, o3 = Math.min(r3, n3); a3 < o3; ++a3)
        if (e3[a3] !== t3[a3]) {
          r3 = e3[a3], n3 = t3[a3];
          break;
        }
      return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
    }, i2.isEncoding = function(e3) {
      switch (String(e3).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, i2.concat = function(e3, t3) {
      if (!Array.isArray(e3))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === e3.length)
        return i2.alloc(0);
      var r3;
      if (void 0 === t3)
        for (t3 = 0, r3 = 0; r3 < e3.length; ++r3)
          t3 += e3[r3].length;
      var n3 = i2.allocUnsafe(t3), a3 = 0;
      for (r3 = 0; r3 < e3.length; ++r3) {
        var o3 = e3[r3];
        if (N2(o3, Uint8Array) && (o3 = i2.from(o3)), !i2.isBuffer(o3))
          throw new TypeError('"list" argument must be an Array of Buffers');
        o3.copy(n3, a3), a3 += o3.length;
      }
      return n3;
    }, i2.byteLength = f2, i2.prototype._isBuffer = true, i2.prototype.swap16 = function() {
      var e3 = this.length;
      if (e3 % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var t3 = 0; t3 < e3; t3 += 2)
        d2(this, t3, t3 + 1);
      return this;
    }, i2.prototype.swap32 = function() {
      var e3 = this.length;
      if (e3 % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var t3 = 0; t3 < e3; t3 += 4)
        d2(this, t3, t3 + 3), d2(this, t3 + 1, t3 + 2);
      return this;
    }, i2.prototype.swap64 = function() {
      var e3 = this.length;
      if (e3 % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var t3 = 0; t3 < e3; t3 += 8)
        d2(this, t3, t3 + 7), d2(this, t3 + 1, t3 + 6), d2(this, t3 + 2, t3 + 5), d2(this, t3 + 3, t3 + 4);
      return this;
    }, i2.prototype.toString = function() {
      var e3 = this.length;
      return 0 === e3 ? "" : 0 === arguments.length ? P2(this, 0, e3) : h2.apply(this, arguments);
    }, i2.prototype.toLocaleString = i2.prototype.toString, i2.prototype.equals = function(e3) {
      if (!i2.isBuffer(e3))
        throw new TypeError("Argument must be a Buffer");
      return this === e3 || 0 === i2.compare(this, e3);
    }, i2.prototype.inspect = function() {
      var e3 = "", r3 = t2.INSPECT_MAX_BYTES;
      return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
    }, r2 && (i2.prototype[r2] = i2.prototype.inspect), i2.prototype.compare = function(e3, t3, r3, n3, a3) {
      if (N2(e3, Uint8Array) && (e3 = i2.from(e3, e3.offset, e3.byteLength)), !i2.isBuffer(e3))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
      if (void 0 === t3 && (t3 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n3 && (n3 = 0), void 0 === a3 && (a3 = this.length), t3 < 0 || r3 > e3.length || n3 < 0 || a3 > this.length)
        throw new RangeError("out of range index");
      if (n3 >= a3 && t3 >= r3)
        return 0;
      if (n3 >= a3)
        return -1;
      if (t3 >= r3)
        return 1;
      if (this === e3)
        return 0;
      for (var o3 = (a3 >>>= 0) - (n3 >>>= 0), s3 = (r3 >>>= 0) - (t3 >>>= 0), u3 = Math.min(o3, s3), l3 = this.slice(n3, a3), c3 = e3.slice(t3, r3), f3 = 0; f3 < u3; ++f3)
        if (l3[f3] !== c3[f3]) {
          o3 = l3[f3], s3 = c3[f3];
          break;
        }
      return o3 < s3 ? -1 : s3 < o3 ? 1 : 0;
    }, i2.prototype.includes = function(e3, t3, r3) {
      return -1 !== this.indexOf(e3, t3, r3);
    }, i2.prototype.indexOf = function(e3, t3, r3) {
      return v2(this, e3, t3, r3, true);
    }, i2.prototype.lastIndexOf = function(e3, t3, r3) {
      return v2(this, e3, t3, r3, false);
    }, i2.prototype.write = function(e3, t3, r3, n3) {
      if (void 0 === t3)
        n3 = "utf8", r3 = this.length, t3 = 0;
      else if (void 0 === r3 && "string" == typeof t3)
        n3 = t3, r3 = this.length, t3 = 0;
      else {
        if (!isFinite(t3))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = r3, r3 = void 0);
      }
      var i3 = this.length - t3;
      if ((void 0 === r3 || r3 > i3) && (r3 = i3), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n3 || (n3 = "utf8");
      for (var a3 = false; ; )
        switch (n3) {
          case "hex":
            return m2(this, e3, t3, r3);
          case "utf8":
          case "utf-8":
            return w2(this, e3, t3, r3);
          case "ascii":
            return S2(this, e3, t3, r3);
          case "latin1":
          case "binary":
            return x2(this, e3, t3, r3);
          case "base64":
            return A2(this, e3, t3, r3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return k2(this, e3, t3, r3);
          default:
            if (a3)
              throw new TypeError("Unknown encoding: " + n3);
            n3 = ("" + n3).toLowerCase(), a3 = true;
        }
    }, i2.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function I2(e3, t3, r3) {
      var n3 = "";
      r3 = Math.min(e3.length, r3);
      for (var i3 = t3; i3 < r3; ++i3)
        n3 += String.fromCharCode(127 & e3[i3]);
      return n3;
    }
    function O2(e3, t3, r3) {
      var n3 = "";
      r3 = Math.min(e3.length, r3);
      for (var i3 = t3; i3 < r3; ++i3)
        n3 += String.fromCharCode(e3[i3]);
      return n3;
    }
    function E2(e3, t3, r3) {
      var n3 = e3.length;
      (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n3) && (r3 = n3);
      for (var i3 = "", a3 = t3; a3 < r3; ++a3)
        i3 += G2[e3[a3]];
      return i3;
    }
    function B2(e3, t3, r3) {
      for (var n3 = e3.slice(t3, r3), i3 = "", a3 = 0; a3 < n3.length; a3 += 2)
        i3 += String.fromCharCode(n3[a3] + 256 * n3[a3 + 1]);
      return i3;
    }
    function T2(e3, t3, r3) {
      if (e3 % 1 != 0 || e3 < 0)
        throw new RangeError("offset is not uint");
      if (e3 + t3 > r3)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function L2(e3, t3, r3, n3, a3, o3) {
      if (!i2.isBuffer(e3))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t3 > a3 || t3 < o3)
        throw new RangeError('"value" argument is out of bounds');
      if (r3 + n3 > e3.length)
        throw new RangeError("Index out of range");
    }
    function z2(e3, t3, r3, n3, i3, a3) {
      if (r3 + n3 > e3.length)
        throw new RangeError("Index out of range");
      if (r3 < 0)
        throw new RangeError("Index out of range");
    }
    function U2(e3, t3, r3, n3, i3) {
      return t3 = +t3, r3 >>>= 0, i3 || z2(e3, 0, r3, 4), g(e3, t3, r3, n3, 23, 4), r3 + 4;
    }
    function D2(e3, t3, r3, n3, i3) {
      return t3 = +t3, r3 >>>= 0, i3 || z2(e3, 0, r3, 8), g(e3, t3, r3, n3, 52, 8), r3 + 8;
    }
    i2.prototype.slice = function(e3, t3) {
      var r3 = this.length;
      (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
      var n3 = this.subarray(e3, t3);
      return Object.setPrototypeOf(n3, i2.prototype), n3;
    }, i2.prototype.readUIntLE = function(e3, t3, r3) {
      e3 >>>= 0, t3 >>>= 0, r3 || T2(e3, t3, this.length);
      for (var n3 = this[e3], i3 = 1, a3 = 0; ++a3 < t3 && (i3 *= 256); )
        n3 += this[e3 + a3] * i3;
      return n3;
    }, i2.prototype.readUIntBE = function(e3, t3, r3) {
      e3 >>>= 0, t3 >>>= 0, r3 || T2(e3, t3, this.length);
      for (var n3 = this[e3 + --t3], i3 = 1; t3 > 0 && (i3 *= 256); )
        n3 += this[e3 + --t3] * i3;
      return n3;
    }, i2.prototype.readUInt8 = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 1, this.length), this[e3];
    }, i2.prototype.readUInt16LE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
    }, i2.prototype.readUInt16BE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
    }, i2.prototype.readUInt32LE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
    }, i2.prototype.readUInt32BE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
    }, i2.prototype.readIntLE = function(e3, t3, r3) {
      e3 >>>= 0, t3 >>>= 0, r3 || T2(e3, t3, this.length);
      for (var n3 = this[e3], i3 = 1, a3 = 0; ++a3 < t3 && (i3 *= 256); )
        n3 += this[e3 + a3] * i3;
      return n3 >= (i3 *= 128) && (n3 -= Math.pow(2, 8 * t3)), n3;
    }, i2.prototype.readIntBE = function(e3, t3, r3) {
      e3 >>>= 0, t3 >>>= 0, r3 || T2(e3, t3, this.length);
      for (var n3 = t3, i3 = 1, a3 = this[e3 + --n3]; n3 > 0 && (i3 *= 256); )
        a3 += this[e3 + --n3] * i3;
      return a3 >= (i3 *= 128) && (a3 -= Math.pow(2, 8 * t3)), a3;
    }, i2.prototype.readInt8 = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
    }, i2.prototype.readInt16LE = function(e3, t3) {
      e3 >>>= 0, t3 || T2(e3, 2, this.length);
      var r3 = this[e3] | this[e3 + 1] << 8;
      return 32768 & r3 ? 4294901760 | r3 : r3;
    }, i2.prototype.readInt16BE = function(e3, t3) {
      e3 >>>= 0, t3 || T2(e3, 2, this.length);
      var r3 = this[e3 + 1] | this[e3] << 8;
      return 32768 & r3 ? 4294901760 | r3 : r3;
    }, i2.prototype.readInt32LE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
    }, i2.prototype.readInt32BE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
    }, i2.prototype.readFloatLE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 4, this.length), y(this, e3, true, 23, 4);
    }, i2.prototype.readFloatBE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 4, this.length), y(this, e3, false, 23, 4);
    }, i2.prototype.readDoubleLE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 8, this.length), y(this, e3, true, 52, 8);
    }, i2.prototype.readDoubleBE = function(e3, t3) {
      return e3 >>>= 0, t3 || T2(e3, 8, this.length), y(this, e3, false, 52, 8);
    }, i2.prototype.writeUIntLE = function(e3, t3, r3, n3) {
      (e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3) || L2(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
      var i3 = 1, a3 = 0;
      for (this[t3] = 255 & e3; ++a3 < r3 && (i3 *= 256); )
        this[t3 + a3] = e3 / i3 & 255;
      return t3 + r3;
    }, i2.prototype.writeUIntBE = function(e3, t3, r3, n3) {
      (e3 = +e3, t3 >>>= 0, r3 >>>= 0, n3) || L2(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
      var i3 = r3 - 1, a3 = 1;
      for (this[t3 + i3] = 255 & e3; --i3 >= 0 && (a3 *= 256); )
        this[t3 + i3] = e3 / a3 & 255;
      return t3 + r3;
    }, i2.prototype.writeUInt8 = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
    }, i2.prototype.writeUInt16LE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
    }, i2.prototype.writeUInt16BE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
    }, i2.prototype.writeUInt32LE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
    }, i2.prototype.writeUInt32BE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
    }, i2.prototype.writeIntLE = function(e3, t3, r3, n3) {
      if (e3 = +e3, t3 >>>= 0, !n3) {
        var i3 = Math.pow(2, 8 * r3 - 1);
        L2(this, e3, t3, r3, i3 - 1, -i3);
      }
      var a3 = 0, o3 = 1, s3 = 0;
      for (this[t3] = 255 & e3; ++a3 < r3 && (o3 *= 256); )
        e3 < 0 && 0 === s3 && 0 !== this[t3 + a3 - 1] && (s3 = 1), this[t3 + a3] = (e3 / o3 >> 0) - s3 & 255;
      return t3 + r3;
    }, i2.prototype.writeIntBE = function(e3, t3, r3, n3) {
      if (e3 = +e3, t3 >>>= 0, !n3) {
        var i3 = Math.pow(2, 8 * r3 - 1);
        L2(this, e3, t3, r3, i3 - 1, -i3);
      }
      var a3 = r3 - 1, o3 = 1, s3 = 0;
      for (this[t3 + a3] = 255 & e3; --a3 >= 0 && (o3 *= 256); )
        e3 < 0 && 0 === s3 && 0 !== this[t3 + a3 + 1] && (s3 = 1), this[t3 + a3] = (e3 / o3 >> 0) - s3 & 255;
      return t3 + r3;
    }, i2.prototype.writeInt8 = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
    }, i2.prototype.writeInt16LE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
    }, i2.prototype.writeInt16BE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
    }, i2.prototype.writeInt32LE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
    }, i2.prototype.writeInt32BE = function(e3, t3, r3) {
      return e3 = +e3, t3 >>>= 0, r3 || L2(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
    }, i2.prototype.writeFloatLE = function(e3, t3, r3) {
      return U2(this, e3, t3, true, r3);
    }, i2.prototype.writeFloatBE = function(e3, t3, r3) {
      return U2(this, e3, t3, false, r3);
    }, i2.prototype.writeDoubleLE = function(e3, t3, r3) {
      return D2(this, e3, t3, true, r3);
    }, i2.prototype.writeDoubleBE = function(e3, t3, r3) {
      return D2(this, e3, t3, false, r3);
    }, i2.prototype.copy = function(e3, t3, r3, n3) {
      if (!i2.isBuffer(e3))
        throw new TypeError("argument should be a Buffer");
      if (r3 || (r3 = 0), n3 || 0 === n3 || (n3 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n3 > 0 && n3 < r3 && (n3 = r3), n3 === r3)
        return 0;
      if (0 === e3.length || 0 === this.length)
        return 0;
      if (t3 < 0)
        throw new RangeError("targetStart out of bounds");
      if (r3 < 0 || r3 >= this.length)
        throw new RangeError("Index out of range");
      if (n3 < 0)
        throw new RangeError("sourceEnd out of bounds");
      n3 > this.length && (n3 = this.length), e3.length - t3 < n3 - r3 && (n3 = e3.length - t3 + r3);
      var a3 = n3 - r3;
      if (this === e3 && "function" == typeof Uint8Array.prototype.copyWithin)
        this.copyWithin(t3, r3, n3);
      else if (this === e3 && r3 < t3 && t3 < n3)
        for (var o3 = a3 - 1; o3 >= 0; --o3)
          e3[o3 + t3] = this[o3 + r3];
      else
        Uint8Array.prototype.set.call(e3, this.subarray(r3, n3), t3);
      return a3;
    }, i2.prototype.fill = function(e3, t3, r3, n3) {
      if ("string" == typeof e3) {
        if ("string" == typeof t3 ? (n3 = t3, t3 = 0, r3 = this.length) : "string" == typeof r3 && (n3 = r3, r3 = this.length), void 0 !== n3 && "string" != typeof n3)
          throw new TypeError("encoding must be a string");
        if ("string" == typeof n3 && !i2.isEncoding(n3))
          throw new TypeError("Unknown encoding: " + n3);
        if (1 === e3.length) {
          var a3 = e3.charCodeAt(0);
          ("utf8" === n3 && a3 < 128 || "latin1" === n3) && (e3 = a3);
        }
      } else
        "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
      if (t3 < 0 || this.length < t3 || this.length < r3)
        throw new RangeError("Out of range index");
      if (r3 <= t3)
        return this;
      var o3;
      if (t3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3)
        for (o3 = t3; o3 < r3; ++o3)
          this[o3] = e3;
      else {
        var s3 = i2.isBuffer(e3) ? e3 : i2.from(e3, n3), u3 = s3.length;
        if (0 === u3)
          throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
        for (o3 = 0; o3 < r3 - t3; ++o3)
          this[o3 + t3] = s3[o3 % u3];
      }
      return this;
    };
    var j2 = /[^+/0-9A-Za-z-_]/g;
    function M2(e3, t3) {
      var r3;
      t3 = t3 || 1 / 0;
      for (var n3 = e3.length, i3 = null, a3 = [], o3 = 0; o3 < n3; ++o3) {
        if ((r3 = e3.charCodeAt(o3)) > 55295 && r3 < 57344) {
          if (!i3) {
            if (r3 > 56319) {
              (t3 -= 3) > -1 && a3.push(239, 191, 189);
              continue;
            }
            if (o3 + 1 === n3) {
              (t3 -= 3) > -1 && a3.push(239, 191, 189);
              continue;
            }
            i3 = r3;
            continue;
          }
          if (r3 < 56320) {
            (t3 -= 3) > -1 && a3.push(239, 191, 189), i3 = r3;
            continue;
          }
          r3 = 65536 + (i3 - 55296 << 10 | r3 - 56320);
        } else
          i3 && (t3 -= 3) > -1 && a3.push(239, 191, 189);
        if (i3 = null, r3 < 128) {
          if ((t3 -= 1) < 0)
            break;
          a3.push(r3);
        } else if (r3 < 2048) {
          if ((t3 -= 2) < 0)
            break;
          a3.push(r3 >> 6 | 192, 63 & r3 | 128);
        } else if (r3 < 65536) {
          if ((t3 -= 3) < 0)
            break;
          a3.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
        } else {
          if (!(r3 < 1114112))
            throw new Error("Invalid code point");
          if ((t3 -= 4) < 0)
            break;
          a3.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
        }
      }
      return a3;
    }
    function F2(e3) {
      return p.toByteArray(function(e4) {
        if ((e4 = (e4 = e4.split("=")[0]).trim().replace(j2, "")).length < 2)
          return "";
        for (; e4.length % 4 != 0; )
          e4 += "=";
        return e4;
      }(e3));
    }
    function R2(e3, t3, r3, n3) {
      for (var i3 = 0; i3 < n3 && !(i3 + r3 >= t3.length || i3 >= e3.length); ++i3)
        t3[i3 + r3] = e3[i3];
      return i3;
    }
    function N2(e3, t3) {
      return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
    }
    function q2(e3) {
      return e3 != e3;
    }
    var G2 = function() {
      for (var e3 = new Array(256), t3 = 0; t3 < 16; ++t3)
        for (var r3 = 16 * t3, n3 = 0; n3 < 16; ++n3)
          e3[r3 + n3] = "0123456789abcdef"[t3] + "0123456789abcdef"[n3];
      return e3;
    }();
  }), b = v.Buffer;
  v.SlowBuffer, v.INSPECT_MAX_BYTES, v.kMaxLength;
  function m() {
  }
  function w() {
    w.init.call(this);
  }
  function S(e2) {
    return void 0 === e2._maxListeners ? w.defaultMaxListeners : e2._maxListeners;
  }
  function x(e2, t2, r2) {
    if (t2)
      e2.call(r2);
    else
      for (var n2 = e2.length, i2 = B(e2, n2), a2 = 0; a2 < n2; ++a2)
        i2[a2].call(r2);
  }
  function A(e2, t2, r2, n2) {
    if (t2)
      e2.call(r2, n2);
    else
      for (var i2 = e2.length, a2 = B(e2, i2), o2 = 0; o2 < i2; ++o2)
        a2[o2].call(r2, n2);
  }
  function k(e2, t2, r2, n2, i2) {
    if (t2)
      e2.call(r2, n2, i2);
    else
      for (var a2 = e2.length, o2 = B(e2, a2), s2 = 0; s2 < a2; ++s2)
        o2[s2].call(r2, n2, i2);
  }
  function C(e2, t2, r2, n2, i2, a2) {
    if (t2)
      e2.call(r2, n2, i2, a2);
    else
      for (var o2 = e2.length, s2 = B(e2, o2), u2 = 0; u2 < o2; ++u2)
        s2[u2].call(r2, n2, i2, a2);
  }
  function P(e2, t2, r2, n2) {
    if (t2)
      e2.apply(r2, n2);
    else
      for (var i2 = e2.length, a2 = B(e2, i2), o2 = 0; o2 < i2; ++o2)
        a2[o2].apply(r2, n2);
  }
  function I(e2, t2, r2, n2) {
    var i2, a2, o2, s2;
    if ("function" != typeof r2)
      throw new TypeError('"listener" argument must be a function');
    if ((a2 = e2._events) ? (a2.newListener && (e2.emit("newListener", t2, r2.listener ? r2.listener : r2), a2 = e2._events), o2 = a2[t2]) : (a2 = e2._events = new m(), e2._eventsCount = 0), o2) {
      if ("function" == typeof o2 ? o2 = a2[t2] = n2 ? [r2, o2] : [o2, r2] : n2 ? o2.unshift(r2) : o2.push(r2), !o2.warned && (i2 = S(e2)) && i2 > 0 && o2.length > i2) {
        o2.warned = true;
        var u2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + t2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        u2.name = "MaxListenersExceededWarning", u2.emitter = e2, u2.type = t2, u2.count = o2.length, s2 = u2, "function" == typeof console.warn ? console.warn(s2) : console.log(s2);
      }
    } else
      o2 = a2[t2] = r2, ++e2._eventsCount;
    return e2;
  }
  function O(e2, t2, r2) {
    var n2 = false;
    function i2() {
      e2.removeListener(t2, i2), n2 || (n2 = true, r2.apply(e2, arguments));
    }
    return i2.listener = r2, i2;
  }
  function E(e2) {
    var t2 = this._events;
    if (t2) {
      var r2 = t2[e2];
      if ("function" == typeof r2)
        return 1;
      if (r2)
        return r2.length;
    }
    return 0;
  }
  function B(e2, t2) {
    for (var r2 = new Array(t2); t2--; )
      r2[t2] = e2[t2];
    return r2;
  }
  m.prototype = /* @__PURE__ */ Object.create(null), w.EventEmitter = w, w.usingDomains = false, w.prototype.domain = void 0, w.prototype._events = void 0, w.prototype._maxListeners = void 0, w.defaultMaxListeners = 10, w.init = function() {
    this.domain = null, w.usingDomains && (void 0).active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new m(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, w.prototype.setMaxListeners = function(e2) {
    if ("number" != typeof e2 || e2 < 0 || isNaN(e2))
      throw new TypeError('"n" argument must be a positive number');
    return this._maxListeners = e2, this;
  }, w.prototype.getMaxListeners = function() {
    return S(this);
  }, w.prototype.emit = function(e2) {
    var t2, r2, n2, i2, a2, o2, s2, u2 = "error" === e2;
    if (o2 = this._events)
      u2 = u2 && null == o2.error;
    else if (!u2)
      return false;
    if (s2 = this.domain, u2) {
      if (t2 = arguments[1], !s2) {
        if (t2 instanceof Error)
          throw t2;
        var l2 = new Error('Uncaught, unspecified "error" event. (' + t2 + ")");
        throw l2.context = t2, l2;
      }
      return t2 || (t2 = new Error('Uncaught, unspecified "error" event')), t2.domainEmitter = this, t2.domain = s2, t2.domainThrown = false, s2.emit("error", t2), false;
    }
    if (!(r2 = o2[e2]))
      return false;
    var c2 = "function" == typeof r2;
    switch (n2 = arguments.length) {
      case 1:
        x(r2, c2, this);
        break;
      case 2:
        A(r2, c2, this, arguments[1]);
        break;
      case 3:
        k(r2, c2, this, arguments[1], arguments[2]);
        break;
      case 4:
        C(r2, c2, this, arguments[1], arguments[2], arguments[3]);
        break;
      default:
        for (i2 = new Array(n2 - 1), a2 = 1; a2 < n2; a2++)
          i2[a2 - 1] = arguments[a2];
        P(r2, c2, this, i2);
    }
    return true;
  }, w.prototype.addListener = function(e2, t2) {
    return I(this, e2, t2, false);
  }, w.prototype.on = w.prototype.addListener, w.prototype.prependListener = function(e2, t2) {
    return I(this, e2, t2, true);
  }, w.prototype.once = function(e2, t2) {
    if ("function" != typeof t2)
      throw new TypeError('"listener" argument must be a function');
    return this.on(e2, O(this, e2, t2)), this;
  }, w.prototype.prependOnceListener = function(e2, t2) {
    if ("function" != typeof t2)
      throw new TypeError('"listener" argument must be a function');
    return this.prependListener(e2, O(this, e2, t2)), this;
  }, w.prototype.removeListener = function(e2, t2) {
    var r2, n2, i2, a2, o2;
    if ("function" != typeof t2)
      throw new TypeError('"listener" argument must be a function');
    if (!(n2 = this._events))
      return this;
    if (!(r2 = n2[e2]))
      return this;
    if (r2 === t2 || r2.listener && r2.listener === t2)
      0 == --this._eventsCount ? this._events = new m() : (delete n2[e2], n2.removeListener && this.emit("removeListener", e2, r2.listener || t2));
    else if ("function" != typeof r2) {
      for (i2 = -1, a2 = r2.length; a2-- > 0; )
        if (r2[a2] === t2 || r2[a2].listener && r2[a2].listener === t2) {
          o2 = r2[a2].listener, i2 = a2;
          break;
        }
      if (i2 < 0)
        return this;
      if (1 === r2.length) {
        if (r2[0] = void 0, 0 == --this._eventsCount)
          return this._events = new m(), this;
        delete n2[e2];
      } else
        !function(e3, t3) {
          for (var r3 = t3, n3 = r3 + 1, i3 = e3.length; n3 < i3; r3 += 1, n3 += 1)
            e3[r3] = e3[n3];
          e3.pop();
        }(r2, i2);
      n2.removeListener && this.emit("removeListener", e2, o2 || t2);
    }
    return this;
  }, w.prototype.removeAllListeners = function(e2) {
    var t2, r2;
    if (!(r2 = this._events))
      return this;
    if (!r2.removeListener)
      return 0 === arguments.length ? (this._events = new m(), this._eventsCount = 0) : r2[e2] && (0 == --this._eventsCount ? this._events = new m() : delete r2[e2]), this;
    if (0 === arguments.length) {
      for (var n2, i2 = Object.keys(r2), a2 = 0; a2 < i2.length; ++a2)
        "removeListener" !== (n2 = i2[a2]) && this.removeAllListeners(n2);
      return this.removeAllListeners("removeListener"), this._events = new m(), this._eventsCount = 0, this;
    }
    if ("function" == typeof (t2 = r2[e2]))
      this.removeListener(e2, t2);
    else if (t2)
      do {
        this.removeListener(e2, t2[t2.length - 1]);
      } while (t2[0]);
    return this;
  }, w.prototype.listeners = function(e2) {
    var t2, r2 = this._events;
    return r2 && (t2 = r2[e2]) ? "function" == typeof t2 ? [t2.listener || t2] : function(e3) {
      for (var t3 = new Array(e3.length), r3 = 0; r3 < t3.length; ++r3)
        t3[r3] = e3[r3].listener || e3[r3];
      return t3;
    }(t2) : [];
  }, w.listenerCount = function(e2, t2) {
    return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : E.call(e2, t2);
  }, w.prototype.listenerCount = E, w.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  var T = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
  function L() {
    throw new Error("setTimeout has not been defined");
  }
  function z() {
    throw new Error("clearTimeout has not been defined");
  }
  var U = L, D = z;
  function j(e2) {
    if (U === setTimeout)
      return setTimeout(e2, 0);
    if ((U === L || !U) && setTimeout)
      return U = setTimeout, setTimeout(e2, 0);
    try {
      return U(e2, 0);
    } catch (t2) {
      try {
        return U.call(null, e2, 0);
      } catch (t3) {
        return U.call(this, e2, 0);
      }
    }
  }
  "function" == typeof T.setTimeout && (U = setTimeout), "function" == typeof T.clearTimeout && (D = clearTimeout);
  var M, F = [], R = false, N = -1;
  function q() {
    R && M && (R = false, M.length ? F = M.concat(F) : N = -1, F.length && G());
  }
  function G() {
    if (!R) {
      var e2 = j(q);
      R = true;
      for (var t2 = F.length; t2; ) {
        for (M = F, F = []; ++N < t2; )
          M && M[N].run();
        N = -1, t2 = F.length;
      }
      M = null, R = false, function(e3) {
        if (D === clearTimeout)
          return clearTimeout(e3);
        if ((D === z || !D) && clearTimeout)
          return D = clearTimeout, clearTimeout(e3);
        try {
          D(e3);
        } catch (t3) {
          try {
            return D.call(null, e3);
          } catch (t4) {
            return D.call(this, e3);
          }
        }
      }(e2);
    }
  }
  function V(e2) {
    var t2 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r2 = 1; r2 < arguments.length; r2++)
        t2[r2 - 1] = arguments[r2];
    F.push(new _(e2, t2)), 1 !== F.length || R || j(G);
  }
  function _(e2, t2) {
    this.fun = e2, this.array = t2;
  }
  _.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  function W() {
  }
  var H = W, Y = W, X = W, Z = W, K = W, J = W, Q = W;
  var $ = T.performance || {}, ee = $.now || $.mozNow || $.msNow || $.oNow || $.webkitNow || function() {
    return (/* @__PURE__ */ new Date()).getTime();
  };
  var te = /* @__PURE__ */ new Date();
  var re = { nextTick: V, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: H, addListener: Y, once: X, off: Z, removeListener: K, removeAllListeners: J, emit: Q, binding: function(e2) {
    throw new Error("process.binding is not supported");
  }, cwd: function() {
    return "/";
  }, chdir: function(e2) {
    throw new Error("process.chdir is not supported");
  }, umask: function() {
    return 0;
  }, hrtime: function(e2) {
    var t2 = 1e-3 * ee.call($), r2 = Math.floor(t2), n2 = Math.floor(t2 % 1 * 1e9);
    return e2 && (r2 -= e2[0], (n2 -= e2[1]) < 0 && (r2--, n2 += 1e9)), [r2, n2];
  }, platform: "browser", release: {}, config: {}, uptime: function() {
    return (/* @__PURE__ */ new Date() - te) / 1e3;
  } }, ne = "function" == typeof Object.create ? function(e2, t2) {
    e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
  } : function(e2, t2) {
    e2.super_ = t2;
    var r2 = function() {
    };
    r2.prototype = t2.prototype, e2.prototype = new r2(), e2.prototype.constructor = e2;
  }, ie = /%[sdj%]/g;
  function ae(e2) {
    if (!we(e2)) {
      for (var t2 = [], r2 = 0; r2 < arguments.length; r2++)
        t2.push(ce(arguments[r2]));
      return t2.join(" ");
    }
    r2 = 1;
    for (var n2 = arguments, i2 = n2.length, a2 = String(e2).replace(ie, function(e3) {
      if ("%%" === e3)
        return "%";
      if (r2 >= i2)
        return e3;
      switch (e3) {
        case "%s":
          return String(n2[r2++]);
        case "%d":
          return Number(n2[r2++]);
        case "%j":
          try {
            return JSON.stringify(n2[r2++]);
          } catch (e4) {
            return "[Circular]";
          }
        default:
          return e3;
      }
    }), o2 = n2[r2]; r2 < i2; o2 = n2[++r2])
      be(o2) || !Ae(o2) ? a2 += " " + o2 : a2 += " " + ce(o2);
    return a2;
  }
  function oe(e2, t2) {
    if (Se(T.process))
      return function() {
        return oe(e2, t2).apply(this, arguments);
      };
    if (true === re.noDeprecation)
      return e2;
    var r2 = false;
    return function() {
      if (!r2) {
        if (re.throwDeprecation)
          throw new Error(t2);
        re.traceDeprecation ? console.trace(t2) : console.error(t2), r2 = true;
      }
      return e2.apply(this, arguments);
    };
  }
  var se, ue = {};
  function le(e2) {
    if (Se(se) && (se = re.env.NODE_DEBUG || ""), e2 = e2.toUpperCase(), !ue[e2])
      if (new RegExp("\\b" + e2 + "\\b", "i").test(se)) {
        ue[e2] = function() {
          var t2 = ae.apply(null, arguments);
          console.error("%s %d: %s", e2, 0, t2);
        };
      } else
        ue[e2] = function() {
        };
    return ue[e2];
  }
  function ce(e2, t2) {
    var r2 = { seen: [], stylize: he };
    return arguments.length >= 3 && (r2.depth = arguments[2]), arguments.length >= 4 && (r2.colors = arguments[3]), ve(t2) ? r2.showHidden = t2 : t2 && Oe(r2, t2), Se(r2.showHidden) && (r2.showHidden = false), Se(r2.depth) && (r2.depth = 2), Se(r2.colors) && (r2.colors = false), Se(r2.customInspect) && (r2.customInspect = true), r2.colors && (r2.stylize = fe), de(r2, e2, r2.depth);
  }
  function fe(e2, t2) {
    var r2 = ce.styles[t2];
    return r2 ? "\x1B[" + ce.colors[r2][0] + "m" + e2 + "\x1B[" + ce.colors[r2][1] + "m" : e2;
  }
  function he(e2, t2) {
    return e2;
  }
  function de(e2, t2, r2) {
    if (e2.customInspect && t2 && Pe(t2.inspect) && t2.inspect !== ce && (!t2.constructor || t2.constructor.prototype !== t2)) {
      var n2 = t2.inspect(r2, e2);
      return we(n2) || (n2 = de(e2, n2, r2)), n2;
    }
    var i2 = function(e3, t3) {
      if (Se(t3))
        return e3.stylize("undefined", "undefined");
      if (we(t3)) {
        var r3 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e3.stylize(r3, "string");
      }
      if (me(t3))
        return e3.stylize("" + t3, "number");
      if (ve(t3))
        return e3.stylize("" + t3, "boolean");
      if (be(t3))
        return e3.stylize("null", "null");
    }(e2, t2);
    if (i2)
      return i2;
    var a2 = Object.keys(t2), o2 = function(e3) {
      var t3 = {};
      return e3.forEach(function(e4, r3) {
        t3[e4] = true;
      }), t3;
    }(a2);
    if (e2.showHidden && (a2 = Object.getOwnPropertyNames(t2)), Ce(t2) && (a2.indexOf("message") >= 0 || a2.indexOf("description") >= 0))
      return pe(t2);
    if (0 === a2.length) {
      if (Pe(t2)) {
        var s2 = t2.name ? ": " + t2.name : "";
        return e2.stylize("[Function" + s2 + "]", "special");
      }
      if (xe(t2))
        return e2.stylize(RegExp.prototype.toString.call(t2), "regexp");
      if (ke(t2))
        return e2.stylize(Date.prototype.toString.call(t2), "date");
      if (Ce(t2))
        return pe(t2);
    }
    var u2, l2 = "", c2 = false, f2 = ["{", "}"];
    (ge(t2) && (c2 = true, f2 = ["[", "]"]), Pe(t2)) && (l2 = " [Function" + (t2.name ? ": " + t2.name : "") + "]");
    return xe(t2) && (l2 = " " + RegExp.prototype.toString.call(t2)), ke(t2) && (l2 = " " + Date.prototype.toUTCString.call(t2)), Ce(t2) && (l2 = " " + pe(t2)), 0 !== a2.length || c2 && 0 != t2.length ? r2 < 0 ? xe(t2) ? e2.stylize(RegExp.prototype.toString.call(t2), "regexp") : e2.stylize("[Object]", "special") : (e2.seen.push(t2), u2 = c2 ? function(e3, t3, r3, n3, i3) {
      for (var a3 = [], o3 = 0, s3 = t3.length; o3 < s3; ++o3)
        Ee(t3, String(o3)) ? a3.push(ye(e3, t3, r3, n3, String(o3), true)) : a3.push("");
      return i3.forEach(function(i4) {
        i4.match(/^\d+$/) || a3.push(ye(e3, t3, r3, n3, i4, true));
      }), a3;
    }(e2, t2, r2, o2, a2) : a2.map(function(n3) {
      return ye(e2, t2, r2, o2, n3, c2);
    }), e2.seen.pop(), function(e3, t3, r3) {
      if (e3.reduce(function(e4, t4) {
        return t4.indexOf("\n"), e4 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return r3[0] + ("" === t3 ? "" : t3 + "\n ") + " " + e3.join(",\n  ") + " " + r3[1];
      return r3[0] + t3 + " " + e3.join(", ") + " " + r3[1];
    }(u2, l2, f2)) : f2[0] + l2 + f2[1];
  }
  function pe(e2) {
    return "[" + Error.prototype.toString.call(e2) + "]";
  }
  function ye(e2, t2, r2, n2, i2, a2) {
    var o2, s2, u2;
    if ((u2 = Object.getOwnPropertyDescriptor(t2, i2) || { value: t2[i2] }).get ? s2 = u2.set ? e2.stylize("[Getter/Setter]", "special") : e2.stylize("[Getter]", "special") : u2.set && (s2 = e2.stylize("[Setter]", "special")), Ee(n2, i2) || (o2 = "[" + i2 + "]"), s2 || (e2.seen.indexOf(u2.value) < 0 ? (s2 = be(r2) ? de(e2, u2.value, null) : de(e2, u2.value, r2 - 1)).indexOf("\n") > -1 && (s2 = a2 ? s2.split("\n").map(function(e3) {
      return "  " + e3;
    }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e3) {
      return "   " + e3;
    }).join("\n")) : s2 = e2.stylize("[Circular]", "special")), Se(o2)) {
      if (a2 && i2.match(/^\d+$/))
        return s2;
      (o2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e2.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e2.stylize(o2, "string"));
    }
    return o2 + ": " + s2;
  }
  function ge(e2) {
    return Array.isArray(e2);
  }
  function ve(e2) {
    return "boolean" == typeof e2;
  }
  function be(e2) {
    return null === e2;
  }
  function me(e2) {
    return "number" == typeof e2;
  }
  function we(e2) {
    return "string" == typeof e2;
  }
  function Se(e2) {
    return void 0 === e2;
  }
  function xe(e2) {
    return Ae(e2) && "[object RegExp]" === Ie(e2);
  }
  function Ae(e2) {
    return "object" == typeof e2 && null !== e2;
  }
  function ke(e2) {
    return Ae(e2) && "[object Date]" === Ie(e2);
  }
  function Ce(e2) {
    return Ae(e2) && ("[object Error]" === Ie(e2) || e2 instanceof Error);
  }
  function Pe(e2) {
    return "function" == typeof e2;
  }
  function Ie(e2) {
    return Object.prototype.toString.call(e2);
  }
  ce.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, ce.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
  function Oe(e2, t2) {
    if (!t2 || !Ae(t2))
      return e2;
    for (var r2 = Object.keys(t2), n2 = r2.length; n2--; )
      e2[r2[n2]] = t2[r2[n2]];
    return e2;
  }
  function Ee(e2, t2) {
    return Object.prototype.hasOwnProperty.call(e2, t2);
  }
  var Be = ce;
  function Te() {
    this.head = null, this.tail = null, this.length = 0;
  }
  Te.prototype.push = function(e2) {
    var t2 = { data: e2, next: null };
    this.length > 0 ? this.tail.next = t2 : this.head = t2, this.tail = t2, ++this.length;
  }, Te.prototype.unshift = function(e2) {
    var t2 = { data: e2, next: this.head };
    0 === this.length && (this.tail = t2), this.head = t2, ++this.length;
  }, Te.prototype.shift = function() {
    if (0 !== this.length) {
      var e2 = this.head.data;
      return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e2;
    }
  }, Te.prototype.clear = function() {
    this.head = this.tail = null, this.length = 0;
  }, Te.prototype.join = function(e2) {
    if (0 === this.length)
      return "";
    for (var t2 = this.head, r2 = "" + t2.data; t2 = t2.next; )
      r2 += e2 + t2.data;
    return r2;
  }, Te.prototype.concat = function(e2) {
    if (0 === this.length)
      return b.alloc(0);
    if (1 === this.length)
      return this.head.data;
    for (var t2 = b.allocUnsafe(e2 >>> 0), r2 = this.head, n2 = 0; r2; )
      r2.data.copy(t2, n2), n2 += r2.data.length, r2 = r2.next;
    return t2;
  };
  var Le = t(function(e2, t2) {
    var r2 = v.Buffer, n2 = r2.isEncoding || function(e3) {
      switch (e3 && e3.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    var i2 = t2.StringDecoder = function(e3) {
      switch (this.encoding = (e3 || "utf8").toLowerCase().replace(/[-_]/, ""), function(e4) {
        if (e4 && !n2(e4))
          throw new Error("Unknown encoding: " + e4);
      }(e3), this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2, this.detectIncompleteChar = o2;
          break;
        case "base64":
          this.surrogateSize = 3, this.detectIncompleteChar = s2;
          break;
        default:
          return void (this.write = a2);
      }
      this.charBuffer = new r2(6), this.charReceived = 0, this.charLength = 0;
    };
    function a2(e3) {
      return e3.toString(this.encoding);
    }
    function o2(e3) {
      this.charReceived = e3.length % 2, this.charLength = this.charReceived ? 2 : 0;
    }
    function s2(e3) {
      this.charReceived = e3.length % 3, this.charLength = this.charReceived ? 3 : 0;
    }
    i2.prototype.write = function(e3) {
      for (var t3 = ""; this.charLength; ) {
        var r3 = e3.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : e3.length;
        if (e3.copy(this.charBuffer, this.charReceived, 0, r3), this.charReceived += r3, this.charReceived < this.charLength)
          return "";
        if (e3 = e3.slice(r3, e3.length), !((i3 = (t3 = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(t3.length - 1)) >= 55296 && i3 <= 56319)) {
          if (this.charReceived = this.charLength = 0, 0 === e3.length)
            return t3;
          break;
        }
        this.charLength += this.surrogateSize, t3 = "";
      }
      this.detectIncompleteChar(e3);
      var n3 = e3.length;
      this.charLength && (e3.copy(this.charBuffer, 0, e3.length - this.charReceived, n3), n3 -= this.charReceived);
      var i3;
      n3 = (t3 += e3.toString(this.encoding, 0, n3)).length - 1;
      if ((i3 = t3.charCodeAt(n3)) >= 55296 && i3 <= 56319) {
        var a3 = this.surrogateSize;
        return this.charLength += a3, this.charReceived += a3, this.charBuffer.copy(this.charBuffer, a3, 0, a3), e3.copy(this.charBuffer, 0, 0, a3), t3.substring(0, n3);
      }
      return t3;
    }, i2.prototype.detectIncompleteChar = function(e3) {
      for (var t3 = e3.length >= 3 ? 3 : e3.length; t3 > 0; t3--) {
        var r3 = e3[e3.length - t3];
        if (1 == t3 && r3 >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (t3 <= 2 && r3 >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (t3 <= 3 && r3 >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = t3;
    }, i2.prototype.end = function(e3) {
      var t3 = "";
      if (e3 && e3.length && (t3 = this.write(e3)), this.charReceived) {
        var r3 = this.charReceived, n3 = this.charBuffer, i3 = this.encoding;
        t3 += n3.slice(0, r3).toString(i3);
      }
      return t3;
    };
  }), ze = Le.StringDecoder;
  je.ReadableState = De;
  var Ue = le("stream");
  function De(e2, t2) {
    e2 = e2 || {}, this.objectMode = !!e2.objectMode, t2 instanceof lt && (this.objectMode = this.objectMode || !!e2.readableObjectMode);
    var r2 = e2.highWaterMark, n2 = this.objectMode ? 16 : 16384;
    this.highWaterMark = r2 || 0 === r2 ? r2 : n2, this.highWaterMark = ~~this.highWaterMark, this.buffer = new Te(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.defaultEncoding = e2.defaultEncoding || "utf8", this.ranOut = false, this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e2.encoding && (this.decoder = new ze(e2.encoding), this.encoding = e2.encoding);
  }
  function je(e2) {
    if (!(this instanceof je))
      return new je(e2);
    this._readableState = new De(e2, this), this.readable = true, e2 && "function" == typeof e2.read && (this._read = e2.read), w.call(this);
  }
  function Me(e2, t2, r2, n2, i2) {
    var a2 = function(e3, t3) {
      var r3 = null;
      b.isBuffer(t3) || "string" == typeof t3 || null == t3 || e3.objectMode || (r3 = new TypeError("Invalid non-string/buffer chunk"));
      return r3;
    }(t2, r2);
    if (a2)
      e2.emit("error", a2);
    else if (null === r2)
      t2.reading = false, function(e3, t3) {
        if (t3.ended)
          return;
        if (t3.decoder) {
          var r3 = t3.decoder.end();
          r3 && r3.length && (t3.buffer.push(r3), t3.length += t3.objectMode ? 1 : r3.length);
        }
        t3.ended = true, Re(e3);
      }(e2, t2);
    else if (t2.objectMode || r2 && r2.length > 0)
      if (t2.ended && !i2) {
        var o2 = new Error("stream.push() after EOF");
        e2.emit("error", o2);
      } else if (t2.endEmitted && i2) {
        var s2 = new Error("stream.unshift() after end event");
        e2.emit("error", s2);
      } else {
        var u2;
        !t2.decoder || i2 || n2 || (r2 = t2.decoder.write(r2), u2 = !t2.objectMode && 0 === r2.length), i2 || (t2.reading = false), u2 || (t2.flowing && 0 === t2.length && !t2.sync ? (e2.emit("data", r2), e2.read(0)) : (t2.length += t2.objectMode ? 1 : r2.length, i2 ? t2.buffer.unshift(r2) : t2.buffer.push(r2), t2.needReadable && Re(e2))), function(e3, t3) {
          t3.readingMore || (t3.readingMore = true, V(qe, e3, t3));
        }(e2, t2);
      }
    else
      i2 || (t2.reading = false);
    return function(e3) {
      return !e3.ended && (e3.needReadable || e3.length < e3.highWaterMark || 0 === e3.length);
    }(t2);
  }
  ne(je, w), je.prototype.push = function(e2, t2) {
    var r2 = this._readableState;
    return r2.objectMode || "string" != typeof e2 || (t2 = t2 || r2.defaultEncoding) !== r2.encoding && (e2 = b.from(e2, t2), t2 = ""), Me(this, r2, e2, t2, false);
  }, je.prototype.unshift = function(e2) {
    return Me(this, this._readableState, e2, "", true);
  }, je.prototype.isPaused = function() {
    return false === this._readableState.flowing;
  }, je.prototype.setEncoding = function(e2) {
    return this._readableState.decoder = new ze(e2), this._readableState.encoding = e2, this;
  };
  function Fe(e2, t2) {
    return e2 <= 0 || 0 === t2.length && t2.ended ? 0 : t2.objectMode ? 1 : e2 != e2 ? t2.flowing && t2.length ? t2.buffer.head.data.length : t2.length : (e2 > t2.highWaterMark && (t2.highWaterMark = function(e3) {
      return e3 >= 8388608 ? e3 = 8388608 : (e3--, e3 |= e3 >>> 1, e3 |= e3 >>> 2, e3 |= e3 >>> 4, e3 |= e3 >>> 8, e3 |= e3 >>> 16, e3++), e3;
    }(e2)), e2 <= t2.length ? e2 : t2.ended ? t2.length : (t2.needReadable = true, 0));
  }
  function Re(e2) {
    var t2 = e2._readableState;
    t2.needReadable = false, t2.emittedReadable || (Ue("emitReadable", t2.flowing), t2.emittedReadable = true, t2.sync ? V(Ne, e2) : Ne(e2));
  }
  function Ne(e2) {
    Ue("emit readable"), e2.emit("readable"), _e(e2);
  }
  function qe(e2, t2) {
    for (var r2 = t2.length; !t2.reading && !t2.flowing && !t2.ended && t2.length < t2.highWaterMark && (Ue("maybeReadMore read 0"), e2.read(0), r2 !== t2.length); )
      r2 = t2.length;
    t2.readingMore = false;
  }
  function Ge(e2) {
    Ue("readable nexttick read 0"), e2.read(0);
  }
  function Ve(e2, t2) {
    t2.reading || (Ue("resume read 0"), e2.read(0)), t2.resumeScheduled = false, t2.awaitDrain = 0, e2.emit("resume"), _e(e2), t2.flowing && !t2.reading && e2.read(0);
  }
  function _e(e2) {
    var t2 = e2._readableState;
    for (Ue("flow", t2.flowing); t2.flowing && null !== e2.read(); )
      ;
  }
  function We(e2, t2) {
    return 0 === t2.length ? null : (t2.objectMode ? r2 = t2.buffer.shift() : !e2 || e2 >= t2.length ? (r2 = t2.decoder ? t2.buffer.join("") : 1 === t2.buffer.length ? t2.buffer.head.data : t2.buffer.concat(t2.length), t2.buffer.clear()) : r2 = function(e3, t3, r3) {
      var n2;
      e3 < t3.head.data.length ? (n2 = t3.head.data.slice(0, e3), t3.head.data = t3.head.data.slice(e3)) : n2 = e3 === t3.head.data.length ? t3.shift() : r3 ? function(e4, t4) {
        var r4 = t4.head, n3 = 1, i2 = r4.data;
        e4 -= i2.length;
        for (; r4 = r4.next; ) {
          var a2 = r4.data, o2 = e4 > a2.length ? a2.length : e4;
          if (o2 === a2.length ? i2 += a2 : i2 += a2.slice(0, e4), 0 === (e4 -= o2)) {
            o2 === a2.length ? (++n3, r4.next ? t4.head = r4.next : t4.head = t4.tail = null) : (t4.head = r4, r4.data = a2.slice(o2));
            break;
          }
          ++n3;
        }
        return t4.length -= n3, i2;
      }(e3, t3) : function(e4, t4) {
        var r4 = b.allocUnsafe(e4), n3 = t4.head, i2 = 1;
        n3.data.copy(r4), e4 -= n3.data.length;
        for (; n3 = n3.next; ) {
          var a2 = n3.data, o2 = e4 > a2.length ? a2.length : e4;
          if (a2.copy(r4, r4.length - e4, 0, o2), 0 === (e4 -= o2)) {
            o2 === a2.length ? (++i2, n3.next ? t4.head = n3.next : t4.head = t4.tail = null) : (t4.head = n3, n3.data = a2.slice(o2));
            break;
          }
          ++i2;
        }
        return t4.length -= i2, r4;
      }(e3, t3);
      return n2;
    }(e2, t2.buffer, t2.decoder), r2);
    var r2;
  }
  function He(e2) {
    var t2 = e2._readableState;
    if (t2.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    t2.endEmitted || (t2.ended = true, V(Ye, t2, e2));
  }
  function Ye(e2, t2) {
    e2.endEmitted || 0 !== e2.length || (e2.endEmitted = true, t2.readable = false, t2.emit("end"));
  }
  function Xe(e2, t2) {
    for (var r2 = 0, n2 = e2.length; r2 < n2; r2++)
      if (e2[r2] === t2)
        return r2;
    return -1;
  }
  function Ze() {
  }
  function Ke(e2, t2, r2) {
    this.chunk = e2, this.encoding = t2, this.callback = r2, this.next = null;
  }
  function Je(e2, t2) {
    Object.defineProperty(this, "buffer", { get: oe(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.") }), e2 = e2 || {}, this.objectMode = !!e2.objectMode, t2 instanceof lt && (this.objectMode = this.objectMode || !!e2.writableObjectMode);
    var r2 = e2.highWaterMark, n2 = this.objectMode ? 16 : 16384;
    this.highWaterMark = r2 || 0 === r2 ? r2 : n2, this.highWaterMark = ~~this.highWaterMark, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false;
    var i2 = false === e2.decodeStrings;
    this.decodeStrings = !i2, this.defaultEncoding = e2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e3) {
      !function(e4, t3) {
        var r3 = e4._writableState, n3 = r3.sync, i3 = r3.writecb;
        if (function(e5) {
          e5.writing = false, e5.writecb = null, e5.length -= e5.writelen, e5.writelen = 0;
        }(r3), t3)
          !function(e5, t4, r4, n4, i4) {
            --t4.pendingcb, r4 ? V(i4, n4) : i4(n4);
            e5._writableState.errorEmitted = true, e5.emit("error", n4);
          }(e4, r3, n3, t3, i3);
        else {
          var a2 = rt(r3);
          a2 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || tt(e4, r3), n3 ? V(et, e4, r3, a2, i3) : et(e4, r3, a2, i3);
        }
      }(t2, e3);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.bufferedRequestCount = 0, this.corkedRequestsFree = new at(this);
  }
  function Qe(e2) {
    if (!(this instanceof Qe || this instanceof lt))
      return new Qe(e2);
    this._writableState = new Je(e2, this), this.writable = true, e2 && ("function" == typeof e2.write && (this._write = e2.write), "function" == typeof e2.writev && (this._writev = e2.writev)), w.call(this);
  }
  function $e(e2, t2, r2, n2, i2, a2, o2) {
    t2.writelen = n2, t2.writecb = o2, t2.writing = true, t2.sync = true, r2 ? e2._writev(i2, t2.onwrite) : e2._write(i2, a2, t2.onwrite), t2.sync = false;
  }
  function et(e2, t2, r2, n2) {
    r2 || function(e3, t3) {
      0 === t3.length && t3.needDrain && (t3.needDrain = false, e3.emit("drain"));
    }(e2, t2), t2.pendingcb--, n2(), it(e2, t2);
  }
  function tt(e2, t2) {
    t2.bufferProcessing = true;
    var r2 = t2.bufferedRequest;
    if (e2._writev && r2 && r2.next) {
      var n2 = t2.bufferedRequestCount, i2 = new Array(n2), a2 = t2.corkedRequestsFree;
      a2.entry = r2;
      for (var o2 = 0; r2; )
        i2[o2] = r2, r2 = r2.next, o2 += 1;
      $e(e2, t2, true, t2.length, i2, "", a2.finish), t2.pendingcb++, t2.lastBufferedRequest = null, a2.next ? (t2.corkedRequestsFree = a2.next, a2.next = null) : t2.corkedRequestsFree = new at(t2);
    } else {
      for (; r2; ) {
        var s2 = r2.chunk, u2 = r2.encoding, l2 = r2.callback;
        if ($e(e2, t2, false, t2.objectMode ? 1 : s2.length, s2, u2, l2), r2 = r2.next, t2.writing)
          break;
      }
      null === r2 && (t2.lastBufferedRequest = null);
    }
    t2.bufferedRequestCount = 0, t2.bufferedRequest = r2, t2.bufferProcessing = false;
  }
  function rt(e2) {
    return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
  }
  function nt(e2, t2) {
    t2.prefinished || (t2.prefinished = true, e2.emit("prefinish"));
  }
  function it(e2, t2) {
    var r2 = rt(t2);
    return r2 && (0 === t2.pendingcb ? (nt(e2, t2), t2.finished = true, e2.emit("finish")) : nt(e2, t2)), r2;
  }
  function at(e2) {
    var t2 = this;
    this.next = null, this.entry = null, this.finish = function(r2) {
      var n2 = t2.entry;
      for (t2.entry = null; n2; ) {
        var i2 = n2.callback;
        e2.pendingcb--, i2(r2), n2 = n2.next;
      }
      e2.corkedRequestsFree ? e2.corkedRequestsFree.next = t2 : e2.corkedRequestsFree = t2;
    };
  }
  je.prototype.read = function(e2) {
    Ue("read", e2), e2 = parseInt(e2, 10);
    var t2 = this._readableState, r2 = e2;
    if (0 !== e2 && (t2.emittedReadable = false), 0 === e2 && t2.needReadable && (t2.length >= t2.highWaterMark || t2.ended))
      return Ue("read: emitReadable", t2.length, t2.ended), 0 === t2.length && t2.ended ? He(this) : Re(this), null;
    if (0 === (e2 = Fe(e2, t2)) && t2.ended)
      return 0 === t2.length && He(this), null;
    var n2, i2 = t2.needReadable;
    return Ue("need readable", i2), (0 === t2.length || t2.length - e2 < t2.highWaterMark) && Ue("length less than watermark", i2 = true), t2.ended || t2.reading ? Ue("reading or ended", i2 = false) : i2 && (Ue("do read"), t2.reading = true, t2.sync = true, 0 === t2.length && (t2.needReadable = true), this._read(t2.highWaterMark), t2.sync = false, t2.reading || (e2 = Fe(r2, t2))), null === (n2 = e2 > 0 ? We(e2, t2) : null) ? (t2.needReadable = true, e2 = 0) : t2.length -= e2, 0 === t2.length && (t2.ended || (t2.needReadable = true), r2 !== e2 && t2.ended && He(this)), null !== n2 && this.emit("data", n2), n2;
  }, je.prototype._read = function(e2) {
    this.emit("error", new Error("not implemented"));
  }, je.prototype.pipe = function(e2, t2) {
    var r2 = this, n2 = this._readableState;
    switch (n2.pipesCount) {
      case 0:
        n2.pipes = e2;
        break;
      case 1:
        n2.pipes = [n2.pipes, e2];
        break;
      default:
        n2.pipes.push(e2);
    }
    n2.pipesCount += 1, Ue("pipe count=%d opts=%j", n2.pipesCount, t2);
    var i2 = !t2 || false !== t2.end ? o2 : l2;
    function a2(e3) {
      Ue("onunpipe"), e3 === r2 && l2();
    }
    function o2() {
      Ue("onend"), e2.end();
    }
    n2.endEmitted ? V(i2) : r2.once("end", i2), e2.on("unpipe", a2);
    var s2 = function(e3) {
      return function() {
        var t3 = e3._readableState;
        Ue("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && e3.listeners("data").length && (t3.flowing = true, _e(e3));
      };
    }(r2);
    e2.on("drain", s2);
    var u2 = false;
    function l2() {
      Ue("cleanup"), e2.removeListener("close", d2), e2.removeListener("finish", p2), e2.removeListener("drain", s2), e2.removeListener("error", h2), e2.removeListener("unpipe", a2), r2.removeListener("end", o2), r2.removeListener("end", l2), r2.removeListener("data", f2), u2 = true, !n2.awaitDrain || e2._writableState && !e2._writableState.needDrain || s2();
    }
    var c2 = false;
    function f2(t3) {
      Ue("ondata"), c2 = false, false !== e2.write(t3) || c2 || ((1 === n2.pipesCount && n2.pipes === e2 || n2.pipesCount > 1 && -1 !== Xe(n2.pipes, e2)) && !u2 && (Ue("false write response, pause", r2._readableState.awaitDrain), r2._readableState.awaitDrain++, c2 = true), r2.pause());
    }
    function h2(t3) {
      var r3;
      Ue("onerror", t3), y2(), e2.removeListener("error", h2), 0 === (r3 = "error", e2.listeners(r3).length) && e2.emit("error", t3);
    }
    function d2() {
      e2.removeListener("finish", p2), y2();
    }
    function p2() {
      Ue("onfinish"), e2.removeListener("close", d2), y2();
    }
    function y2() {
      Ue("unpipe"), r2.unpipe(e2);
    }
    return r2.on("data", f2), function(e3, t3, r3) {
      if ("function" == typeof e3.prependListener)
        return e3.prependListener(t3, r3);
      e3._events && e3._events[t3] ? Array.isArray(e3._events[t3]) ? e3._events[t3].unshift(r3) : e3._events[t3] = [r3, e3._events[t3]] : e3.on(t3, r3);
    }(e2, "error", h2), e2.once("close", d2), e2.once("finish", p2), e2.emit("pipe", r2), n2.flowing || (Ue("pipe resume"), r2.resume()), e2;
  }, je.prototype.unpipe = function(e2) {
    var t2 = this._readableState;
    if (0 === t2.pipesCount)
      return this;
    if (1 === t2.pipesCount)
      return e2 && e2 !== t2.pipes || (e2 || (e2 = t2.pipes), t2.pipes = null, t2.pipesCount = 0, t2.flowing = false, e2 && e2.emit("unpipe", this)), this;
    if (!e2) {
      var r2 = t2.pipes, n2 = t2.pipesCount;
      t2.pipes = null, t2.pipesCount = 0, t2.flowing = false;
      for (var i2 = 0; i2 < n2; i2++)
        r2[i2].emit("unpipe", this);
      return this;
    }
    var a2 = Xe(t2.pipes, e2);
    return -1 === a2 || (t2.pipes.splice(a2, 1), t2.pipesCount -= 1, 1 === t2.pipesCount && (t2.pipes = t2.pipes[0]), e2.emit("unpipe", this)), this;
  }, je.prototype.on = function(e2, t2) {
    var r2 = w.prototype.on.call(this, e2, t2);
    if ("data" === e2)
      false !== this._readableState.flowing && this.resume();
    else if ("readable" === e2) {
      var n2 = this._readableState;
      n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = true, n2.emittedReadable = false, n2.reading ? n2.length && Re(this) : V(Ge, this));
    }
    return r2;
  }, je.prototype.addListener = je.prototype.on, je.prototype.resume = function() {
    var e2 = this._readableState;
    return e2.flowing || (Ue("resume"), e2.flowing = true, function(e3, t2) {
      t2.resumeScheduled || (t2.resumeScheduled = true, V(Ve, e3, t2));
    }(this, e2)), this;
  }, je.prototype.pause = function() {
    return Ue("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (Ue("pause"), this._readableState.flowing = false, this.emit("pause")), this;
  }, je.prototype.wrap = function(e2) {
    var t2 = this._readableState, r2 = false, n2 = this;
    for (var i2 in e2.on("end", function() {
      if (Ue("wrapped end"), t2.decoder && !t2.ended) {
        var e3 = t2.decoder.end();
        e3 && e3.length && n2.push(e3);
      }
      n2.push(null);
    }), e2.on("data", function(i3) {
      (Ue("wrapped data"), t2.decoder && (i3 = t2.decoder.write(i3)), t2.objectMode && null == i3) || (t2.objectMode || i3 && i3.length) && (n2.push(i3) || (r2 = true, e2.pause()));
    }), e2)
      void 0 === this[i2] && "function" == typeof e2[i2] && (this[i2] = function(t3) {
        return function() {
          return e2[t3].apply(e2, arguments);
        };
      }(i2));
    return function(e3, t3) {
      for (var r3 = 0, n3 = e3.length; r3 < n3; r3++)
        t3(e3[r3], r3);
    }(["error", "close", "destroy", "pause", "resume"], function(t3) {
      e2.on(t3, n2.emit.bind(n2, t3));
    }), n2._read = function(t3) {
      Ue("wrapped _read", t3), r2 && (r2 = false, e2.resume());
    }, n2;
  }, je._fromList = We, Qe.WritableState = Je, ne(Qe, w), Je.prototype.getBuffer = function() {
    for (var e2 = this.bufferedRequest, t2 = []; e2; )
      t2.push(e2), e2 = e2.next;
    return t2;
  }, Qe.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  }, Qe.prototype.write = function(e2, t2, r2) {
    var n2 = this._writableState, i2 = false;
    return "function" == typeof t2 && (r2 = t2, t2 = null), b.isBuffer(e2) ? t2 = "buffer" : t2 || (t2 = n2.defaultEncoding), "function" != typeof r2 && (r2 = Ze), n2.ended ? function(e3, t3) {
      var r3 = new Error("write after end");
      e3.emit("error", r3), V(t3, r3);
    }(this, r2) : function(e3, t3, r3, n3) {
      var i3 = true, a2 = false;
      return null === r3 ? a2 = new TypeError("May not write null values to stream") : b.isBuffer(r3) || "string" == typeof r3 || void 0 === r3 || t3.objectMode || (a2 = new TypeError("Invalid non-string/buffer chunk")), a2 && (e3.emit("error", a2), V(n3, a2), i3 = false), i3;
    }(this, n2, e2, r2) && (n2.pendingcb++, i2 = function(e3, t3, r3, n3, i3) {
      r3 = function(e4, t4, r4) {
        e4.objectMode || false === e4.decodeStrings || "string" != typeof t4 || (t4 = b.from(t4, r4));
        return t4;
      }(t3, r3, n3), b.isBuffer(r3) && (n3 = "buffer");
      var a2 = t3.objectMode ? 1 : r3.length;
      t3.length += a2;
      var o2 = t3.length < t3.highWaterMark;
      o2 || (t3.needDrain = true);
      if (t3.writing || t3.corked) {
        var s2 = t3.lastBufferedRequest;
        t3.lastBufferedRequest = new Ke(r3, n3, i3), s2 ? s2.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
      } else
        $e(e3, t3, false, a2, r3, n3, i3);
      return o2;
    }(this, n2, e2, t2, r2)), i2;
  }, Qe.prototype.cork = function() {
    this._writableState.corked++;
  }, Qe.prototype.uncork = function() {
    var e2 = this._writableState;
    e2.corked && (e2.corked--, e2.writing || e2.corked || e2.finished || e2.bufferProcessing || !e2.bufferedRequest || tt(this, e2));
  }, Qe.prototype.setDefaultEncoding = function(e2) {
    if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + e2);
    return this._writableState.defaultEncoding = e2, this;
  }, Qe.prototype._write = function(e2, t2, r2) {
    r2(new Error("not implemented"));
  }, Qe.prototype._writev = null, Qe.prototype.end = function(e2, t2, r2) {
    var n2 = this._writableState;
    "function" == typeof e2 ? (r2 = e2, e2 = null, t2 = null) : "function" == typeof t2 && (r2 = t2, t2 = null), null != e2 && this.write(e2, t2), n2.corked && (n2.corked = 1, this.uncork()), n2.ending || n2.finished || function(e3, t3, r3) {
      t3.ending = true, it(e3, t3), r3 && (t3.finished ? V(r3) : e3.once("finish", r3));
      t3.ended = true, e3.writable = false;
    }(this, n2, r2);
  }, ne(lt, je);
  for (var ot = Object.keys(Qe.prototype), st = 0; st < ot.length; st++) {
    var ut = ot[st];
    lt.prototype[ut] || (lt.prototype[ut] = Qe.prototype[ut]);
  }
  function lt(e2) {
    if (!(this instanceof lt))
      return new lt(e2);
    je.call(this, e2), Qe.call(this, e2), e2 && false === e2.readable && (this.readable = false), e2 && false === e2.writable && (this.writable = false), this.allowHalfOpen = true, e2 && false === e2.allowHalfOpen && (this.allowHalfOpen = false), this.once("end", ct);
  }
  function ct() {
    this.allowHalfOpen || this._writableState.ended || V(ft, this);
  }
  function ft(e2) {
    e2.end();
  }
  function ht(e2) {
    this.afterTransform = function(t2, r2) {
      return function(e3, t3, r3) {
        var n2 = e3._transformState;
        n2.transforming = false;
        var i2 = n2.writecb;
        if (!i2)
          return e3.emit("error", new Error("no writecb in Transform class"));
        n2.writechunk = null, n2.writecb = null, null != r3 && e3.push(r3);
        i2(t3);
        var a2 = e3._readableState;
        a2.reading = false, (a2.needReadable || a2.length < a2.highWaterMark) && e3._read(a2.highWaterMark);
      }(e2, t2, r2);
    }, this.needTransform = false, this.transforming = false, this.writecb = null, this.writechunk = null, this.writeencoding = null;
  }
  function dt(e2) {
    if (!(this instanceof dt))
      return new dt(e2);
    lt.call(this, e2), this._transformState = new ht(this);
    var t2 = this;
    this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.once("prefinish", function() {
      "function" == typeof this._flush ? this._flush(function(e3) {
        pt(t2, e3);
      }) : pt(t2);
    });
  }
  function pt(e2, t2) {
    if (t2)
      return e2.emit("error", t2);
    var r2 = e2._writableState, n2 = e2._transformState;
    if (r2.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (n2.transforming)
      throw new Error("Calling transform done when still transforming");
    return e2.push(null);
  }
  function yt(e2) {
    if (!(this instanceof yt))
      return new yt(e2);
    dt.call(this, e2);
  }
  function gt() {
    w.call(this);
  }
  ne(dt, lt), dt.prototype.push = function(e2, t2) {
    return this._transformState.needTransform = false, lt.prototype.push.call(this, e2, t2);
  }, dt.prototype._transform = function(e2, t2, r2) {
    throw new Error("Not implemented");
  }, dt.prototype._write = function(e2, t2, r2) {
    var n2 = this._transformState;
    if (n2.writecb = r2, n2.writechunk = e2, n2.writeencoding = t2, !n2.transforming) {
      var i2 = this._readableState;
      (n2.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
    }
  }, dt.prototype._read = function(e2) {
    var t2 = this._transformState;
    null !== t2.writechunk && t2.writecb && !t2.transforming ? (t2.transforming = true, this._transform(t2.writechunk, t2.writeencoding, t2.afterTransform)) : t2.needTransform = true;
  }, ne(yt, dt), yt.prototype._transform = function(e2, t2, r2) {
    r2(null, e2);
  }, ne(gt, w), gt.Readable = je, gt.Writable = Qe, gt.Duplex = lt, gt.Transform = dt, gt.PassThrough = yt, gt.Stream = gt, gt.prototype.pipe = function(e2, t2) {
    var r2 = this;
    function n2(t3) {
      e2.writable && false === e2.write(t3) && r2.pause && r2.pause();
    }
    function i2() {
      r2.readable && r2.resume && r2.resume();
    }
    r2.on("data", n2), e2.on("drain", i2), e2._isStdio || t2 && false === t2.end || (r2.on("end", o2), r2.on("close", s2));
    var a2 = false;
    function o2() {
      a2 || (a2 = true, e2.end());
    }
    function s2() {
      a2 || (a2 = true, "function" == typeof e2.destroy && e2.destroy());
    }
    function u2(e3) {
      if (l2(), 0 === w.listenerCount(this, "error"))
        throw e3;
    }
    function l2() {
      r2.removeListener("data", n2), e2.removeListener("drain", i2), r2.removeListener("end", o2), r2.removeListener("close", s2), r2.removeListener("error", u2), e2.removeListener("error", u2), r2.removeListener("end", l2), r2.removeListener("close", l2), e2.removeListener("close", l2);
    }
    return r2.on("error", u2), e2.on("error", u2), r2.on("end", l2), r2.on("close", l2), e2.on("close", l2), e2.emit("pipe", r2), e2;
  };
  var vt, bt = v.Buffer, mt = {};
  for (vt in v)
    v.hasOwnProperty(vt) && "SlowBuffer" !== vt && "Buffer" !== vt && (mt[vt] = v[vt]);
  var wt = mt.Buffer = {};
  for (vt in bt)
    bt.hasOwnProperty(vt) && "allocUnsafe" !== vt && "allocUnsafeSlow" !== vt && (wt[vt] = bt[vt]);
  if (mt.Buffer.prototype = bt.prototype, wt.from && wt.from !== Uint8Array.from || (wt.from = function(e2, t2, r2) {
    if ("number" == typeof e2)
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e2);
    if (e2 && void 0 === e2.length)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
    return bt(e2, t2, r2);
  }), wt.alloc || (wt.alloc = function(e2, t2, r2) {
    if ("number" != typeof e2)
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e2);
    if (e2 < 0 || e2 >= 2 * (1 << 30))
      throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
    var n2 = bt(e2);
    return t2 && 0 !== t2.length ? "string" == typeof r2 ? n2.fill(t2, r2) : n2.fill(t2) : n2.fill(0), n2;
  }), !mt.kStringMaxLength)
    try {
      mt.kStringMaxLength = re.binding("buffer").kStringMaxLength;
    } catch (e2) {
    }
  mt.constants || (mt.constants = { MAX_LENGTH: mt.kMaxLength }, mt.kStringMaxLength && (mt.constants.MAX_STRING_LENGTH = mt.kStringMaxLength));
  var St = mt, xt = At;
  function At(e2, t2) {
    this.encoder = e2, this.addBOM = true;
  }
  At.prototype.write = function(e2) {
    return this.addBOM && (e2 = "\uFEFF" + e2, this.addBOM = false), this.encoder.write(e2);
  }, At.prototype.end = function() {
    return this.encoder.end();
  };
  var kt = Ct;
  function Ct(e2, t2) {
    this.decoder = e2, this.pass = false, this.options = t2 || {};
  }
  Ct.prototype.write = function(e2) {
    var t2 = this.decoder.write(e2);
    return this.pass || !t2 || ("\uFEFF" === t2[0] && (t2 = t2.slice(1), "function" == typeof this.options.stripBOM && this.options.stripBOM()), this.pass = true), t2;
  }, Ct.prototype.end = function() {
    return this.decoder.end();
  };
  var Pt = { PrependBOM: xt, StripBOM: kt }, It = St.Buffer, Ot = { utf8: { type: "_internal", bomAware: true }, cesu8: { type: "_internal", bomAware: true }, unicode11utf8: "utf8", ucs2: { type: "_internal", bomAware: true }, utf16le: "ucs2", binary: { type: "_internal" }, base64: { type: "_internal" }, hex: { type: "_internal" }, _internal: Et };
  function Et(e2, t2) {
    this.enc = e2.encodingName, this.bomAware = e2.bomAware, "base64" === this.enc ? this.encoder = zt : "cesu8" === this.enc && (this.enc = "utf8", this.encoder = Ut, "" !== It.from("eda0bdedb2a9", "hex").toString() && (this.decoder = Dt, this.defaultCharUnicode = t2.defaultCharUnicode));
  }
  Et.prototype.encoder = Lt, Et.prototype.decoder = Tt;
  var Bt = Le.StringDecoder;
  function Tt(e2, t2) {
    Bt.call(this, t2.enc);
  }
  function Lt(e2, t2) {
    this.enc = t2.enc;
  }
  function zt(e2, t2) {
    this.prevStr = "";
  }
  function Ut(e2, t2) {
  }
  function Dt(e2, t2) {
    this.acc = 0, this.contBytes = 0, this.accBytes = 0, this.defaultCharUnicode = t2.defaultCharUnicode;
  }
  Bt.prototype.end || (Bt.prototype.end = function() {
  }), Tt.prototype = Bt.prototype, Lt.prototype.write = function(e2) {
    return It.from(e2, this.enc);
  }, Lt.prototype.end = function() {
  }, zt.prototype.write = function(e2) {
    var t2 = (e2 = this.prevStr + e2).length - e2.length % 4;
    return this.prevStr = e2.slice(t2), e2 = e2.slice(0, t2), It.from(e2, "base64");
  }, zt.prototype.end = function() {
    return It.from(this.prevStr, "base64");
  }, Ut.prototype.write = function(e2) {
    for (var t2 = It.alloc(3 * e2.length), r2 = 0, n2 = 0; n2 < e2.length; n2++) {
      var i2 = e2.charCodeAt(n2);
      i2 < 128 ? t2[r2++] = i2 : i2 < 2048 ? (t2[r2++] = 192 + (i2 >>> 6), t2[r2++] = 128 + (63 & i2)) : (t2[r2++] = 224 + (i2 >>> 12), t2[r2++] = 128 + (i2 >>> 6 & 63), t2[r2++] = 128 + (63 & i2));
    }
    return t2.slice(0, r2);
  }, Ut.prototype.end = function() {
  }, Dt.prototype.write = function(e2) {
    for (var t2 = this.acc, r2 = this.contBytes, n2 = this.accBytes, i2 = "", a2 = 0; a2 < e2.length; a2++) {
      var o2 = e2[a2];
      128 != (192 & o2) ? (r2 > 0 && (i2 += this.defaultCharUnicode, r2 = 0), o2 < 128 ? i2 += String.fromCharCode(o2) : o2 < 224 ? (t2 = 31 & o2, r2 = 1, n2 = 1) : o2 < 240 ? (t2 = 15 & o2, r2 = 2, n2 = 1) : i2 += this.defaultCharUnicode) : r2 > 0 ? (t2 = t2 << 6 | 63 & o2, n2++, 0 === --r2 && (i2 += 2 === n2 && t2 < 128 && t2 > 0 || 3 === n2 && t2 < 2048 ? this.defaultCharUnicode : String.fromCharCode(t2))) : i2 += this.defaultCharUnicode;
    }
    return this.acc = t2, this.contBytes = r2, this.accBytes = n2, i2;
  }, Dt.prototype.end = function() {
    var e2 = 0;
    return this.contBytes > 0 && (e2 += this.defaultCharUnicode), e2;
  };
  var jt = St.Buffer, Mt = Ft;
  function Ft() {
  }
  function Rt() {
  }
  function Nt() {
    this.overflowByte = -1;
  }
  Ft.prototype.encoder = Rt, Ft.prototype.decoder = Nt, Ft.prototype.bomAware = true, Rt.prototype.write = function(e2) {
    for (var t2 = jt.from(e2, "ucs2"), r2 = 0; r2 < t2.length; r2 += 2) {
      var n2 = t2[r2];
      t2[r2] = t2[r2 + 1], t2[r2 + 1] = n2;
    }
    return t2;
  }, Rt.prototype.end = function() {
  }, Nt.prototype.write = function(e2) {
    if (0 == e2.length)
      return "";
    var t2 = jt.alloc(e2.length + 1), r2 = 0, n2 = 0;
    for (-1 !== this.overflowByte && (t2[0] = e2[0], t2[1] = this.overflowByte, r2 = 1, n2 = 2); r2 < e2.length - 1; r2 += 2, n2 += 2)
      t2[n2] = e2[r2 + 1], t2[n2 + 1] = e2[r2];
    return this.overflowByte = r2 == e2.length - 1 ? e2[e2.length - 1] : -1, t2.slice(0, n2).toString("ucs2");
  }, Nt.prototype.end = function() {
  };
  var qt = Gt;
  function Gt(e2, t2) {
    this.iconv = t2;
  }
  function Vt(e2, t2) {
    void 0 === (e2 = e2 || {}).addBOM && (e2.addBOM = true), this.encoder = t2.iconv.getEncoder("utf-16le", e2);
  }
  function _t(e2, t2) {
    this.decoder = null, this.initialBytes = [], this.initialBytesLen = 0, this.options = e2 || {}, this.iconv = t2.iconv;
  }
  function Wt(e2, t2) {
    var r2 = t2 || "utf-16le";
    if (e2.length >= 2)
      if (254 == e2[0] && 255 == e2[1])
        r2 = "utf-16be";
      else if (255 == e2[0] && 254 == e2[1])
        r2 = "utf-16le";
      else {
        for (var n2 = 0, i2 = 0, a2 = Math.min(e2.length - e2.length % 2, 64), o2 = 0; o2 < a2; o2 += 2)
          0 === e2[o2] && 0 !== e2[o2 + 1] && i2++, 0 !== e2[o2] && 0 === e2[o2 + 1] && n2++;
        i2 > n2 ? r2 = "utf-16be" : i2 < n2 && (r2 = "utf-16le");
      }
    return r2;
  }
  Gt.prototype.encoder = Vt, Gt.prototype.decoder = _t, Vt.prototype.write = function(e2) {
    return this.encoder.write(e2);
  }, Vt.prototype.end = function() {
    return this.encoder.end();
  }, _t.prototype.write = function(e2) {
    if (!this.decoder) {
      if (this.initialBytes.push(e2), this.initialBytesLen += e2.length, this.initialBytesLen < 16)
        return "";
      var t2 = Wt(e2 = jt.concat(this.initialBytes), this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(t2, this.options), this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(e2);
  }, _t.prototype.end = function() {
    if (!this.decoder) {
      var e2 = jt.concat(this.initialBytes), t2 = Wt(e2, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(t2, this.options);
      var r2 = this.decoder.write(e2), n2 = this.decoder.end();
      return n2 ? r2 + n2 : r2;
    }
    return this.decoder.end();
  };
  var Ht = { utf16be: Mt, utf16: qt }, Yt = St.Buffer, Xt = Zt;
  function Zt(e2, t2) {
    this.iconv = t2;
  }
  Zt.prototype.encoder = Jt, Zt.prototype.decoder = Qt, Zt.prototype.bomAware = true;
  var Kt = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Jt(e2, t2) {
    this.iconv = t2.iconv;
  }
  function Qt(e2, t2) {
    this.iconv = t2.iconv, this.inBase64 = false, this.base64Accum = "";
  }
  Jt.prototype.write = function(e2) {
    return Yt.from(e2.replace(Kt, function(e3) {
      return "+" + ("+" === e3 ? "" : this.iconv.encode(e3, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }.bind(this)));
  }, Jt.prototype.end = function() {
  };
  for (var $t = /[A-Za-z0-9\/+]/, er = [], tr = 0; tr < 256; tr++)
    er[tr] = $t.test(String.fromCharCode(tr));
  var rr = "+".charCodeAt(0), nr = "-".charCodeAt(0), ir = "&".charCodeAt(0);
  Qt.prototype.write = function(e2) {
    for (var t2 = "", r2 = 0, n2 = this.inBase64, i2 = this.base64Accum, a2 = 0; a2 < e2.length; a2++)
      if (n2) {
        if (!er[e2[a2]]) {
          if (a2 == r2 && e2[a2] == nr)
            t2 += "+";
          else {
            var o2 = i2 + e2.slice(r2, a2).toString();
            t2 += this.iconv.decode(Yt.from(o2, "base64"), "utf16-be");
          }
          e2[a2] != nr && a2--, r2 = a2 + 1, n2 = false, i2 = "";
        }
      } else
        e2[a2] == rr && (t2 += this.iconv.decode(e2.slice(r2, a2), "ascii"), r2 = a2 + 1, n2 = true);
    if (n2) {
      var s2 = (o2 = i2 + e2.slice(r2).toString()).length - o2.length % 8;
      i2 = o2.slice(s2), o2 = o2.slice(0, s2), t2 += this.iconv.decode(Yt.from(o2, "base64"), "utf16-be");
    } else
      t2 += this.iconv.decode(e2.slice(r2), "ascii");
    return this.inBase64 = n2, this.base64Accum = i2, t2;
  }, Qt.prototype.end = function() {
    var e2 = "";
    return this.inBase64 && this.base64Accum.length > 0 && (e2 = this.iconv.decode(Yt.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = false, this.base64Accum = "", e2;
  };
  var ar = or;
  function or(e2, t2) {
    this.iconv = t2;
  }
  function sr(e2, t2) {
    this.iconv = t2.iconv, this.inBase64 = false, this.base64Accum = Yt.alloc(6), this.base64AccumIdx = 0;
  }
  function ur(e2, t2) {
    this.iconv = t2.iconv, this.inBase64 = false, this.base64Accum = "";
  }
  or.prototype.encoder = sr, or.prototype.decoder = ur, or.prototype.bomAware = true, sr.prototype.write = function(e2) {
    for (var t2 = this.inBase64, r2 = this.base64Accum, n2 = this.base64AccumIdx, i2 = Yt.alloc(5 * e2.length + 10), a2 = 0, o2 = 0; o2 < e2.length; o2++) {
      var s2 = e2.charCodeAt(o2);
      32 <= s2 && s2 <= 126 ? (t2 && (n2 > 0 && (a2 += i2.write(r2.slice(0, n2).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), a2), n2 = 0), i2[a2++] = nr, t2 = false), t2 || (i2[a2++] = s2, s2 === ir && (i2[a2++] = nr))) : (t2 || (i2[a2++] = ir, t2 = true), t2 && (r2[n2++] = s2 >> 8, r2[n2++] = 255 & s2, n2 == r2.length && (a2 += i2.write(r2.toString("base64").replace(/\//g, ","), a2), n2 = 0)));
    }
    return this.inBase64 = t2, this.base64AccumIdx = n2, i2.slice(0, a2);
  }, sr.prototype.end = function() {
    var e2 = Yt.alloc(10), t2 = 0;
    return this.inBase64 && (this.base64AccumIdx > 0 && (t2 += e2.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), t2), this.base64AccumIdx = 0), e2[t2++] = nr, this.inBase64 = false), e2.slice(0, t2);
  };
  var lr = er.slice();
  lr[",".charCodeAt(0)] = true, ur.prototype.write = function(e2) {
    for (var t2 = "", r2 = 0, n2 = this.inBase64, i2 = this.base64Accum, a2 = 0; a2 < e2.length; a2++)
      if (n2) {
        if (!lr[e2[a2]]) {
          if (a2 == r2 && e2[a2] == nr)
            t2 += "&";
          else {
            var o2 = i2 + e2.slice(r2, a2).toString().replace(/,/g, "/");
            t2 += this.iconv.decode(Yt.from(o2, "base64"), "utf16-be");
          }
          e2[a2] != nr && a2--, r2 = a2 + 1, n2 = false, i2 = "";
        }
      } else
        e2[a2] == ir && (t2 += this.iconv.decode(e2.slice(r2, a2), "ascii"), r2 = a2 + 1, n2 = true);
    if (n2) {
      var s2 = (o2 = i2 + e2.slice(r2).toString().replace(/,/g, "/")).length - o2.length % 8;
      i2 = o2.slice(s2), o2 = o2.slice(0, s2), t2 += this.iconv.decode(Yt.from(o2, "base64"), "utf16-be");
    } else
      t2 += this.iconv.decode(e2.slice(r2), "ascii");
    return this.inBase64 = n2, this.base64Accum = i2, t2;
  }, ur.prototype.end = function() {
    var e2 = "";
    return this.inBase64 && this.base64Accum.length > 0 && (e2 = this.iconv.decode(Yt.from(this.base64Accum, "base64"), "utf16-be")), this.inBase64 = false, this.base64Accum = "", e2;
  };
  var cr = { utf7: Xt, unicode11utf7: "utf7", utf7imap: ar }, fr = St.Buffer, hr = dr;
  function dr(e2, t2) {
    if (!e2)
      throw new Error("SBCS codec is called without the data.");
    if (!e2.chars || 128 !== e2.chars.length && 256 !== e2.chars.length)
      throw new Error("Encoding '" + e2.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (128 === e2.chars.length) {
      for (var r2 = "", n2 = 0; n2 < 128; n2++)
        r2 += String.fromCharCode(n2);
      e2.chars = r2 + e2.chars;
    }
    this.decodeBuf = fr.from(e2.chars, "ucs2");
    var i2 = fr.alloc(65536, t2.defaultCharSingleByte.charCodeAt(0));
    for (n2 = 0; n2 < e2.chars.length; n2++)
      i2[e2.chars.charCodeAt(n2)] = n2;
    this.encodeBuf = i2;
  }
  function pr(e2, t2) {
    this.encodeBuf = t2.encodeBuf;
  }
  function yr(e2, t2) {
    this.decodeBuf = t2.decodeBuf;
  }
  dr.prototype.encoder = pr, dr.prototype.decoder = yr, pr.prototype.write = function(e2) {
    for (var t2 = fr.alloc(e2.length), r2 = 0; r2 < e2.length; r2++)
      t2[r2] = this.encodeBuf[e2.charCodeAt(r2)];
    return t2;
  }, pr.prototype.end = function() {
  }, yr.prototype.write = function(e2) {
    for (var t2 = this.decodeBuf, r2 = fr.alloc(2 * e2.length), n2 = 0, i2 = 0, a2 = 0; a2 < e2.length; a2++)
      n2 = 2 * e2[a2], r2[i2 = 2 * a2] = t2[n2], r2[i2 + 1] = t2[n2 + 1];
    return r2.toString("ucs2");
  }, yr.prototype.end = function() {
  };
  for (var gr = { _sbcs: hr }, vr = { 10029: "maccenteuro", maccenteuro: { type: "_sbcs", chars: "" }, 808: "cp808", ibm808: "cp808", cp808: { type: "_sbcs", chars: "" }, mik: { type: "_sbcs", chars: "" }, ascii8bit: "ascii", usascii: "ascii", ansix34: "ascii", ansix341968: "ascii", ansix341986: "ascii", csascii: "ascii", cp367: "ascii", ibm367: "ascii", isoir6: "ascii", iso646us: "ascii", iso646irv: "ascii", us: "ascii", latin1: "iso88591", latin2: "iso88592", latin3: "iso88593", latin4: "iso88594", latin5: "iso88599", latin6: "iso885910", latin7: "iso885913", latin8: "iso885914", latin9: "iso885915", latin10: "iso885916", csisolatin1: "iso88591", csisolatin2: "iso88592", csisolatin3: "iso88593", csisolatin4: "iso88594", csisolatincyrillic: "iso88595", csisolatinarabic: "iso88596", csisolatingreek: "iso88597", csisolatinhebrew: "iso88598", csisolatin5: "iso88599", csisolatin6: "iso885910", l1: "iso88591", l2: "iso88592", l3: "iso88593", l4: "iso88594", l5: "iso88599", l6: "iso885910", l7: "iso885913", l8: "iso885914", l9: "iso885915", l10: "iso885916", isoir14: "iso646jp", isoir57: "iso646cn", isoir100: "iso88591", isoir101: "iso88592", isoir109: "iso88593", isoir110: "iso88594", isoir144: "iso88595", isoir127: "iso88596", isoir126: "iso88597", isoir138: "iso88598", isoir148: "iso88599", isoir157: "iso885910", isoir166: "tis620", isoir179: "iso885913", isoir199: "iso885914", isoir203: "iso885915", isoir226: "iso885916", cp819: "iso88591", ibm819: "iso88591", cyrillic: "iso88595", arabic: "iso88596", arabic8: "iso88596", ecma114: "iso88596", asmo708: "iso88596", greek: "iso88597", greek8: "iso88597", ecma118: "iso88597", elot928: "iso88597", hebrew: "iso88598", hebrew8: "iso88598", turkish: "iso88599", turkish8: "iso88599", thai: "iso885911", thai8: "iso885911", celtic: "iso885914", celtic8: "iso885914", isoceltic: "iso885914", tis6200: "tis620", tis62025291: "tis620", tis62025330: "tis620", 1e4: "macroman", 10006: "macgreek", 10007: "maccyrillic", 10079: "maciceland", 10081: "macturkish", cspc8codepage437: "cp437", cspc775baltic: "cp775", cspc850multilingual: "cp850", cspcp852: "cp852", cspc862latinhebrew: "cp862", cpgr: "cp869", msee: "cp1250", mscyrl: "cp1251", msansi: "cp1252", msgreek: "cp1253", msturk: "cp1254", mshebr: "cp1255", msarab: "cp1256", winbaltrim: "cp1257", cp20866: "koi8r", 20866: "koi8r", ibm878: "koi8r", cskoi8r: "koi8r", cp21866: "koi8u", 21866: "koi8u", ibm1168: "koi8u", strk10482002: "rk1048", tcvn5712: "tcvn", tcvn57121: "tcvn", gb198880: "iso646cn", cn: "iso646cn", csiso14jisc6220ro: "iso646jp", jisc62201969ro: "iso646jp", jp: "iso646jp", cshproman8: "hproman8", r8: "hproman8", roman8: "hproman8", xroman8: "hproman8", ibm1051: "hproman8", mac: "macintosh", csmacintosh: "macintosh" }, br = { 437: "cp437", 737: "cp737", 775: "cp775", 850: "cp850", 852: "cp852", 855: "cp855", 856: "cp856", 857: "cp857", 858: "cp858", 860: "cp860", 861: "cp861", 862: "cp862", 863: "cp863", 864: "cp864", 865: "cp865", 866: "cp866", 869: "cp869", 874: "windows874", 922: "cp922", 1046: "cp1046", 1124: "cp1124", 1125: "cp1125", 1129: "cp1129", 1133: "cp1133", 1161: "cp1161", 1162: "cp1162", 1163: "cp1163", 1250: "windows1250", 1251: "windows1251", 1252: "windows1252", 1253: "windows1253", 1254: "windows1254", 1255: "windows1255", 1256: "windows1256", 1257: "windows1257", 1258: "windows1258", 28591: "iso88591", 28592: "iso88592", 28593: "iso88593", 28594: "iso88594", 28595: "iso88595", 28596: "iso88596", 28597: "iso88597", 28598: "iso88598", 28599: "iso88599", 28600: "iso885910", 28601: "iso885911", 28603: "iso885913", 28604: "iso885914", 28605: "iso885915", 28606: "iso885916", windows874: { type: "_sbcs", chars: "" }, win874: "windows874", cp874: "windows874", windows1250: { type: "_sbcs", chars: "" }, win1250: "windows1250", cp1250: "windows1250", windows1251: { type: "_sbcs", chars: "" }, win1251: "windows1251", cp1251: "windows1251", windows1252: { type: "_sbcs", chars: "" }, win1252: "windows1252", cp1252: "windows1252", windows1253: { type: "_sbcs", chars: "" }, win1253: "windows1253", cp1253: "windows1253", windows1254: { type: "_sbcs", chars: "" }, win1254: "windows1254", cp1254: "windows1254", windows1255: { type: "_sbcs", chars: "" }, win1255: "windows1255", cp1255: "windows1255", windows1256: { type: "_sbcs", chars: "" }, win1256: "windows1256", cp1256: "windows1256", windows1257: { type: "_sbcs", chars: "" }, win1257: "windows1257", cp1257: "windows1257", windows1258: { type: "_sbcs", chars: "" }, win1258: "windows1258", cp1258: "windows1258", iso88591: { type: "_sbcs", chars: "" }, cp28591: "iso88591", iso88592: { type: "_sbcs", chars: "" }, cp28592: "iso88592", iso88593: { type: "_sbcs", chars: "" }, cp28593: "iso88593", iso88594: { type: "_sbcs", chars: "" }, cp28594: "iso88594", iso88595: { type: "_sbcs", chars: "" }, cp28595: "iso88595", iso88596: { type: "_sbcs", chars: "" }, cp28596: "iso88596", iso88597: { type: "_sbcs", chars: "" }, cp28597: "iso88597", iso88598: { type: "_sbcs", chars: "" }, cp28598: "iso88598", iso88599: { type: "_sbcs", chars: "" }, cp28599: "iso88599", iso885910: { type: "_sbcs", chars: "" }, cp28600: "iso885910", iso885911: { type: "_sbcs", chars: "" }, cp28601: "iso885911", iso885913: { type: "_sbcs", chars: "" }, cp28603: "iso885913", iso885914: { type: "_sbcs", chars: "" }, cp28604: "iso885914", iso885915: { type: "_sbcs", chars: "" }, cp28605: "iso885915", iso885916: { type: "_sbcs", chars: "" }, cp28606: "iso885916", cp437: { type: "_sbcs", chars: "" }, ibm437: "cp437", csibm437: "cp437", cp737: { type: "_sbcs", chars: "" }, ibm737: "cp737", csibm737: "cp737", cp775: { type: "_sbcs", chars: "" }, ibm775: "cp775", csibm775: "cp775", cp850: { type: "_sbcs", chars: "" }, ibm850: "cp850", csibm850: "cp850", cp852: { type: "_sbcs", chars: "" }, ibm852: "cp852", csibm852: "cp852", cp855: { type: "_sbcs", chars: "" }, ibm855: "cp855", csibm855: "cp855", cp856: { type: "_sbcs", chars: "" }, ibm856: "cp856", csibm856: "cp856", cp857: { type: "_sbcs", chars: "" }, ibm857: "cp857", csibm857: "cp857", cp858: { type: "_sbcs", chars: "" }, ibm858: "cp858", csibm858: "cp858", cp860: { type: "_sbcs", chars: "" }, ibm860: "cp860", csibm860: "cp860", cp861: { type: "_sbcs", chars: "" }, ibm861: "cp861", csibm861: "cp861", cp862: { type: "_sbcs", chars: "" }, ibm862: "cp862", csibm862: "cp862", cp863: { type: "_sbcs", chars: "" }, ibm863: "cp863", csibm863: "cp863", cp864: { type: "_sbcs", chars: "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~" }, ibm864: "cp864", csibm864: "cp864", cp865: { type: "_sbcs", chars: "" }, ibm865: "cp865", csibm865: "cp865", cp866: { type: "_sbcs", chars: "" }, ibm866: "cp866", csibm866: "cp866", cp869: { type: "_sbcs", chars: "" }, ibm869: "cp869", csibm869: "cp869", cp922: { type: "_sbcs", chars: "" }, ibm922: "cp922", csibm922: "cp922", cp1046: { type: "_sbcs", chars: "" }, ibm1046: "cp1046", csibm1046: "cp1046", cp1124: { type: "_sbcs", chars: "" }, ibm1124: "cp1124", csibm1124: "cp1124", cp1125: { type: "_sbcs", chars: "" }, ibm1125: "cp1125", csibm1125: "cp1125", cp1129: { type: "_sbcs", chars: "" }, ibm1129: "cp1129", csibm1129: "cp1129", cp1133: { type: "_sbcs", chars: "" }, ibm1133: "cp1133", csibm1133: "cp1133", cp1161: { type: "_sbcs", chars: "" }, ibm1161: "cp1161", csibm1161: "cp1161", cp1162: { type: "_sbcs", chars: "" }, ibm1162: "cp1162", csibm1162: "cp1162", cp1163: { type: "_sbcs", chars: "" }, ibm1163: "cp1163", csibm1163: "cp1163", maccroatian: { type: "_sbcs", chars: "" }, maccyrillic: { type: "_sbcs", chars: "" }, macgreek: { type: "_sbcs", chars: "" }, maciceland: { type: "_sbcs", chars: "" }, macroman: { type: "_sbcs", chars: "" }, macromania: { type: "_sbcs", chars: "" }, macthai: { type: "_sbcs", chars: "\uFEFF" }, macturkish: { type: "_sbcs", chars: "" }, macukraine: { type: "_sbcs", chars: "" }, koi8r: { type: "_sbcs", chars: "" }, koi8u: { type: "_sbcs", chars: "" }, koi8ru: { type: "_sbcs", chars: "" }, koi8t: { type: "_sbcs", chars: "" }, armscii8: { type: "_sbcs", chars: ")(.,-" }, rk1048: { type: "_sbcs", chars: "" }, tcvn: { type: "_sbcs", chars: "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~" }, georgianacademy: { type: "_sbcs", chars: "" }, georgianps: { type: "_sbcs", chars: "" }, pt154: { type: "_sbcs", chars: "" }, viscii: { type: "_sbcs", chars: "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~" }, iso646cn: { type: "_sbcs", chars: "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}" }, iso646jp: { type: "_sbcs", chars: "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}" }, hproman8: { type: "_sbcs", chars: "" }, macintosh: { type: "_sbcs", chars: "" }, ascii: { type: "_sbcs", chars: "" }, tis620: { type: "_sbcs", chars: "" } }, mr = St.Buffer, wr = Ar, Sr = new Array(256), xr = 0; xr < 256; xr++)
    Sr[xr] = -1;
  function Ar(e2, t2) {
    if (this.encodingName = e2.encodingName, !e2)
      throw new Error("DBCS codec is called without the data.");
    if (!e2.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var r2 = e2.table();
    this.decodeTables = [], this.decodeTables[0] = Sr.slice(0), this.decodeTableSeq = [];
    for (var n2 = 0; n2 < r2.length; n2++)
      this._addDecodeChunk(r2[n2]);
    this.defaultCharUnicode = t2.defaultCharUnicode, this.encodeTable = [], this.encodeTableSeq = [];
    var i2 = {};
    if (e2.encodeSkipVals)
      for (n2 = 0; n2 < e2.encodeSkipVals.length; n2++) {
        var a2 = e2.encodeSkipVals[n2];
        if ("number" == typeof a2)
          i2[a2] = true;
        else
          for (var o2 = a2.from; o2 <= a2.to; o2++)
            i2[o2] = true;
      }
    if (this._fillEncodeTable(0, 0, i2), e2.encodeAdd)
      for (var s2 in e2.encodeAdd)
        Object.prototype.hasOwnProperty.call(e2.encodeAdd, s2) && this._setEncodeChar(s2.charCodeAt(0), e2.encodeAdd[s2]);
    if (this.defCharSB = this.encodeTable[0][t2.defaultCharSingleByte.charCodeAt(0)], -1 === this.defCharSB && (this.defCharSB = this.encodeTable[0]["?"]), -1 === this.defCharSB && (this.defCharSB = "?".charCodeAt(0)), "function" == typeof e2.gb18030) {
      this.gb18030 = e2.gb18030();
      var u2 = this.decodeTables.length, l2 = this.decodeTables[u2] = Sr.slice(0), c2 = this.decodeTables.length, f2 = this.decodeTables[c2] = Sr.slice(0);
      for (n2 = 129; n2 <= 254; n2++) {
        var h2 = -1e3 - this.decodeTables[0][n2], d2 = this.decodeTables[h2];
        for (o2 = 48; o2 <= 57; o2++)
          d2[o2] = -1e3 - u2;
      }
      for (n2 = 129; n2 <= 254; n2++)
        l2[n2] = -1e3 - c2;
      for (n2 = 48; n2 <= 57; n2++)
        f2[n2] = -2;
    }
  }
  function kr(e2, t2) {
    this.leadSurrogate = -1, this.seqObj = void 0, this.encodeTable = t2.encodeTable, this.encodeTableSeq = t2.encodeTableSeq, this.defaultCharSingleByte = t2.defCharSB, this.gb18030 = t2.gb18030;
  }
  function Cr(e2, t2) {
    this.nodeIdx = 0, this.prevBuf = mr.alloc(0), this.decodeTables = t2.decodeTables, this.decodeTableSeq = t2.decodeTableSeq, this.defaultCharUnicode = t2.defaultCharUnicode, this.gb18030 = t2.gb18030;
  }
  function Pr(e2, t2) {
    if (e2[0] > t2)
      return -1;
    for (var r2 = 0, n2 = e2.length; r2 < n2 - 1; ) {
      var i2 = r2 + Math.floor((n2 - r2 + 1) / 2);
      e2[i2] <= t2 ? r2 = i2 : n2 = i2;
    }
    return r2;
  }
  Ar.prototype.encoder = kr, Ar.prototype.decoder = Cr, Ar.prototype._getDecodeTrieNode = function(e2) {
    for (var t2 = []; e2 > 0; e2 >>= 8)
      t2.push(255 & e2);
    0 == t2.length && t2.push(0);
    for (var r2 = this.decodeTables[0], n2 = t2.length - 1; n2 > 0; n2--) {
      var i2 = r2[t2[n2]];
      if (-1 == i2)
        r2[t2[n2]] = -1e3 - this.decodeTables.length, this.decodeTables.push(r2 = Sr.slice(0));
      else {
        if (!(i2 <= -1e3))
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + e2.toString(16));
        r2 = this.decodeTables[-1e3 - i2];
      }
    }
    return r2;
  }, Ar.prototype._addDecodeChunk = function(e2) {
    var t2 = parseInt(e2[0], 16), r2 = this._getDecodeTrieNode(t2);
    t2 &= 255;
    for (var n2 = 1; n2 < e2.length; n2++) {
      var i2 = e2[n2];
      if ("string" == typeof i2)
        for (var a2 = 0; a2 < i2.length; ) {
          var o2 = i2.charCodeAt(a2++);
          if (55296 <= o2 && o2 < 56320) {
            var s2 = i2.charCodeAt(a2++);
            if (!(56320 <= s2 && s2 < 57344))
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + e2[0]);
            r2[t2++] = 65536 + 1024 * (o2 - 55296) + (s2 - 56320);
          } else if (4080 < o2 && o2 <= 4095) {
            for (var u2 = 4095 - o2 + 2, l2 = [], c2 = 0; c2 < u2; c2++)
              l2.push(i2.charCodeAt(a2++));
            r2[t2++] = -10 - this.decodeTableSeq.length, this.decodeTableSeq.push(l2);
          } else
            r2[t2++] = o2;
        }
      else {
        if ("number" != typeof i2)
          throw new Error("Incorrect type '" + typeof i2 + "' given in " + this.encodingName + " at chunk " + e2[0]);
        var f2 = r2[t2 - 1] + 1;
        for (a2 = 0; a2 < i2; a2++)
          r2[t2++] = f2++;
      }
    }
    if (t2 > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + e2[0] + ": too long" + t2);
  }, Ar.prototype._getEncodeBucket = function(e2) {
    var t2 = e2 >> 8;
    return void 0 === this.encodeTable[t2] && (this.encodeTable[t2] = Sr.slice(0)), this.encodeTable[t2];
  }, Ar.prototype._setEncodeChar = function(e2, t2) {
    var r2 = this._getEncodeBucket(e2), n2 = 255 & e2;
    r2[n2] <= -10 ? this.encodeTableSeq[-10 - r2[n2]][-1] = t2 : -1 == r2[n2] && (r2[n2] = t2);
  }, Ar.prototype._setEncodeSequence = function(e2, t2) {
    var r2, n2 = e2[0], i2 = this._getEncodeBucket(n2), a2 = 255 & n2;
    i2[a2] <= -10 ? r2 = this.encodeTableSeq[-10 - i2[a2]] : (r2 = {}, -1 !== i2[a2] && (r2[-1] = i2[a2]), i2[a2] = -10 - this.encodeTableSeq.length, this.encodeTableSeq.push(r2));
    for (var o2 = 1; o2 < e2.length - 1; o2++) {
      var s2 = r2[n2];
      "object" == typeof s2 ? r2 = s2 : (r2 = r2[n2] = {}, void 0 !== s2 && (r2[-1] = s2));
    }
    r2[n2 = e2[e2.length - 1]] = t2;
  }, Ar.prototype._fillEncodeTable = function(e2, t2, r2) {
    for (var n2 = this.decodeTables[e2], i2 = 0; i2 < 256; i2++) {
      var a2 = n2[i2], o2 = t2 + i2;
      r2[o2] || (a2 >= 0 ? this._setEncodeChar(a2, o2) : a2 <= -1e3 ? this._fillEncodeTable(-1e3 - a2, o2 << 8, r2) : a2 <= -10 && this._setEncodeSequence(this.decodeTableSeq[-10 - a2], o2));
    }
  }, kr.prototype.write = function(e2) {
    for (var t2 = mr.alloc(e2.length * (this.gb18030 ? 4 : 3)), r2 = this.leadSurrogate, n2 = this.seqObj, i2 = -1, a2 = 0, o2 = 0; ; ) {
      if (-1 === i2) {
        if (a2 == e2.length)
          break;
        var s2 = e2.charCodeAt(a2++);
      } else {
        s2 = i2;
        i2 = -1;
      }
      if (55296 <= s2 && s2 < 57344)
        if (s2 < 56320) {
          if (-1 === r2) {
            r2 = s2;
            continue;
          }
          r2 = s2, s2 = -1;
        } else
          -1 !== r2 ? (s2 = 65536 + 1024 * (r2 - 55296) + (s2 - 56320), r2 = -1) : s2 = -1;
      else
        -1 !== r2 && (i2 = s2, s2 = -1, r2 = -1);
      var u2 = -1;
      if (void 0 !== n2 && -1 != s2) {
        var l2 = n2[s2];
        if ("object" == typeof l2) {
          n2 = l2;
          continue;
        }
        "number" == typeof l2 ? u2 = l2 : null == l2 && void 0 !== (l2 = n2[-1]) && (u2 = l2, i2 = s2), n2 = void 0;
      } else if (s2 >= 0) {
        var c2 = this.encodeTable[s2 >> 8];
        if (void 0 !== c2 && (u2 = c2[255 & s2]), u2 <= -10) {
          n2 = this.encodeTableSeq[-10 - u2];
          continue;
        }
        if (-1 == u2 && this.gb18030) {
          var f2 = Pr(this.gb18030.uChars, s2);
          if (-1 != f2) {
            u2 = this.gb18030.gbChars[f2] + (s2 - this.gb18030.uChars[f2]);
            t2[o2++] = 129 + Math.floor(u2 / 12600), u2 %= 12600, t2[o2++] = 48 + Math.floor(u2 / 1260), u2 %= 1260, t2[o2++] = 129 + Math.floor(u2 / 10), u2 %= 10, t2[o2++] = 48 + u2;
            continue;
          }
        }
      }
      -1 === u2 && (u2 = this.defaultCharSingleByte), u2 < 256 ? t2[o2++] = u2 : u2 < 65536 ? (t2[o2++] = u2 >> 8, t2[o2++] = 255 & u2) : (t2[o2++] = u2 >> 16, t2[o2++] = u2 >> 8 & 255, t2[o2++] = 255 & u2);
    }
    return this.seqObj = n2, this.leadSurrogate = r2, t2.slice(0, o2);
  }, kr.prototype.end = function() {
    if (-1 !== this.leadSurrogate || void 0 !== this.seqObj) {
      var e2 = mr.alloc(10), t2 = 0;
      if (this.seqObj) {
        var r2 = this.seqObj[-1];
        void 0 !== r2 && (r2 < 256 ? e2[t2++] = r2 : (e2[t2++] = r2 >> 8, e2[t2++] = 255 & r2)), this.seqObj = void 0;
      }
      return -1 !== this.leadSurrogate && (e2[t2++] = this.defaultCharSingleByte, this.leadSurrogate = -1), e2.slice(0, t2);
    }
  }, kr.prototype.findIdx = Pr, Cr.prototype.write = function(e2) {
    var t2 = mr.alloc(2 * e2.length), r2 = this.nodeIdx, n2 = this.prevBuf, i2 = this.prevBuf.length, a2 = -this.prevBuf.length;
    i2 > 0 && (n2 = mr.concat([n2, e2.slice(0, 10)]));
    for (var o2 = 0, s2 = 0; o2 < e2.length; o2++) {
      var u2, l2 = o2 >= 0 ? e2[o2] : n2[o2 + i2];
      if ((u2 = this.decodeTables[r2][l2]) >= 0)
        ;
      else if (-1 === u2)
        o2 = a2, u2 = this.defaultCharUnicode.charCodeAt(0);
      else if (-2 === u2) {
        var c2 = a2 >= 0 ? e2.slice(a2, o2 + 1) : n2.slice(a2 + i2, o2 + 1 + i2), f2 = 12600 * (c2[0] - 129) + 1260 * (c2[1] - 48) + 10 * (c2[2] - 129) + (c2[3] - 48), h2 = Pr(this.gb18030.gbChars, f2);
        u2 = this.gb18030.uChars[h2] + f2 - this.gb18030.gbChars[h2];
      } else {
        if (u2 <= -1e3) {
          r2 = -1e3 - u2;
          continue;
        }
        if (!(u2 <= -10))
          throw new Error("iconv-lite internal error: invalid decoding table value " + u2 + " at " + r2 + "/" + l2);
        for (var d2 = this.decodeTableSeq[-10 - u2], p2 = 0; p2 < d2.length - 1; p2++)
          u2 = d2[p2], t2[s2++] = 255 & u2, t2[s2++] = u2 >> 8;
        u2 = d2[d2.length - 1];
      }
      if (u2 > 65535) {
        u2 -= 65536;
        var y2 = 55296 + Math.floor(u2 / 1024);
        t2[s2++] = 255 & y2, t2[s2++] = y2 >> 8, u2 = 56320 + u2 % 1024;
      }
      t2[s2++] = 255 & u2, t2[s2++] = u2 >> 8, r2 = 0, a2 = o2 + 1;
    }
    return this.nodeIdx = r2, this.prevBuf = a2 >= 0 ? e2.slice(a2) : n2.slice(a2 + i2), t2.slice(0, s2).toString("ucs2");
  }, Cr.prototype.end = function() {
    for (var e2 = ""; this.prevBuf.length > 0; ) {
      e2 += this.defaultCharUnicode;
      var t2 = this.prevBuf.slice(1);
      this.prevBuf = mr.alloc(0), this.nodeIdx = 0, t2.length > 0 && (e2 += this.write(t2));
    }
    return this.nodeIdx = 0, e2;
  };
  var Ir = { _dbcs: wr }, Or = Object.freeze({ __proto__: null, default: [["0", "\0", 128], ["a1", "", 62], ["8140", "", 9, ""], ["8180", ""], ["81b8", ""], ["81c8", ""], ["81da", ""], ["81f0", ""], ["81fc", ""], ["824f", "", 9], ["8260", "", 25], ["8281", "", 25], ["829f", "", 82], ["8340", "", 62], ["8380", "", 22], ["839f", "", 16, "", 6], ["83bf", "", 16, "", 6], ["8440", "", 5, "", 25], ["8470", "", 5, "", 7], ["8480", "", 17], ["849f", ""], ["8740", "", 19, "", 9], ["875f", ""], ["877e", ""], ["8780", "", 4, ""], ["889f", ""], ["8940", ""], ["8980", ""], ["8a40", ""], ["8a80", ""], ["8b40", ""], ["8b80", ""], ["8c40", ""], ["8c80", ""], ["8d40", ""], ["8d80", ""], ["8e40", ""], ["8e80", ""], ["8f40", ""], ["8f80", ""], ["9040", ""], ["9080", ""], ["9140", ""], ["9180", ""], ["9240", ""], ["9280", ""], ["9340", ""], ["9380", ""], ["9440", ""], ["9480", ""], ["9540", ""], ["9580", ""], ["9640", ""], ["9680", ""], ["9740", ""], ["9780", ""], ["9840", ""], ["989f", ""], ["9940", ""], ["9980", ""], ["9a40", ""], ["9a80", ""], ["9b40", ""], ["9b80", ""], ["9c40", ""], ["9c80", ""], ["9d40", ""], ["9d80", ""], ["9e40", ""], ["9e80", ""], ["9f40", ""], ["9f80", ""], ["e040", ""], ["e080", ""], ["e140", ""], ["e180", ""], ["e240", ""], ["e280", ""], ["e340", ""], ["e380", ""], ["e440", ""], ["e480", ""], ["e540", ""], ["e580", ""], ["e640", ""], ["e680", ""], ["e740", ""], ["e780", ""], ["e840", ""], ["e880", ""], ["e940", ""], ["e980", ""], ["ea40", ""], ["ea80", ""], ["ed40", ""], ["ed80", ""], ["ee40", ""], ["ee80", ""], ["eeef", "", 9, ""], ["f040", "", 62], ["f080", "", 124], ["f140", "", 62], ["f180", "", 124], ["f240", "", 62], ["f280", "", 124], ["f340", "", 62], ["f380", "", 124], ["f440", "", 62], ["f480", "", 124], ["f540", "", 62], ["f580", "", 124], ["f640", "", 62], ["f680", "", 124], ["f740", "", 62], ["f780", "", 124], ["f840", "", 62], ["f880", "", 124], ["f940", ""], ["fa40", "", 9, "", 9, ""], ["fa80", ""], ["fb40", ""], ["fb80", ""], ["fc40", ""]] }), Er = Object.freeze({ __proto__: null, default: [["0", "\0", 127], ["8ea1", "", 62], ["a1a1", "", 9, ""], ["a2a1", ""], ["a2ba", ""], ["a2ca", ""], ["a2dc", ""], ["a2f2", ""], ["a2fe", ""], ["a3b0", "", 9], ["a3c1", "", 25], ["a3e1", "", 25], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a8a1", ""], ["ada1", "", 19, "", 9], ["adc0", ""], ["addf", "", 4, ""], ["b0a1", ""], ["b1a1", ""], ["b2a1", ""], ["b3a1", ""], ["b4a1", ""], ["b5a1", ""], ["b6a1", ""], ["b7a1", ""], ["b8a1", ""], ["b9a1", ""], ["baa1", ""], ["bba1", ""], ["bca1", ""], ["bda1", ""], ["bea1", ""], ["bfa1", ""], ["c0a1", ""], ["c1a1", ""], ["c2a1", ""], ["c3a1", ""], ["c4a1", ""], ["c5a1", ""], ["c6a1", ""], ["c7a1", ""], ["c8a1", ""], ["c9a1", ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", ""], ["d2a1", ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fcf1", "", 9, ""], ["8fa2af", ""], ["8fa2c2", ""], ["8fa2eb", ""], ["8fa6e1", ""], ["8fa6e7", ""], ["8fa6e9", ""], ["8fa6ec", ""], ["8fa6f1", ""], ["8fa7c2", "", 10, ""], ["8fa7f2", "", 10, ""], ["8fa9a1", ""], ["8fa9a4", ""], ["8fa9a6", ""], ["8fa9a8", ""], ["8fa9ab", ""], ["8fa9af", ""], ["8fa9c1", ""], ["8faaa1", ""], ["8faaba", ""], ["8faba1", ""], ["8fabbd", ""], ["8fabc5", ""], ["8fb0a1", ""], ["8fb1a1", ""], ["8fb2a1", "", 4, ""], ["8fb3a1", ""], ["8fb4a1", ""], ["8fb5a1", ""], ["8fb6a1", "", 5, "", 4, ""], ["8fb7a1", "", 4, ""], ["8fb8a1", ""], ["8fb9a1", ""], ["8fbaa1", "", 4, ""], ["8fbba1", ""], ["8fbca1", "", 4, ""], ["8fbda1", "", 4, ""], ["8fbea1", "", 4, ""], ["8fbfa1", ""], ["8fc0a1", ""], ["8fc1a1", ""], ["8fc2a1", ""], ["8fc3a1", "", 4, ""], ["8fc4a1", ""], ["8fc5a1", ""], ["8fc6a1", ""], ["8fc7a1", ""], ["8fc8a1", ""], ["8fc9a1", "", 4, "", 4, ""], ["8fcaa1", ""], ["8fcba1", ""], ["8fcca1", "", 9, ""], ["8fcda1", "", 5, ""], ["8fcea1", "", 6, ""], ["8fcfa1", ""], ["8fd0a1", ""], ["8fd1a1", ""], ["8fd2a1", "", 5], ["8fd3a1", ""], ["8fd4a1", "", 4, ""], ["8fd5a1", ""], ["8fd6a1", ""], ["8fd7a1", ""], ["8fd8a1", ""], ["8fd9a1", "", 4, "", 6, ""], ["8fdaa1", "", 4, ""], ["8fdba1", "", 6, ""], ["8fdca1", "", 4, ""], ["8fdda1", "", 4, ""], ["8fdea1", "", 4, ""], ["8fdfa1", ""], ["8fe0a1", ""], ["8fe1a1", "", 4, ""], ["8fe2a1", ""], ["8fe3a1", "", 5, "", 4, ""], ["8fe4a1", "", 4, ""], ["8fe5a1", "", 4, ""], ["8fe6a1", ""], ["8fe7a1", ""], ["8fe8a1", "", 4, ""], ["8fe9a1", "", 4], ["8feaa1", "", 4, ""], ["8feba1", "", 4, ""], ["8feca1", ""], ["8feda1", "", 4, "", 4, ""]] }), Br = Object.freeze({ __proto__: null, default: [["0", "\0", 127, ""], ["8140", "", 5, "", 9, "", 6, ""], ["8180", "", 6, "", 4, "", 4, "", 5, ""], ["8240", "", 4, "", 8, "", 4, "", 11], ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""], ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""], ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5], ["8440", "", 5, "", 5, ""], ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""], ["8540", "", 9, ""], ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""], ["8640", "", 4, "", 5, "", 4, "", 5, ""], ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""], ["8740", "", 7, "", 11, "", 4, "", 4], ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6], ["8840", "", 9, "", 4, "", 4, ""], ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7], ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""], ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""], ["8a40", "", 4, "", 12, ""], ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5], ["8b40", "", 8, "", 17, "", 6, "", 13, ""], ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6], ["8c40", "", 7, ""], ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4], ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4], ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""], ["8e40", "", 21, "", 12, "", 6, "", 12, ""], ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6], ["8f40", "", 5, "", 11, "", 8, ""], ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""], ["9040", "", 4, "", 4, "", 6, ""], ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6], ["9140", "", 6, "", 6, "", 18, "", 4, ""], ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""], ["9240", "", 6, "", 5, ""], ["9280", "", 5, "", 7, "", 6, ""], ["9340", "", 6, "", 4, "", 4, "", 5, ""], ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""], ["9440", "", 24, "", 7, "", 7, "", 4, "", 8], ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""], ["9540", "", 4, "", 4, "", 6, ""], ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""], ["9640", "", 5, "", 4, ""], ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5], ["9740", "", 7, "", 8, "", 7, "", 9, ""], ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""], ["9840", "", 4, "", 5, "", 9, ""], ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""], ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5], ["9980", "", 114, "", 6], ["9a40", "", 11, "", 7, "", 13, ""], ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""], ["9b40", "", 4, ""], ["9b80", "", 5, "", 4, "", 4, "", 5, ""], ["9c40", "", 7, ""], ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5], ["9d40", "", 7, "", 4, "", 9, "", 6, ""], ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""], ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6], ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""], ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""], ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4], ["a040", "", 9, "", 5, "", 9, "", 11, "", 19], ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""], ["a1a1", "", 7, ""], ["a2a1", "", 9], ["a2b1", "", 19, "", 19, "", 9], ["a2e5", "", 9], ["a2f1", "", 11], ["a3a1", "", 88, ""], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a6e0", ""], ["a6ee", ""], ["a6f4", ""], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a840", "", 35, "", 6], ["a880", "", 7, ""], ["a8a1", ""], ["a8bd", ""], ["a8c0", ""], ["a8c5", "", 36], ["a940", "", 8, ""], ["a959", ""], ["a95c", ""], ["a960", "", 9, "", 8], ["a980", "", 4, ""], ["a996", ""], ["a9a4", "", 75], ["aa40", "", 5, "", 5, "", 8], ["aa80", "", 7, "", 10, ""], ["ab40", "", 11, "", 4, "", 5, "", 4], ["ab80", "", 6, "", 4], ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11], ["ac80", "", 6, "", 12, "", 4, ""], ["ad40", "", 10, "", 7, "", 15, "", 12], ["ad80", "", 9, "", 8, "", 6, ""], ["ae40", "", 6, "", 7, "", 4, ""], ["ae80", "", 7, "", 6, "", 4, ""], ["af40", "", 4, ""], ["af80", ""], ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""], ["b080", "", 7, "", 8, "", 9, ""], ["b140", "", 4, "", 7, "", 10, ""], ["b180", "", 4, "", 7, "", 7, ""], ["b240", "", 11, "", 5, "", 11, "", 4], ["b280", "", 12, "", 8, "", 4, ""], ["b340", "", 5, ""], ["b380", "", 11, "", 7, "", 6, ""], ["b440", "", 7, "", 9], ["b480", "", 4, "", 5, "", 6, ""], ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""], ["b580", "", 6, "", 4, ""], ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""], ["b680", "", 6, "", 4, ""], ["b740", "", 14, "", 5, "", 9, "", 4, "", 16], ["b780", "", 6, ""], ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""], ["b880", "", 4, ""], ["b940", "", 5, "", 10, "", 6, ""], ["b980", "", 7, ""], ["ba40", "", 4, "", 4, "", 7, "", 5, ""], ["ba80", "", 4, "", 5, "", 12, "", 5, ""], ["bb40", "", 9, "", 36, "", 5, "", 9], ["bb80", "", 6, "", 4, ""], ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5], ["bc80", "", 14, "", 6, ""], ["bd40", "", 54, "", 7], ["bd80", "", 32, ""], ["be40", "", 12, "", 6, "", 42], ["be80", "", 32, ""], ["bf40", "", 62], ["bf80", "", 4, "", 4, "", 21, ""], ["c040", "", 35, "", 23, ""], ["c080", "", 6, "", 9, ""], ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""], ["c180", "", 4, "", 4, "", 5, ""], ["c240", "", 6, "", 5, ""], ["c280", "", 13, "", 5, "", 11, ""], ["c340", "", 5, "", 4, "", 6, ""], ["c380", "", 12, "", 4, ""], ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""], ["c480", "", 7, "", 5, "", 6, ""], ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""], ["c580", "", 7, "", 7, ""], ["c640", ""], ["c680", "", 4, "", 9, ""], ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""], ["c780", ""], ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""], ["c880", "", 6, "", 4, "", 4, ""], ["c940", "", 4, "", 7, "", 12, ""], ["c980", "", 4, "", 4, "", 10, ""], ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10], ["ca80", "", 4, "", 8, ""], ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""], ["cb80", "", 5, "", 6, "", 14, ""], ["cc40", "", 4, "", 10, "", 15, "", 13, ""], ["cc80", "", 11, "", 4, "", 7, ""], ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""], ["cd80", ""], ["ce40", "", 6, "", 5, "", 7, ""], ["ce80", "", 4, "", 6, "", 4, ""], ["cf40", "", 4, "", 4, "", 6, "", 9], ["cf80", "", 5, "", 7, "", 4, ""], ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""], ["d080", "", 4, "", 4, "", 5, ""], ["d140", "", 4, "", 4, "", 6, "", 5], ["d180", "", 4, "", 4, "", 4, ""], ["d240", "", 8, "", 24, "", 5, "", 19, ""], ["d280", "", 26, ""], ["d340", "", 30, "", 6], ["d380", "", 4, "", 5, "", 21, ""], ["d440", "", 31, "", 8, "", 21], ["d480", "", 25, "", 6, ""], ["d540", "", 7, "", 7, "", 46], ["d580", "", 32, ""], ["d640", "", 34, "", 27], ["d680", "", 30, ""], ["d740", "", 31, "", 4, "", 25], ["d780", "", 24, ""], ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""], ["d880", "", 6, "", 20, ""], ["d940", "", 62], ["d980", "", 32, ""], ["da40", "", 14, "", 8, "", 4, "", 9, ""], ["da80", "", 12, ""], ["db40", "", 6, "", 7, "", 4, ""], ["db80", "", 4, "", 5, "", 11, ""], ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7], ["dc80", "", 10, "", 21, ""], ["dd40", "", 62], ["dd80", "", 32, ""], ["de40", "", 32, ""], ["de80", "", 4, ""], ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""], ["df80", "", 4, ""], ["e040", "", 19, ""], ["e080", "", 10, "", 6, "", 8, ""], ["e140", "", 4, "", 6, "", 5, "", 5, ""], ["e180", "", 10, "", 9, "", 8, ""], ["e240", "", 62], ["e280", "", 32, "", 5, ""], ["e340", "", 45, "", 16], ["e380", "", 7, "", 24, ""], ["e440", "", 5, "", 24, "", 31], ["e480", "", 32, ""], ["e540", "", 51, "", 10], ["e580", "", 31, ""], ["e640", "", 34, "", 27], ["e680", "", 29, ""], ["e740", "", 7, "", 54], ["e780", "", 32, "", 6, "", 4, ""], ["e840", "", 14, "", 43, ""], ["e880", "", 20, ""], ["e940", "", 7, "", 42], ["e980", "", 32, ""], ["ea40", "", 27, "", 6, ""], ["ea80", "", 4, "", 12, ""], ["eb40", "", 9, "", 7, "", 9, "", 6, ""], ["eb80", "", 4, ""], ["ec40", "", 8, "", 4, "", 18, "", 7], ["ec80", "", 4, "", 7, "", 4, "", 4, ""], ["ed40", "", 6, "", 46], ["ed80", "", 4, "", 23, ""], ["ee40", "", 62], ["ee80", "", 32, "", 4, "", 6, ""], ["ef40", "", 5, "", 37, "", 4], ["ef80", "", 30, "", 4, "", 8, ""], ["f040", "", 4, "", 28, "", 26], ["f080", "", 9, "", 12, "", 4, "", 6, ""], ["f140", "", 10, "", 47], ["f180", "", 32, ""], ["f240", "", 62], ["f280", "", 32, ""], ["f340", "", 17, "", 6, "", 4, ""], ["f380", "", 8, "", 6, ""], ["f440", "", 5, "", 10, "", 10, "", 7, "", 5], ["f480", "", 32, ""], ["f540", "", 62], ["f580", "", 32, ""], ["f640", "", 62], ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""], ["f740", "", 62], ["f780", "", 4, "", 4, ""], ["f840", "", 62], ["f880", "", 32], ["f940", "", 62], ["f980", "", 32], ["fa40", "", 62], ["fa80", "", 32], ["fb40", "", 27, "", 9, ""], ["fb80", "", 5, "", 8, "", 5, ""], ["fc40", "", 8, "", 4, "", 8, "", 6], ["fc80", "", 4, "", 5, "", 8, ""], ["fd40", "", 4, "", 4, "", 10, "", 38], ["fd80", "", 5, "", 11, "", 4, ""], ["fe40", ""]] }), Tr = Object.freeze({ __proto__: null, default: [["a140", "", 62], ["a180", "", 32], ["a240", "", 62], ["a280", "", 32], ["a2ab", "", 5], ["a2e3", ""], ["a2ef", ""], ["a2fd", ""], ["a340", "", 62], ["a380", "", 31, ""], ["a440", "", 62], ["a480", "", 32], ["a4f4", "", 10], ["a540", "", 62], ["a580", "", 32], ["a5f7", "", 7], ["a640", "", 62], ["a680", "", 32], ["a6b9", "", 7], ["a6d9", "", 6], ["a6ec", ""], ["a6f3", ""], ["a6f6", "", 8], ["a740", "", 62], ["a780", "", 32], ["a7c2", "", 14], ["a7f2", "", 12], ["a896", "", 10], ["a8bc", ""], ["a8bf", ""], ["a8c1", ""], ["a8ea", "", 20], ["a958", ""], ["a95b", ""], ["a95d", ""], ["a989", "", 11], ["a997", "", 12], ["a9f0", "", 14], ["aaa1", "", 93], ["aba1", "", 93], ["aca1", "", 93], ["ada1", "", 93], ["aea1", "", 93], ["afa1", "", 93], ["d7fa", "", 4], ["f8a1", "", 93], ["f9a1", "", 93], ["faa1", "", 93], ["fba1", "", 93], ["fca1", "", 93], ["fda1", "", 93], ["fe50", ""], ["fe80", "", 6, "", 93]] }), Lr = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], zr = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3], Ur = { uChars: Lr, gbChars: zr }, Dr = Object.freeze({ __proto__: null, uChars: Lr, gbChars: zr, default: Ur }), jr = Object.freeze({ __proto__: null, default: [["0", "\0", 127], ["8141", "", 4, "", 6, ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", "", 5, "", 4, ""], ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f5a1", ""], ["f6a1", ""], ["f7a1", ""], ["f8a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fda1", ""]] }), Mr = Object.freeze({ __proto__: null, default: [["0", "\0", 127], ["a140", ""], ["a1a1", "", 4, ""], ["a240", "", 7, ""], ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21], ["a340", "", 16, "", 6, "", 16, "", 6, "", 10], ["a3a1", "", 25, ""], ["a3e1", ""], ["a440", ""], ["a4a1", ""], ["a540", ""], ["a5a1", ""], ["a640", ""], ["a6a1", ""], ["a740", ""], ["a7a1", ""], ["a840", ""], ["a8a1", ""], ["a940", ""], ["a9a1", ""], ["aa40", ""], ["aaa1", ""], ["ab40", ""], ["aba1", ""], ["ac40", ""], ["aca1", ""], ["ad40", ""], ["ada1", ""], ["ae40", ""], ["aea1", ""], ["af40", ""], ["afa1", ""], ["b040", ""], ["b0a1", ""], ["b140", ""], ["b1a1", ""], ["b240", ""], ["b2a1", ""], ["b340", ""], ["b3a1", ""], ["b440", ""], ["b4a1", ""], ["b540", ""], ["b5a1", ""], ["b640", ""], ["c640", ""], ["c940", ""], ["c9a1", ""], ["ca40", ""], ["caa1", ""], ["cb40", ""], ["cba1", ""], ["cc40", ""], ["cca1", ""], ["cd40", ""], ["cda1", ""], ["ce40", ""], ["cea1", ""], ["cf40", ""], ["cfa1", ""], ["d040", ""], ["d0a1", ""], ["f9a1", ""]] }), Fr = Object.freeze({ __proto__: null, default: [["8740", ""], ["8767", ""], ["87a1", ""], ["8840", "", 4, ""], ["88a1", ""], ["8940", ""], ["8943", ""], ["8946", ""], ["894c", ""], ["89a1", ""], ["89ab", ""], ["89b0", ""], ["89b5", ""], ["89c1", ""], ["89c5", ""], ["8a40", ""], ["8a43", ""], ["8a64", ""], ["8a76", ""], ["8aa1", ""], ["8aac", ""], ["8ab2", ""], ["8abb", ""], ["8ac9", ""], ["8ace", ""], ["8adf", ""], ["8af6", ""], ["8b40", ""], ["8b55", ""], ["8ba1", ""], ["8bde", ""], ["8c40", ""], ["8ca1", ""], ["8ca7", ""], ["8cc9", ""], ["9d40", ""], ["9da1", ""], ["9e40", ""], ["9ea1", ""], ["9ead", ""], ["9ec5", ""], ["9ef5", ""], ["9f40", ""], ["9f4f", ""], ["9fa1", ""], ["9fae", ""], ["9fb2", ""], ["9fc1", ""], ["9fc9", ""], ["9fdb", ""], ["9fe7", ""], ["9feb", ""], ["9ff0", ""], ["a040", ""], ["a055", ""], ["a058", ""], ["a05b", ""], ["a063", ""], ["a073", ""], ["a0a1", ""], ["a0a6", ""], ["a0ae", ""], ["a0b0", ""], ["a0d4", ""], ["a0e2", ""], ["a3c0", "", 31, ""], ["c6a1", "", 9, "", 9, "", 9, "", 23], ["c740", "", 58, ""], ["c7a1", "", 81, "", 5, "", 4], ["c840", "", 26, "", 25, ""], ["c8a1", ""], ["c8cd", ""], ["c8f5", ""], ["f9fe", ""], ["fa40", ""], ["faa1", ""], ["fb40", ""], ["fba1", ""], ["fc40", ""], ["fca1", ""], ["fd40", ""], ["fda1", ""], ["fe40", ""], ["fea1", ""]] }), Rr = r(Or), Nr = r(Er), qr = r(Br), Gr = r(Tr), Vr = r(Dr), _r = r(jr), Wr = r(Mr), Hr = r(Fr), Yr = { shiftjis: { type: "_dbcs", table: function() {
    return Rr;
  }, encodeAdd: { "": 92, "": 126 }, encodeSkipVals: [{ from: 60736, to: 63808 }] }, csshiftjis: "shiftjis", mskanji: "shiftjis", sjis: "shiftjis", windows31j: "shiftjis", ms31j: "shiftjis", xsjis: "shiftjis", windows932: "shiftjis", ms932: "shiftjis", 932: "shiftjis", cp932: "shiftjis", eucjp: { type: "_dbcs", table: function() {
    return Nr;
  }, encodeAdd: { "": 92, "": 126 } }, gb2312: "cp936", gb231280: "cp936", gb23121980: "cp936", csgb2312: "cp936", csiso58gb231280: "cp936", euccn: "cp936", windows936: "cp936", ms936: "cp936", 936: "cp936", cp936: { type: "_dbcs", table: function() {
    return qr;
  } }, gbk: { type: "_dbcs", table: function() {
    return qr.concat(Gr);
  } }, xgbk: "gbk", isoir58: "gbk", gb18030: { type: "_dbcs", table: function() {
    return qr.concat(Gr);
  }, gb18030: function() {
    return Vr;
  }, encodeSkipVals: [128], encodeAdd: { "": 41699 } }, chinese: "gb18030", windows949: "cp949", ms949: "cp949", 949: "cp949", cp949: { type: "_dbcs", table: function() {
    return _r;
  } }, cseuckr: "cp949", csksc56011987: "cp949", euckr: "cp949", isoir149: "cp949", korean: "cp949", ksc56011987: "cp949", ksc56011989: "cp949", ksc5601: "cp949", windows950: "cp950", ms950: "cp950", 950: "cp950", cp950: { type: "_dbcs", table: function() {
    return Wr;
  } }, big5: "big5hkscs", big5hkscs: { type: "_dbcs", table: function() {
    return Wr.concat(Hr);
  }, encodeSkipVals: [41676] }, cnbig5: "big5hkscs", csbig5: "big5hkscs", xxbig5: "big5hkscs" }, Xr = t(function(e2, t2) {
    for (var r2 = [Ot, Ht, cr, gr, vr, br, Ir, Yr], n2 = 0; n2 < r2.length; n2++) {
      e2 = r2[n2];
      for (var i2 in e2)
        Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
    }
  }), Zr = v.Buffer, Kr = gt.Transform;
  function Jr(e2, t2) {
    this.conv = e2, (t2 = t2 || {}).decodeStrings = false, Kr.call(this, t2);
  }
  function Qr(e2, t2) {
    this.conv = e2, (t2 = t2 || {}).encoding = this.encoding = "utf8", Kr.call(this, t2);
  }
  Jr.prototype = Object.create(Kr.prototype, { constructor: { value: Jr } }), Jr.prototype._transform = function(e2, t2, r2) {
    if ("string" != typeof e2)
      return r2(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var n2 = this.conv.write(e2);
      n2 && n2.length && this.push(n2), r2();
    } catch (e3) {
      r2(e3);
    }
  }, Jr.prototype._flush = function(e2) {
    try {
      var t2 = this.conv.end();
      t2 && t2.length && this.push(t2), e2();
    } catch (t3) {
      e2(t3);
    }
  }, Jr.prototype.collect = function(e2) {
    var t2 = [];
    return this.on("error", e2), this.on("data", function(e3) {
      t2.push(e3);
    }), this.on("end", function() {
      e2(null, Zr.concat(t2));
    }), this;
  }, Qr.prototype = Object.create(Kr.prototype, { constructor: { value: Qr } }), Qr.prototype._transform = function(e2, t2, r2) {
    if (!Zr.isBuffer(e2))
      return r2(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var n2 = this.conv.write(e2);
      n2 && n2.length && this.push(n2, this.encoding), r2();
    } catch (e3) {
      r2(e3);
    }
  }, Qr.prototype._flush = function(e2) {
    try {
      var t2 = this.conv.end();
      t2 && t2.length && this.push(t2, this.encoding), e2();
    } catch (t3) {
      e2(t3);
    }
  }, Qr.prototype.collect = function(e2) {
    var t2 = "";
    return this.on("error", e2), this.on("data", function(e3) {
      t2 += e3;
    }), this.on("end", function() {
      e2(null, t2);
    }), this;
  };
  var $r = v.Buffer, en = t(function(e2) {
    var t2 = St.Buffer, r2 = e2.exports;
    r2.encodings = null, r2.defaultCharUnicode = "", r2.defaultCharSingleByte = "?", r2.encode = function(e3, n3, i3) {
      e3 = "" + (e3 || "");
      var a2 = r2.getEncoder(n3, i3), o2 = a2.write(e3), s2 = a2.end();
      return s2 && s2.length > 0 ? t2.concat([o2, s2]) : o2;
    }, r2.decode = function(e3, n3, i3) {
      "string" == typeof e3 && (r2.skipDecodeWarning || (console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding"), r2.skipDecodeWarning = true), e3 = t2.from("" + (e3 || ""), "binary"));
      var a2 = r2.getDecoder(n3, i3), o2 = a2.write(e3), s2 = a2.end();
      return s2 ? o2 + s2 : o2;
    }, r2.encodingExists = function(e3) {
      try {
        return r2.getCodec(e3), true;
      } catch (e4) {
        return false;
      }
    }, r2.toEncoding = r2.encode, r2.fromEncoding = r2.decode, r2._codecDataCache = {}, r2.getCodec = function(e3) {
      r2.encodings || (r2.encodings = Xr);
      for (var t3 = r2._canonicalizeEncoding(e3), n3 = {}; ; ) {
        var i3 = r2._codecDataCache[t3];
        if (i3)
          return i3;
        var a2 = r2.encodings[t3];
        switch (typeof a2) {
          case "string":
            t3 = a2;
            break;
          case "object":
            for (var o2 in a2)
              n3[o2] = a2[o2];
            n3.encodingName || (n3.encodingName = t3), t3 = a2.type;
            break;
          case "function":
            return n3.encodingName || (n3.encodingName = t3), i3 = new a2(n3, r2), r2._codecDataCache[n3.encodingName] = i3, i3;
          default:
            throw new Error("Encoding not recognized: '" + e3 + "' (searched as: '" + t3 + "')");
        }
      }
    }, r2._canonicalizeEncoding = function(e3) {
      return ("" + e3).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    }, r2.getEncoder = function(e3, t3) {
      var n3 = r2.getCodec(e3), i3 = new n3.encoder(t3, n3);
      return n3.bomAware && t3 && t3.addBOM && (i3 = new Pt.PrependBOM(i3, t3)), i3;
    }, r2.getDecoder = function(e3, t3) {
      var n3 = r2.getCodec(e3), i3 = new n3.decoder(t3, n3);
      return !n3.bomAware || t3 && false === t3.stripBOM || (i3 = new Pt.StripBOM(i3, t3)), i3;
    };
    var n2 = void 0 !== re && re.versions && re.versions.node;
    if (n2) {
      var i2 = n2.split(".").map(Number);
      (i2[0] > 0 || i2[1] >= 10) && function(e3) {
        e3.encodeStream = function(t3, r3) {
          return new Jr(e3.getEncoder(t3, r3), r3);
        }, e3.decodeStream = function(t3, r3) {
          return new Qr(e3.getDecoder(t3, r3), r3);
        }, e3.supportsStreams = true, e3.IconvLiteEncoderStream = Jr, e3.IconvLiteDecoderStream = Qr, e3._collect = Qr.prototype.collect;
      }(r2), function(e3) {
        var t3 = void 0;
        e3.supportsNodeEncodingsExtension = !($r.from || new $r(0) instanceof Uint8Array), e3.extendNodeEncodings = function() {
          if (!t3) {
            if (t3 = {}, !e3.supportsNodeEncodingsExtension)
              return console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node"), void console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            var r3 = { hex: true, utf8: true, "utf-8": true, ascii: true, binary: true, base64: true, ucs2: true, "ucs-2": true, utf16le: true, "utf-16le": true };
            $r.isNativeEncoding = function(e4) {
              return e4 && r3[e4.toLowerCase()];
            };
            var n3 = v.SlowBuffer;
            if (t3.SlowBufferToString = n3.prototype.toString, n3.prototype.toString = function(r4, n4, i4) {
              return r4 = String(r4 || "utf8").toLowerCase(), $r.isNativeEncoding(r4) ? t3.SlowBufferToString.call(this, r4, n4, i4) : (void 0 === n4 && (n4 = 0), void 0 === i4 && (i4 = this.length), e3.decode(this.slice(n4, i4), r4));
            }, t3.SlowBufferWrite = n3.prototype.write, n3.prototype.write = function(r4, n4, i4, a2) {
              if (isFinite(n4))
                isFinite(i4) || (a2 = i4, i4 = void 0);
              else {
                var o2 = a2;
                a2 = n4, n4 = i4, i4 = o2;
              }
              n4 = +n4 || 0;
              var s2 = this.length - n4;
              if (i4 ? (i4 = +i4) > s2 && (i4 = s2) : i4 = s2, a2 = String(a2 || "utf8").toLowerCase(), $r.isNativeEncoding(a2))
                return t3.SlowBufferWrite.call(this, r4, n4, i4, a2);
              if (r4.length > 0 && (i4 < 0 || n4 < 0))
                throw new RangeError("attempt to write beyond buffer bounds");
              var u2 = e3.encode(r4, a2);
              return u2.length < i4 && (i4 = u2.length), u2.copy(this, n4, 0, i4), i4;
            }, t3.BufferIsEncoding = $r.isEncoding, $r.isEncoding = function(t4) {
              return $r.isNativeEncoding(t4) || e3.encodingExists(t4);
            }, t3.BufferByteLength = $r.byteLength, $r.byteLength = n3.byteLength = function(r4, n4) {
              return n4 = String(n4 || "utf8").toLowerCase(), $r.isNativeEncoding(n4) ? t3.BufferByteLength.call(this, r4, n4) : e3.encode(r4, n4).length;
            }, t3.BufferToString = $r.prototype.toString, $r.prototype.toString = function(r4, n4, i4) {
              return r4 = String(r4 || "utf8").toLowerCase(), $r.isNativeEncoding(r4) ? t3.BufferToString.call(this, r4, n4, i4) : (void 0 === n4 && (n4 = 0), void 0 === i4 && (i4 = this.length), e3.decode(this.slice(n4, i4), r4));
            }, t3.BufferWrite = $r.prototype.write, $r.prototype.write = function(r4, n4, i4, a2) {
              var o2 = n4, s2 = i4, u2 = a2;
              if (isFinite(n4))
                isFinite(i4) || (a2 = i4, i4 = void 0);
              else {
                var l2 = a2;
                a2 = n4, n4 = i4, i4 = l2;
              }
              if (a2 = String(a2 || "utf8").toLowerCase(), $r.isNativeEncoding(a2))
                return t3.BufferWrite.call(this, r4, o2, s2, u2);
              n4 = +n4 || 0;
              var c2 = this.length - n4;
              if (i4 ? (i4 = +i4) > c2 && (i4 = c2) : i4 = c2, r4.length > 0 && (i4 < 0 || n4 < 0))
                throw new RangeError("attempt to write beyond buffer bounds");
              var f2 = e3.encode(r4, a2);
              return f2.length < i4 && (i4 = f2.length), f2.copy(this, n4, 0, i4), i4;
            }, e3.supportsStreams) {
              var i3 = gt.Readable;
              t3.ReadableSetEncoding = i3.prototype.setEncoding, i3.prototype.setEncoding = function(t4, r4) {
                this._readableState.decoder = e3.getDecoder(t4, r4), this._readableState.encoding = t4;
              }, i3.prototype.collect = e3._collect;
            }
          }
        }, e3.undoExtendNodeEncodings = function() {
          if (e3.supportsNodeEncodingsExtension) {
            if (!t3)
              throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
            delete $r.isNativeEncoding;
            var r3 = v.SlowBuffer;
            if (r3.prototype.toString = t3.SlowBufferToString, r3.prototype.write = t3.SlowBufferWrite, $r.isEncoding = t3.BufferIsEncoding, $r.byteLength = t3.BufferByteLength, $r.prototype.toString = t3.BufferToString, $r.prototype.write = t3.BufferWrite, e3.supportsStreams) {
              var n3 = gt.Readable;
              n3.prototype.setEncoding = t3.ReadableSetEncoding, delete n3.prototype.collect;
            }
            t3 = void 0;
          }
        };
      }(r2);
    }
  }), tn = t(function(t2) {
    (function() {
      var e2, r2;
      try {
        r2 = en;
      } catch (e3) {
      }
      e2 = function() {
        var e3;
        function t3(e4) {
          this.buffer = e4, this.pos = 0, this.length = this.buffer.length;
        }
        for (e3 in t3.TYPES = { UInt8: 1, UInt16: 2, UInt24: 3, UInt32: 4, Int8: 1, Int16: 2, Int24: 3, Int32: 4, Float: 4, Double: 8 }, b.prototype)
          "read" === e3.slice(0, 4) && function(e4) {
            var r3;
            r3 = t3.TYPES[e4.replace(/read|[BL]E/g, "")], t3.prototype[e4] = function() {
              var t4;
              return t4 = this.buffer[e4](this.pos), this.pos += r3, t4;
            };
          }(e3);
        return t3.prototype.readString = function(e4, t4) {
          var n2, i2, a2, o2, s2;
          switch (null == t4 && (t4 = "ascii"), t4) {
            case "utf16le":
            case "ucs2":
            case "utf8":
            case "ascii":
              return this.buffer.toString(t4, this.pos, this.pos += e4);
            case "utf16be":
              for (a2 = o2 = 0, s2 = (n2 = new b(this.readBuffer(e4))).length - 1; o2 < s2; a2 = o2 += 2)
                i2 = n2[a2], n2[a2] = n2[a2 + 1], n2[a2 + 1] = i2;
              return n2.toString("utf16le");
            default:
              if (n2 = this.readBuffer(e4), r2)
                try {
                  return r2.decode(n2, t4);
                } catch (e5) {
                }
              return n2;
          }
        }, t3.prototype.readBuffer = function(e4) {
          return this.buffer.slice(this.pos, this.pos += e4);
        }, t3.prototype.readUInt24BE = function() {
          return (this.readUInt16BE() << 8) + this.readUInt8();
        }, t3.prototype.readUInt24LE = function() {
          return this.readUInt16LE() + (this.readUInt8() << 16);
        }, t3.prototype.readInt24BE = function() {
          return (this.readInt16BE() << 8) + this.readUInt8();
        }, t3.prototype.readInt24LE = function() {
          return this.readUInt16LE() + (this.readInt8() << 16);
        }, t3;
      }(), t2.exports = e2;
    }).call(e);
  }), rn = t(function(t2) {
    (function() {
      var e2, r2, n2, i2, a2 = {}.hasOwnProperty;
      i2 = gt, e2 = tn;
      try {
        n2 = en;
      } catch (e3) {
      }
      r2 = function(t3) {
        var r3;
        function i3(e3) {
          null == e3 && (e3 = 65536), i3.__super__.constructor.apply(this, arguments), this.buffer = new b(e3), this.bufferOffset = 0, this.pos = 0;
        }
        for (r3 in function(e3, t4) {
          for (var r4 in t4)
            a2.call(t4, r4) && (e3[r4] = t4[r4]);
          function n3() {
            this.constructor = e3;
          }
          n3.prototype = t4.prototype, e3.prototype = new n3(), e3.__super__ = t4.prototype;
        }(i3, t3), b.prototype)
          "write" === r3.slice(0, 5) && function(t4) {
            var r4;
            r4 = +e2.TYPES[t4.replace(/write|[BL]E/g, "")], i3.prototype[t4] = function(e3) {
              return this.ensure(r4), this.buffer[t4](e3, this.bufferOffset), this.bufferOffset += r4, this.pos += r4;
            };
          }(r3);
        return i3.prototype._read = function() {
        }, i3.prototype.ensure = function(e3) {
          if (this.bufferOffset + e3 > this.buffer.length)
            return this.flush();
        }, i3.prototype.flush = function() {
          if (this.bufferOffset > 0)
            return this.push(new b(this.buffer.slice(0, this.bufferOffset))), this.bufferOffset = 0;
        }, i3.prototype.writeBuffer = function(e3) {
          return this.flush(), this.push(e3), this.pos += e3.length;
        }, i3.prototype.writeString = function(e3, t4) {
          var r4, i4, a3, o2, s2;
          switch (null == t4 && (t4 = "ascii"), t4) {
            case "utf16le":
            case "ucs2":
            case "utf8":
            case "ascii":
              return this.writeBuffer(new b(e3, t4));
            case "utf16be":
              for (a3 = o2 = 0, s2 = (r4 = new b(e3, "utf16le")).length - 1; o2 < s2; a3 = o2 += 2)
                i4 = r4[a3], r4[a3] = r4[a3 + 1], r4[a3 + 1] = i4;
              return this.writeBuffer(r4);
            default:
              if (n2)
                return this.writeBuffer(n2.encode(e3, t4));
              throw new Error("Install iconv-lite to enable additional string encodings.");
          }
        }, i3.prototype.writeUInt24BE = function(e3) {
          return this.ensure(3), this.buffer[this.bufferOffset++] = e3 >>> 16 & 255, this.buffer[this.bufferOffset++] = e3 >>> 8 & 255, this.buffer[this.bufferOffset++] = 255 & e3, this.pos += 3;
        }, i3.prototype.writeUInt24LE = function(e3) {
          return this.ensure(3), this.buffer[this.bufferOffset++] = 255 & e3, this.buffer[this.bufferOffset++] = e3 >>> 8 & 255, this.buffer[this.bufferOffset++] = e3 >>> 16 & 255, this.pos += 3;
        }, i3.prototype.writeInt24BE = function(e3) {
          return e3 >= 0 ? this.writeUInt24BE(e3) : this.writeUInt24BE(e3 + 16777215 + 1);
        }, i3.prototype.writeInt24LE = function(e3) {
          return e3 >= 0 ? this.writeUInt24LE(e3) : this.writeUInt24LE(e3 + 16777215 + 1);
        }, i3.prototype.fill = function(e3, t4) {
          var r4;
          return t4 < this.buffer.length ? (this.ensure(t4), this.buffer.fill(e3, this.bufferOffset, this.bufferOffset + t4), this.bufferOffset += t4, this.pos += t4) : ((r4 = new b(t4)).fill(e3), this.writeBuffer(r4));
        }, i3.prototype.end = function() {
          return this.flush(), this.push(null);
        }, i3;
      }(i2.Readable), t2.exports = r2;
    }).call(e);
  }), nn = t(function(t2, r2) {
    (function() {
      var e2, t3, n2, i2 = {}.hasOwnProperty;
      e2 = tn, n2 = function() {
        function t4(e3, t5) {
          this.type = e3, this.endian = null != t5 ? t5 : "BE", this.fn = this.type, "8" !== this.type[this.type.length - 1] && (this.fn += this.endian);
        }
        return t4.prototype.size = function() {
          return e2.TYPES[this.type];
        }, t4.prototype.decode = function(e3) {
          return e3["read" + this.fn]();
        }, t4.prototype.encode = function(e3, t5) {
          return e3["write" + this.fn](t5);
        }, t4;
      }(), r2.Number = n2, r2.uint8 = new n2("UInt8"), r2.uint16be = r2.uint16 = new n2("UInt16", "BE"), r2.uint16le = new n2("UInt16", "LE"), r2.uint24be = r2.uint24 = new n2("UInt24", "BE"), r2.uint24le = new n2("UInt24", "LE"), r2.uint32be = r2.uint32 = new n2("UInt32", "BE"), r2.uint32le = new n2("UInt32", "LE"), r2.int8 = new n2("Int8"), r2.int16be = r2.int16 = new n2("Int16", "BE"), r2.int16le = new n2("Int16", "LE"), r2.int24be = r2.int24 = new n2("Int24", "BE"), r2.int24le = new n2("Int24", "LE"), r2.int32be = r2.int32 = new n2("Int32", "BE"), r2.int32le = new n2("Int32", "LE"), r2.floatbe = r2.float = new n2("Float", "BE"), r2.floatle = new n2("Float", "LE"), r2.doublebe = r2.double = new n2("Double", "BE"), r2.doublele = new n2("Double", "LE"), t3 = function(e3) {
        function t4(e4, r3, n3) {
          null == n3 && (n3 = e4 >> 1), t4.__super__.constructor.call(this, "Int" + e4, r3), this._point = 1 << n3;
        }
        return function(e4, t5) {
          for (var r3 in t5)
            i2.call(t5, r3) && (e4[r3] = t5[r3]);
          function n3() {
            this.constructor = e4;
          }
          n3.prototype = t5.prototype, e4.prototype = new n3(), e4.__super__ = t5.prototype;
        }(t4, e3), t4.prototype.decode = function(e4) {
          return t4.__super__.decode.call(this, e4) / this._point;
        }, t4.prototype.encode = function(e4, r3) {
          return t4.__super__.encode.call(this, e4, r3 * this._point | 0);
        }, t4;
      }(n2), r2.Fixed = t3, r2.fixed16be = r2.fixed16 = new t3(16, "BE"), r2.fixed16le = new t3(16, "LE"), r2.fixed32be = r2.fixed32 = new t3(32, "BE"), r2.fixed32le = new t3(32, "LE");
    }).call(e);
  }), an = (nn.Number, nn.uint8, nn.uint16be, nn.uint16, nn.uint16le, nn.uint24be, nn.uint24, nn.uint24le, nn.uint32be, nn.uint32, nn.uint32le, nn.int8, nn.int16be, nn.int16, nn.int16le, nn.int24be, nn.int24, nn.int24le, nn.int32be, nn.int32, nn.int32le, nn.floatbe, nn.floatle, nn.doublebe, nn.doublele, nn.Fixed, nn.fixed16be, nn.fixed16, nn.fixed16le, nn.fixed32be, nn.fixed32, nn.fixed32le, t(function(t2, r2) {
    (function() {
      var e2, t3;
      e2 = nn.Number, r2.resolveLength = function(t4, r3, n2) {
        var i2;
        if ("number" == typeof t4 ? i2 = t4 : "function" == typeof t4 ? i2 = t4.call(n2, n2) : n2 && "string" == typeof t4 ? i2 = n2[t4] : r3 && t4 instanceof e2 && (i2 = t4.decode(r3)), isNaN(i2))
          throw new Error("Not a fixed size");
        return i2;
      }, t3 = function(e3) {
        var t4, r3;
        for (t4 in null == e3 && (e3 = {}), this.enumerable = true, this.configurable = true, e3)
          r3 = e3[t4], this[t4] = r3;
      }, r2.PropertyDescriptor = t3;
    }).call(e);
  })), on = an.resolveLength, sn = an.PropertyDescriptor, un = t(function(t2) {
    (function() {
      var e2, r2, n2;
      r2 = nn.Number, n2 = an, e2 = function() {
        function e3(e4, t3, r3) {
          this.type = e4, this.length = t3, this.lengthType = null != r3 ? r3 : "count";
        }
        return e3.prototype.decode = function(e4, t3) {
          var i2, a2, o2, s2, u2, l2;
          if (o2 = e4.pos, s2 = [], i2 = t3, null != this.length && (a2 = n2.resolveLength(this.length, e4, t3)), this.length instanceof r2 && (Object.defineProperties(s2, { parent: { value: t3 }, _startOffset: { value: o2 }, _currentOffset: { value: 0, writable: true }, _length: { value: a2 } }), i2 = s2), null == a2 || "bytes" === this.lengthType)
            for (u2 = null != a2 ? e4.pos + a2 : (null != t3 ? t3._length : void 0) ? t3._startOffset + t3._length : e4.length; e4.pos < u2; )
              s2.push(this.type.decode(e4, i2));
          else
            for (l2 = 0; l2 < a2; l2 += 1)
              s2.push(this.type.decode(e4, i2));
          return s2;
        }, e3.prototype.size = function(e4, t3) {
          var i2, a2, o2, s2;
          if (!e4)
            return this.type.size(null, t3) * n2.resolveLength(this.length, null, t3);
          for (a2 = 0, this.length instanceof r2 && (a2 += this.length.size(), t3 = { parent: t3 }), o2 = 0, s2 = e4.length; o2 < s2; o2++)
            i2 = e4[o2], a2 += this.type.size(i2, t3);
          return a2;
        }, e3.prototype.encode = function(e4, t3, n3) {
          var i2, a2, o2, s2, u2, l2;
          for (i2 = n3, this.length instanceof r2 && ((i2 = { pointers: [], startOffset: e4.pos, parent: n3 }).pointerOffset = e4.pos + this.size(t3, i2), this.length.encode(e4, t3.length)), u2 = 0, l2 = t3.length; u2 < l2; u2++)
            o2 = t3[u2], this.type.encode(e4, o2, i2);
          if (this.length instanceof r2)
            for (a2 = 0; a2 < i2.pointers.length; )
              (s2 = i2.pointers[a2++]).type.encode(e4, s2.val);
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), ln = t(function(t2) {
    (function() {
      var e2, r2, n2, i2, a2, o2, s2 = {}.hasOwnProperty;
      e2 = un, i2 = nn.Number, o2 = an, a2 = Be, n2 = function(e3) {
        function t3() {
          return t3.__super__.constructor.apply(this, arguments);
        }
        return function(e4, t4) {
          for (var r3 in t4)
            s2.call(t4, r3) && (e4[r3] = t4[r3]);
          function n3() {
            this.constructor = e4;
          }
          n3.prototype = t4.prototype, e4.prototype = new n3(), e4.__super__ = t4.prototype;
        }(t3, e3), t3.prototype.decode = function(e4, t4) {
          var n3, a3, s3;
          return a3 = e4.pos, n3 = o2.resolveLength(this.length, e4, t4), this.length instanceof i2 && (t4 = { parent: t4, _startOffset: a3, _currentOffset: 0, _length: n3 }), s3 = new r2(this.type, n3, e4, t4), e4.pos += n3 * this.type.size(null, t4), s3;
        }, t3.prototype.size = function(e4, n3) {
          return e4 instanceof r2 && (e4 = e4.toArray()), t3.__super__.size.call(this, e4, n3);
        }, t3.prototype.encode = function(e4, n3, i3) {
          return n3 instanceof r2 && (n3 = n3.toArray()), t3.__super__.encode.call(this, e4, n3, i3);
        }, t3;
      }(e2), r2 = function() {
        function e3(e4, t3, r3, n3) {
          this.type = e4, this.length = t3, this.stream = r3, this.ctx = n3, this.base = this.stream.pos, this.items = [];
        }
        return e3.prototype.get = function(e4) {
          var t3;
          if (!(e4 < 0 || e4 >= this.length))
            return null == this.items[e4] && (t3 = this.stream.pos, this.stream.pos = this.base + this.type.size(null, this.ctx) * e4, this.items[e4] = this.type.decode(this.stream, this.ctx), this.stream.pos = t3), this.items[e4];
        }, e3.prototype.toArray = function() {
          var e4, t3, r3, n3;
          for (n3 = [], e4 = t3 = 0, r3 = this.length; t3 < r3; e4 = t3 += 1)
            n3.push(this.get(e4));
          return n3;
        }, e3.prototype.inspect = function() {
          return a2(this.toArray());
        }, e3;
      }(), t2.exports = n2;
    }).call(e);
  }), cn = t(function(t2) {
    (function() {
      var e2;
      e2 = function() {
        function e3(e4, t3) {
          this.type = e4, this.flags = null != t3 ? t3 : [];
        }
        return e3.prototype.decode = function(e4) {
          var t3, r2, n2, i2, a2, o2, s2;
          for (i2 = this.type.decode(e4), n2 = {}, r2 = a2 = 0, o2 = (s2 = this.flags).length; a2 < o2; r2 = ++a2)
            null != (t3 = s2[r2]) && (n2[t3] = !!(i2 & 1 << r2));
          return n2;
        }, e3.prototype.size = function() {
          return this.type.size();
        }, e3.prototype.encode = function(e4, t3) {
          var r2, n2, i2, a2, o2, s2;
          for (i2 = 0, n2 = a2 = 0, o2 = (s2 = this.flags).length; a2 < o2; n2 = ++a2)
            null != (r2 = s2[n2]) && t3[r2] && (i2 |= 1 << n2);
          return this.type.encode(e4, i2);
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), fn = t(function(t2) {
    (function() {
      var e2;
      e2 = function() {
        function e3(e4) {
          this.type = e4;
        }
        return e3.prototype.decode = function(e4, t3) {
          return !!this.type.decode(e4, t3);
        }, e3.prototype.size = function(e4, t3) {
          return this.type.size(e4, t3);
        }, e3.prototype.encode = function(e4, t3, r2) {
          return this.type.encode(e4, +t3, r2);
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), hn = t(function(t2) {
    (function() {
      var e2, r2, n2;
      n2 = an, r2 = nn.Number, e2 = function() {
        function e3(e4) {
          this.length = e4;
        }
        return e3.prototype.decode = function(e4, t3) {
          var r3;
          return r3 = n2.resolveLength(this.length, e4, t3), e4.readBuffer(r3);
        }, e3.prototype.size = function(e4, t3) {
          return e4 ? e4.length : n2.resolveLength(this.length, null, t3);
        }, e3.prototype.encode = function(e4, t3, n3) {
          return this.length instanceof r2 && this.length.encode(e4, t3.length), e4.writeBuffer(t3);
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), dn = t(function(t2) {
    (function() {
      var e2;
      e2 = function() {
        function e3(e4, t3) {
          this.type = e4, this.options = null != t3 ? t3 : [];
        }
        return e3.prototype.decode = function(e4) {
          var t3;
          return t3 = this.type.decode(e4), this.options[t3] || t3;
        }, e3.prototype.size = function() {
          return this.type.size();
        }, e3.prototype.encode = function(e4, t3) {
          var r2;
          if (-1 === (r2 = this.options.indexOf(t3)))
            throw new Error("Unknown option in enum: " + t3);
          return this.type.encode(e4, r2);
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), pn = t(function(t2) {
    (function() {
      var e2;
      e2 = function() {
        function e3(e4, t3) {
          this.type = e4, this.condition = null == t3 || t3;
        }
        return e3.prototype.decode = function(e4, t3) {
          var r2;
          if ("function" == typeof (r2 = this.condition) && (r2 = r2.call(t3, t3)), r2)
            return this.type.decode(e4, t3);
        }, e3.prototype.size = function(e4, t3) {
          var r2;
          return "function" == typeof (r2 = this.condition) && (r2 = r2.call(t3, t3)), r2 ? this.type.size(e4, t3) : 0;
        }, e3.prototype.encode = function(e4, t3, r2) {
          var n2;
          if ("function" == typeof (n2 = this.condition) && (n2 = n2.call(r2, r2)), n2)
            return this.type.encode(e4, t3, r2);
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), yn = t(function(t2) {
    (function() {
      var e2, r2;
      r2 = an, e2 = function() {
        function e3(e4, t3) {
          this.type = e4, this.count = null != t3 ? t3 : 1;
        }
        return e3.prototype.decode = function(e4, t3) {
          e4.pos += this.size(null, t3);
        }, e3.prototype.size = function(e4, t3) {
          var n2;
          return n2 = r2.resolveLength(this.count, null, t3), this.type.size() * n2;
        }, e3.prototype.encode = function(e4, t3, r3) {
          return e4.fill(0, this.size(t3, r3));
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), gn = t(function(t2) {
    (function() {
      var e2, r2, n2;
      e2 = nn.Number, n2 = an, r2 = function() {
        function t3(e3, t4) {
          this.length = e3, this.encoding = null != t4 ? t4 : "ascii";
        }
        return t3.prototype.decode = function(e3, t4) {
          var r3, i2, a2, o2, s2;
          return a2 = function() {
            if (null != this.length)
              return n2.resolveLength(this.length, e3, t4);
            for (r3 = e3.buffer, a2 = e3.length, o2 = e3.pos; o2 < a2 && 0 !== r3[o2]; )
              ++o2;
            return o2 - e3.pos;
          }.call(this), "function" == typeof (i2 = this.encoding) && (i2 = i2.call(t4, t4) || "ascii"), s2 = e3.readString(a2, i2), null == this.length && e3.pos < e3.length && e3.pos++, s2;
        }, t3.prototype.size = function(t4, r3) {
          var i2, a2;
          return t4 ? ("function" == typeof (i2 = this.encoding) && (i2 = i2.call(null != r3 ? r3.val : void 0, null != r3 ? r3.val : void 0) || "ascii"), "utf16be" === i2 && (i2 = "utf16le"), a2 = b.byteLength(t4, i2), this.length instanceof e2 && (a2 += this.length.size()), null == this.length && a2++, a2) : n2.resolveLength(this.length, null, r3);
        }, t3.prototype.encode = function(t4, r3, n3) {
          var i2;
          if ("function" == typeof (i2 = this.encoding) && (i2 = i2.call(null != n3 ? n3.val : void 0, null != n3 ? n3.val : void 0) || "ascii"), this.length instanceof e2 && this.length.encode(t4, b.byteLength(r3, i2)), t4.writeString(r3, i2), null == this.length)
            return t4.writeUInt8(0);
        }, t3;
      }(), t2.exports = r2;
    }).call(e);
  }), vn = t(function(t2) {
    (function() {
      var e2, r2;
      r2 = an, e2 = function() {
        function e3(e4) {
          this.fields = null != e4 ? e4 : {};
        }
        return e3.prototype.decode = function(e4, t3, r3) {
          var n2, i2;
          return null == r3 && (r3 = 0), n2 = this._setup(e4, t3, r3), this._parseFields(e4, n2, this.fields), null != (i2 = this.process) && i2.call(n2, e4), n2;
        }, e3.prototype._setup = function(e4, t3, r3) {
          var n2;
          return n2 = {}, Object.defineProperties(n2, { parent: { value: t3 }, _startOffset: { value: e4.pos }, _currentOffset: { value: 0, writable: true }, _length: { value: r3 } }), n2;
        }, e3.prototype._parseFields = function(e4, t3, n2) {
          var i2, a2, o2;
          for (i2 in n2)
            void 0 !== (o2 = "function" == typeof (a2 = n2[i2]) ? a2.call(t3, t3) : a2.decode(e4, t3)) && (o2 instanceof r2.PropertyDescriptor ? Object.defineProperty(t3, i2, o2) : t3[i2] = o2), t3._currentOffset = e4.pos - t3._startOffset;
        }, e3.prototype.size = function(e4, t3, r3) {
          var n2, i2, a2, o2, s2;
          for (i2 in null == e4 && (e4 = {}), null == r3 && (r3 = true), n2 = { parent: t3, val: e4, pointerSize: 0 }, a2 = 0, s2 = this.fields)
            null != (o2 = s2[i2]).size && (a2 += o2.size(e4[i2], n2));
          return r3 && (a2 += n2.pointerSize), a2;
        }, e3.prototype.encode = function(e4, t3, r3) {
          var n2, i2, a2, o2, s2, u2, l2;
          for (a2 in null != (u2 = this.preEncode) && u2.call(t3, e4), (n2 = { pointers: [], startOffset: e4.pos, parent: r3, val: t3, pointerSize: 0 }).pointerOffset = e4.pos + this.size(t3, n2, false), l2 = this.fields)
            null != (s2 = l2[a2]).encode && s2.encode(e4, t3[a2], n2);
          for (i2 = 0; i2 < n2.pointers.length; )
            (o2 = n2.pointers[i2++]).type.encode(e4, o2.val, o2.parent);
        }, e3;
      }(), t2.exports = e2;
    }).call(e);
  }), bn = t(function(t2) {
    (function() {
      var e2, r2 = {}.hasOwnProperty;
      e2 = function(e3) {
        function t3(e4, t4) {
          this.type = e4, this.versions = null != t4 ? t4 : {};
        }
        return function(e4, t4) {
          for (var n2 in t4)
            r2.call(t4, n2) && (e4[n2] = t4[n2]);
          function i2() {
            this.constructor = e4;
          }
          i2.prototype = t4.prototype, e4.prototype = new i2(), e4.__super__ = t4.prototype;
        }(t3, e3), t3.prototype.versionGetter = function(e4) {
          if ("string" == typeof this.type)
            return this.type.split(".").reduce(function(e5, t4) {
              return void 0 !== e5 ? e5[t4] : void 0;
            }, e4);
        }, t3.prototype.versionSetter = function(e4, t4) {
          if ("string" == typeof this.type)
            return this.type.split(".").reduce(function(e5, r3) {
              return e5[r3] = t4;
            }, e4);
        }, t3.prototype.decode = function(e4, r3, n2) {
          var i2, a2, o2;
          if (null == n2 && (n2 = 0), a2 = this._setup(e4, r3, n2), "string" == typeof this.type ? a2.version = this.versionGetter(r3) : a2.version = this.type.decode(e4), this.versions.header && this._parseFields(e4, a2, this.versions.header), null == (i2 = this.versions[a2.version]))
            throw new Error("Unknown version " + a2.version);
          return i2 instanceof t3 ? i2.decode(e4, r3) : (this._parseFields(e4, a2, i2), null != (o2 = this.process) && o2.call(a2, e4), a2);
        }, t3.prototype.size = function(e4, t4, r3) {
          var n2, i2, a2, o2, s2, u2;
          if (null == r3 && (r3 = true), !e4)
            throw new Error("Not a fixed size");
          if (n2 = { parent: t4, val: e4, pointerSize: 0 }, o2 = 0, "string" != typeof this.type && (o2 += this.type.size(e4.version, n2)), this.versions.header)
            for (a2 in u2 = this.versions.header)
              null != (s2 = u2[a2]).size && (o2 += s2.size(e4[a2], n2));
          if (null == (i2 = this.versions[e4.version]))
            throw new Error("Unknown version " + e4.version);
          for (a2 in i2)
            null != (s2 = i2[a2]).size && (o2 += s2.size(e4[a2], n2));
          return r3 && (o2 += n2.pointerSize), o2;
        }, t3.prototype.encode = function(e4, t4, r3) {
          var n2, i2, a2, o2, s2, u2, l2, c2;
          if (null != (l2 = this.preEncode) && l2.call(t4, e4), (n2 = { pointers: [], startOffset: e4.pos, parent: r3, val: t4, pointerSize: 0 }).pointerOffset = e4.pos + this.size(t4, n2, false), "string" != typeof this.type && this.type.encode(e4, t4.version), this.versions.header)
            for (o2 in c2 = this.versions.header)
              null != (u2 = c2[o2]).encode && u2.encode(e4, t4[o2], n2);
          for (o2 in i2 = this.versions[t4.version])
            null != (u2 = i2[o2]).encode && u2.encode(e4, t4[o2], n2);
          for (a2 = 0; a2 < n2.pointers.length; )
            (s2 = n2.pointers[a2++]).type.encode(e4, s2.val, s2.parent);
        }, t3;
      }(vn), t2.exports = e2;
    }).call(e);
  }), mn = t(function(t2, r2) {
    (function() {
      var e2, t3, n2;
      n2 = an, e2 = function() {
        function e3(e4, t4, r3) {
          var n3, i2, a2, o2;
          this.offsetType = e4, this.type = t4, this.options = null != r3 ? r3 : {}, "void" === this.type && (this.type = null), null == (n3 = this.options).type && (n3.type = "local"), null == (i2 = this.options).allowNull && (i2.allowNull = true), null == (a2 = this.options).nullValue && (a2.nullValue = 0), null == (o2 = this.options).lazy && (o2.lazy = false);
        }
        return e3.prototype.relativeToGetter = function(e4) {
          return this.options.relativeTo.split(".").reduce(function(e5, t4) {
            return e5[t4];
          }, e4);
        }, e3.prototype.decode = function(e4, t4) {
          var r3, i2, a2, o2, s2, u2, l2;
          return (a2 = this.offsetType.decode(e4, t4)) === this.options.nullValue && this.options.allowNull ? null : (s2 = function() {
            switch (this.options.type) {
              case "local":
                return t4._startOffset;
              case "immediate":
                return e4.pos - this.offsetType.size();
              case "parent":
                return t4.parent._startOffset;
              default:
                for (r3 = t4; r3.parent; )
                  r3 = r3.parent;
                return r3._startOffset || 0;
            }
          }.call(this), this.options.relativeTo && (s2 += this.relativeToGetter(t4)), o2 = a2 + s2, null != this.type ? (u2 = null, l2 = this, i2 = function() {
            var r4;
            return null != u2 || (r4 = e4.pos, e4.pos = o2, u2 = l2.type.decode(e4, t4), e4.pos = r4), u2;
          }, this.options.lazy ? new n2.PropertyDescriptor({ get: i2 }) : i2()) : o2);
        }, e3.prototype.size = function(e4, r3) {
          var n3, i2;
          switch (n3 = r3, this.options.type) {
            case "local":
            case "immediate":
              break;
            case "parent":
              r3 = r3.parent;
              break;
            default:
              for (; r3.parent; )
                r3 = r3.parent;
          }
          if (null == (i2 = this.type)) {
            if (!(e4 instanceof t3))
              throw new Error("Must be a VoidPointer");
            i2 = e4.type, e4 = e4.value;
          }
          return e4 && r3 && (r3.pointerSize += i2.size(e4, n3)), this.offsetType.size();
        }, e3.prototype.encode = function(e4, r3, n3) {
          var i2, a2, o2;
          if (i2 = n3, null != r3) {
            switch (this.options.type) {
              case "local":
                a2 = n3.startOffset;
                break;
              case "immediate":
                a2 = e4.pos + this.offsetType.size(r3, i2);
                break;
              case "parent":
                a2 = (n3 = n3.parent).startOffset;
                break;
              default:
                for (a2 = 0; n3.parent; )
                  n3 = n3.parent;
            }
            if (this.options.relativeTo && (a2 += this.relativeToGetter(i2.val)), this.offsetType.encode(e4, n3.pointerOffset - a2), null == (o2 = this.type)) {
              if (!(r3 instanceof t3))
                throw new Error("Must be a VoidPointer");
              o2 = r3.type, r3 = r3.value;
            }
            return n3.pointers.push({ type: o2, val: r3, parent: i2 }), n3.pointerOffset += o2.size(r3, i2);
          }
          this.offsetType.encode(e4, this.options.nullValue);
        }, e3;
      }(), t3 = function(e3, t4) {
        this.type = e3, this.value = t4;
      }, r2.Pointer = e2, r2.VoidPointer = t3;
    }).call(e);
  }), wn = (mn.Pointer, mn.VoidPointer, t(function(t2, r2) {
    (function() {
      var e2, t3, n2, i2;
      for (e2 in r2.EncodeStream = rn, r2.DecodeStream = tn, r2.Array = un, r2.LazyArray = ln, r2.Bitfield = cn, r2.Boolean = fn, r2.Buffer = hn, r2.Enum = dn, r2.Optional = pn, r2.Reserved = yn, r2.String = gn, r2.Struct = vn, r2.VersionedStruct = bn, n2 = nn)
        t3 = n2[e2], r2[e2] = t3;
      for (e2 in i2 = mn)
        t3 = i2[e2], r2[e2] = t3;
    }).call(e);
  })), Sn = (wn.EncodeStream, wn.DecodeStream, wn.Array, wn.LazyArray, wn.Bitfield, wn.Boolean, wn.Buffer, wn.Enum, wn.Optional, wn.Reserved, wn.String, wn.Struct, wn.VersionedStruct, []), xn = { logErrors: false, registerFormat: function(e2) {
    Sn.push(e2);
  }, create: function(e2, t2) {
    for (var r2 = new b.from(e2), n2 = 0; n2 < Sn.length; n2++) {
      var i2 = Sn[n2];
      if (i2.probe(r2)) {
        var a2 = new i2(new wn.DecodeStream(r2));
        return t2 ? a2.getFont(t2) : a2;
      }
    }
    throw new Error("Unknown font format");
  } };
  function An(e2, t2, r2) {
    if (r2.get) {
      var n2 = r2.get;
      r2.get = function() {
        var e3 = n2.call(this);
        return Object.defineProperty(this, t2, { value: e3 }), e3;
      };
    } else if ("function" == typeof r2.value) {
      var i2 = r2.value;
      return { get: function() {
        var e3 = /* @__PURE__ */ new Map();
        function r3() {
          for (var t3 = arguments.length, r4 = new Array(t3), n3 = 0; n3 < t3; n3++)
            r4[n3] = arguments[n3];
          var a2 = r4.length > 0 ? r4[0] : "value";
          if (e3.has(a2))
            return e3.get(a2);
          var o2 = i2.apply(this, r4);
          return e3.set(a2, o2), o2;
        }
        return Object.defineProperty(this, t2, { value: r3 }), r3;
      } };
    }
  }
  var kn = new wn.Struct({ firstCode: wn.uint16, entryCount: wn.uint16, idDelta: wn.int16, idRangeOffset: wn.uint16 }), Cn = new wn.Struct({ startCharCode: wn.uint32, endCharCode: wn.uint32, glyphID: wn.uint32 }), Pn = new wn.Struct({ startUnicodeValue: wn.uint24, additionalCount: wn.uint8 }), In = new wn.Struct({ unicodeValue: wn.uint24, glyphID: wn.uint16 }), On = new wn.Array(Pn, wn.uint32), En = new wn.Array(In, wn.uint32), Bn = new wn.Struct({ varSelector: wn.uint24, defaultUVS: new wn.Pointer(wn.uint32, On, { type: "parent" }), nonDefaultUVS: new wn.Pointer(wn.uint32, En, { type: "parent" }) }), Tn = new wn.VersionedStruct(wn.uint16, { 0: { length: wn.uint16, language: wn.uint16, codeMap: new wn.LazyArray(wn.uint8, 256) }, 2: { length: wn.uint16, language: wn.uint16, subHeaderKeys: new wn.Array(wn.uint16, 256), subHeaderCount: function(e2) {
    return Math.max.apply(Math, e2.subHeaderKeys);
  }, subHeaders: new wn.LazyArray(kn, "subHeaderCount"), glyphIndexArray: new wn.LazyArray(wn.uint16, "subHeaderCount") }, 4: { length: wn.uint16, language: wn.uint16, segCountX2: wn.uint16, segCount: function(e2) {
    return e2.segCountX2 >> 1;
  }, searchRange: wn.uint16, entrySelector: wn.uint16, rangeShift: wn.uint16, endCode: new wn.LazyArray(wn.uint16, "segCount"), reservedPad: new wn.Reserved(wn.uint16), startCode: new wn.LazyArray(wn.uint16, "segCount"), idDelta: new wn.LazyArray(wn.int16, "segCount"), idRangeOffset: new wn.LazyArray(wn.uint16, "segCount"), glyphIndexArray: new wn.LazyArray(wn.uint16, function(e2) {
    return (e2.length - e2._currentOffset) / 2;
  }) }, 6: { length: wn.uint16, language: wn.uint16, firstCode: wn.uint16, entryCount: wn.uint16, glyphIndices: new wn.LazyArray(wn.uint16, "entryCount") }, 8: { reserved: new wn.Reserved(wn.uint16), length: wn.uint32, language: wn.uint16, is32: new wn.LazyArray(wn.uint8, 8192), nGroups: wn.uint32, groups: new wn.LazyArray(Cn, "nGroups") }, 10: { reserved: new wn.Reserved(wn.uint16), length: wn.uint32, language: wn.uint32, firstCode: wn.uint32, entryCount: wn.uint32, glyphIndices: new wn.LazyArray(wn.uint16, "numChars") }, 12: { reserved: new wn.Reserved(wn.uint16), length: wn.uint32, language: wn.uint32, nGroups: wn.uint32, groups: new wn.LazyArray(Cn, "nGroups") }, 13: { reserved: new wn.Reserved(wn.uint16), length: wn.uint32, language: wn.uint32, nGroups: wn.uint32, groups: new wn.LazyArray(Cn, "nGroups") }, 14: { length: wn.uint32, numRecords: wn.uint32, varSelectors: new wn.LazyArray(Bn, "numRecords") } }), Ln = new wn.Struct({ platformID: wn.uint16, encodingID: wn.uint16, table: new wn.Pointer(wn.uint32, Tn, { type: "parent", lazy: true }) }), zn = new wn.Struct({ version: wn.uint16, numSubtables: wn.uint16, tables: new wn.Array(Ln, "numSubtables") }), Un = new wn.Struct({ version: wn.int32, revision: wn.int32, checkSumAdjustment: wn.uint32, magicNumber: wn.uint32, flags: wn.uint16, unitsPerEm: wn.uint16, created: new wn.Array(wn.int32, 2), modified: new wn.Array(wn.int32, 2), xMin: wn.int16, yMin: wn.int16, xMax: wn.int16, yMax: wn.int16, macStyle: new wn.Bitfield(wn.uint16, ["bold", "italic", "underline", "outline", "shadow", "condensed", "extended"]), lowestRecPPEM: wn.uint16, fontDirectionHint: wn.int16, indexToLocFormat: wn.int16, glyphDataFormat: wn.int16 }), Dn = new wn.Struct({ version: wn.int32, ascent: wn.int16, descent: wn.int16, lineGap: wn.int16, advanceWidthMax: wn.uint16, minLeftSideBearing: wn.int16, minRightSideBearing: wn.int16, xMaxExtent: wn.int16, caretSlopeRise: wn.int16, caretSlopeRun: wn.int16, caretOffset: wn.int16, reserved: new wn.Reserved(wn.int16, 4), metricDataFormat: wn.int16, numberOfMetrics: wn.uint16 }), jn = new wn.Struct({ advance: wn.uint16, bearing: wn.int16 }), Mn = new wn.Struct({ metrics: new wn.LazyArray(jn, function(e2) {
    return e2.parent.hhea.numberOfMetrics;
  }), bearings: new wn.LazyArray(wn.int16, function(e2) {
    return e2.parent.maxp.numGlyphs - e2.parent.hhea.numberOfMetrics;
  }) }), Fn = new wn.Struct({ version: wn.int32, numGlyphs: wn.uint16, maxPoints: wn.uint16, maxContours: wn.uint16, maxComponentPoints: wn.uint16, maxComponentContours: wn.uint16, maxZones: wn.uint16, maxTwilightPoints: wn.uint16, maxStorage: wn.uint16, maxFunctionDefs: wn.uint16, maxInstructionDefs: wn.uint16, maxStackElements: wn.uint16, maxSizeOfInstructions: wn.uint16, maxComponentElements: wn.uint16, maxComponentDepth: wn.uint16 });
  function Rn(e2, t2, r2) {
    return void 0 === r2 && (r2 = 0), 1 === e2 && qn[r2] ? qn[r2] : Nn[e2][t2];
  }
  var Nn = [["utf16be", "utf16be", "utf16be", "utf16be", "utf16be", "utf16be"], ["macroman", "shift-jis", "big5", "euc-kr", "iso-8859-6", "iso-8859-8", "macgreek", "maccyrillic", "symbol", "Devanagari", "Gurmukhi", "Gujarati", "Oriya", "Bengali", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhalese", "Burmese", "Khmer", "macthai", "Laotian", "Georgian", "Armenian", "gb-2312-80", "Tibetan", "Mongolian", "Geez", "maccenteuro", "Vietnamese", "Sindhi"], ["ascii"], ["symbol", "utf16be", "shift-jis", "gb18030", "big5", "wansung", "johab", null, null, null, "utf16be"]], qn = { 15: "maciceland", 17: "macturkish", 18: "maccroatian", 24: "maccenteuro", 25: "maccenteuro", 26: "maccenteuro", 27: "maccenteuro", 28: "maccenteuro", 30: "maciceland", 37: "macromania", 38: "maccenteuro", 39: "maccenteuro", 40: "maccenteuro", 143: "macinuit", 146: "macgaelic" }, Gn = [[], { 0: "en", 30: "fo", 60: "ks", 90: "rw", 1: "fr", 31: "fa", 61: "ku", 91: "rn", 2: "de", 32: "ru", 62: "sd", 92: "ny", 3: "it", 33: "zh", 63: "bo", 93: "mg", 4: "nl", 34: "nl-BE", 64: "ne", 94: "eo", 5: "sv", 35: "ga", 65: "sa", 128: "cy", 6: "es", 36: "sq", 66: "mr", 129: "eu", 7: "da", 37: "ro", 67: "bn", 130: "ca", 8: "pt", 38: "cz", 68: "as", 131: "la", 9: "no", 39: "sk", 69: "gu", 132: "qu", 10: "he", 40: "si", 70: "pa", 133: "gn", 11: "ja", 41: "yi", 71: "or", 134: "ay", 12: "ar", 42: "sr", 72: "ml", 135: "tt", 13: "fi", 43: "mk", 73: "kn", 136: "ug", 14: "el", 44: "bg", 74: "ta", 137: "dz", 15: "is", 45: "uk", 75: "te", 138: "jv", 16: "mt", 46: "be", 76: "si", 139: "su", 17: "tr", 47: "uz", 77: "my", 140: "gl", 18: "hr", 48: "kk", 78: "km", 141: "af", 19: "zh-Hant", 49: "az-Cyrl", 79: "lo", 142: "br", 20: "ur", 50: "az-Arab", 80: "vi", 143: "iu", 21: "hi", 51: "hy", 81: "id", 144: "gd", 22: "th", 52: "ka", 82: "tl", 145: "gv", 23: "ko", 53: "mo", 83: "ms", 146: "ga", 24: "lt", 54: "ky", 84: "ms-Arab", 147: "to", 25: "pl", 55: "tg", 85: "am", 148: "el-polyton", 26: "hu", 56: "tk", 86: "ti", 149: "kl", 27: "es", 57: "mn-CN", 87: "om", 150: "az", 28: "lv", 58: "mn", 88: "so", 151: "nn", 29: "se", 59: "ps", 89: "sw" }, [], { 1078: "af", 16393: "en-IN", 1159: "rw", 1074: "tn", 1052: "sq", 6153: "en-IE", 1089: "sw", 1115: "si", 1156: "gsw", 8201: "en-JM", 1111: "kok", 1051: "sk", 1118: "am", 17417: "en-MY", 1042: "ko", 1060: "sl", 5121: "ar-DZ", 5129: "en-NZ", 1088: "ky", 11274: "es-AR", 15361: "ar-BH", 13321: "en-PH", 1108: "lo", 16394: "es-BO", 3073: "ar", 18441: "en-SG", 1062: "lv", 13322: "es-CL", 2049: "ar-IQ", 7177: "en-ZA", 1063: "lt", 9226: "es-CO", 11265: "ar-JO", 11273: "en-TT", 2094: "dsb", 5130: "es-CR", 13313: "ar-KW", 2057: "en-GB", 1134: "lb", 7178: "es-DO", 12289: "ar-LB", 1033: "en", 1071: "mk", 12298: "es-EC", 4097: "ar-LY", 12297: "en-ZW", 2110: "ms-BN", 17418: "es-SV", 6145: "ary", 1061: "et", 1086: "ms", 4106: "es-GT", 8193: "ar-OM", 1080: "fo", 1100: "ml", 18442: "es-HN", 16385: "ar-QA", 1124: "fil", 1082: "mt", 2058: "es-MX", 1025: "ar-SA", 1035: "fi", 1153: "mi", 19466: "es-NI", 10241: "ar-SY", 2060: "fr-BE", 1146: "arn", 6154: "es-PA", 7169: "aeb", 3084: "fr-CA", 1102: "mr", 15370: "es-PY", 14337: "ar-AE", 1036: "fr", 1148: "moh", 10250: "es-PE", 9217: "ar-YE", 5132: "fr-LU", 1104: "mn", 20490: "es-PR", 1067: "hy", 6156: "fr-MC", 2128: "mn-CN", 3082: "es", 1101: "as", 4108: "fr-CH", 1121: "ne", 1034: "es", 2092: "az-Cyrl", 1122: "fy", 1044: "nb", 21514: "es-US", 1068: "az", 1110: "gl", 2068: "nn", 14346: "es-UY", 1133: "ba", 1079: "ka", 1154: "oc", 8202: "es-VE", 1069: "eu", 3079: "de-AT", 1096: "or", 2077: "sv-FI", 1059: "be", 1031: "de", 1123: "ps", 1053: "sv", 2117: "bn", 5127: "de-LI", 1045: "pl", 1114: "syr", 1093: "bn-IN", 4103: "de-LU", 1046: "pt", 1064: "tg", 8218: "bs-Cyrl", 2055: "de-CH", 2070: "pt-PT", 2143: "tzm", 5146: "bs", 1032: "el", 1094: "pa", 1097: "ta", 1150: "br", 1135: "kl", 1131: "qu-BO", 1092: "tt", 1026: "bg", 1095: "gu", 2155: "qu-EC", 1098: "te", 1027: "ca", 1128: "ha", 3179: "qu", 1054: "th", 3076: "zh-HK", 1037: "he", 1048: "ro", 1105: "bo", 5124: "zh-MO", 1081: "hi", 1047: "rm", 1055: "tr", 2052: "zh", 1038: "hu", 1049: "ru", 1090: "tk", 4100: "zh-SG", 1039: "is", 9275: "smn", 1152: "ug", 1028: "zh-TW", 1136: "ig", 4155: "smj-NO", 1058: "uk", 1155: "co", 1057: "id", 5179: "smj", 1070: "hsb", 1050: "hr", 1117: "iu", 3131: "se-FI", 1056: "ur", 4122: "hr-BA", 2141: "iu-Latn", 1083: "se", 2115: "uz-Cyrl", 1029: "cs", 2108: "ga", 2107: "se-SE", 1091: "uz", 1030: "da", 1076: "xh", 8251: "sms", 1066: "vi", 1164: "prs", 1077: "zu", 6203: "sma-NO", 1106: "cy", 1125: "dv", 1040: "it", 7227: "sms", 1160: "wo", 2067: "nl-BE", 2064: "it-CH", 1103: "sa", 1157: "sah", 1043: "nl", 1041: "ja", 7194: "sr-Cyrl-BA", 1144: "ii", 3081: "en-AU", 1099: "kn", 3098: "sr", 1130: "yo", 10249: "en-BZ", 1087: "kk", 6170: "sr-Latn-BA", 4105: "en-CA", 1107: "km", 2074: "sr-Latn", 9225: "en-029", 1158: "quc", 1132: "nso" }];
  function Vn(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return _n(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return _n(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function _n(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Wn = new wn.Struct({ platformID: wn.uint16, encodingID: wn.uint16, languageID: wn.uint16, nameID: wn.uint16, length: wn.uint16, string: new wn.Pointer(wn.uint16, new wn.String("length", function(e2) {
    return Rn(e2.platformID, e2.encodingID, e2.languageID);
  }), { type: "parent", relativeTo: "parent.stringOffset", allowNull: false }) }), Hn = new wn.Struct({ length: wn.uint16, tag: new wn.Pointer(wn.uint16, new wn.String("length", "utf16be"), { type: "parent", relativeTo: "stringOffset" }) }), Yn = new wn.VersionedStruct(wn.uint16, { 0: { count: wn.uint16, stringOffset: wn.uint16, records: new wn.Array(Wn, "count") }, 1: { count: wn.uint16, stringOffset: wn.uint16, records: new wn.Array(Wn, "count"), langTagCount: wn.uint16, langTags: new wn.Array(Hn, "langTagCount") } }), Xn = ["copyright", "fontFamily", "fontSubfamily", "uniqueSubfamily", "fullName", "version", "postscriptName", "trademark", "manufacturer", "designer", "description", "vendorURL", "designerURL", "license", "licenseURL", null, "preferredFamily", "preferredSubfamily", "compatibleFull", "sampleText", "postscriptCIDFontName", "wwsFamilyName", "wwsSubfamilyName"];
  Yn.process = function(e2) {
    for (var t2, r2 = {}, n2 = Vn(this.records); !(t2 = n2()).done; ) {
      var i2 = t2.value, a2 = Gn[i2.platformID][i2.languageID];
      null == a2 && null != this.langTags && i2.languageID >= 32768 && (a2 = this.langTags[i2.languageID - 32768].tag), null == a2 && (a2 = i2.platformID + "-" + i2.languageID);
      var o2 = i2.nameID >= 256 ? "fontFeatures" : Xn[i2.nameID] || i2.nameID;
      null == r2[o2] && (r2[o2] = {});
      var s2 = r2[o2];
      i2.nameID >= 256 && (s2 = s2[i2.nameID] || (s2[i2.nameID] = {})), "string" != typeof i2.string && "string" == typeof s2[a2] || (s2[a2] = i2.string);
    }
    this.records = r2;
  }, Yn.preEncode = function() {
    if (!Array.isArray(this.records)) {
      this.version = 0;
      var e2 = [];
      for (var t2 in this.records) {
        var r2 = this.records[t2];
        "fontFeatures" !== t2 && (e2.push({ platformID: 3, encodingID: 1, languageID: 1033, nameID: Xn.indexOf(t2), length: b.byteLength(r2.en, "utf16le"), string: r2.en }), "postscriptName" === t2 && e2.push({ platformID: 1, encodingID: 0, languageID: 0, nameID: Xn.indexOf(t2), length: r2.en.length, string: r2.en }));
      }
      this.records = e2, this.count = e2.length, this.stringOffset = Yn.size(this, null, false);
    }
  };
  var Zn = new wn.VersionedStruct(wn.uint16, { header: { xAvgCharWidth: wn.int16, usWeightClass: wn.uint16, usWidthClass: wn.uint16, fsType: new wn.Bitfield(wn.uint16, [null, "noEmbedding", "viewOnly", "editable", null, null, null, null, "noSubsetting", "bitmapOnly"]), ySubscriptXSize: wn.int16, ySubscriptYSize: wn.int16, ySubscriptXOffset: wn.int16, ySubscriptYOffset: wn.int16, ySuperscriptXSize: wn.int16, ySuperscriptYSize: wn.int16, ySuperscriptXOffset: wn.int16, ySuperscriptYOffset: wn.int16, yStrikeoutSize: wn.int16, yStrikeoutPosition: wn.int16, sFamilyClass: wn.int16, panose: new wn.Array(wn.uint8, 10), ulCharRange: new wn.Array(wn.uint32, 4), vendorID: new wn.String(4), fsSelection: new wn.Bitfield(wn.uint16, ["italic", "underscore", "negative", "outlined", "strikeout", "bold", "regular", "useTypoMetrics", "wws", "oblique"]), usFirstCharIndex: wn.uint16, usLastCharIndex: wn.uint16 }, 0: {}, 1: { typoAscender: wn.int16, typoDescender: wn.int16, typoLineGap: wn.int16, winAscent: wn.uint16, winDescent: wn.uint16, codePageRange: new wn.Array(wn.uint32, 2) }, 2: { typoAscender: wn.int16, typoDescender: wn.int16, typoLineGap: wn.int16, winAscent: wn.uint16, winDescent: wn.uint16, codePageRange: new wn.Array(wn.uint32, 2), xHeight: wn.int16, capHeight: wn.int16, defaultChar: wn.uint16, breakChar: wn.uint16, maxContent: wn.uint16 }, 5: { typoAscender: wn.int16, typoDescender: wn.int16, typoLineGap: wn.int16, winAscent: wn.uint16, winDescent: wn.uint16, codePageRange: new wn.Array(wn.uint32, 2), xHeight: wn.int16, capHeight: wn.int16, defaultChar: wn.uint16, breakChar: wn.uint16, maxContent: wn.uint16, usLowerOpticalPointSize: wn.uint16, usUpperOpticalPointSize: wn.uint16 } }), Kn = Zn.versions;
  Kn[3] = Kn[4] = Kn[2];
  var Jn = new wn.VersionedStruct(wn.fixed32, { header: { italicAngle: wn.fixed32, underlinePosition: wn.int16, underlineThickness: wn.int16, isFixedPitch: wn.uint32, minMemType42: wn.uint32, maxMemType42: wn.uint32, minMemType1: wn.uint32, maxMemType1: wn.uint32 }, 1: {}, 2: { numberOfGlyphs: wn.uint16, glyphNameIndex: new wn.Array(wn.uint16, "numberOfGlyphs"), names: new wn.Array(new wn.String(wn.uint8)) }, 2.5: { numberOfGlyphs: wn.uint16, offsets: new wn.Array(wn.uint8, "numberOfGlyphs") }, 3: {}, 4: { map: new wn.Array(wn.uint32, function(e2) {
    return e2.parent.maxp.numGlyphs;
  }) } }), Qn = new wn.Struct({ controlValues: new wn.Array(wn.int16) }), $n = new wn.Struct({ instructions: new wn.Array(wn.uint8) }), ei = new wn.VersionedStruct("head.indexToLocFormat", { 0: { offsets: new wn.Array(wn.uint16) }, 1: { offsets: new wn.Array(wn.uint32) } });
  ei.process = function() {
    if (0 === this.version)
      for (var e2 = 0; e2 < this.offsets.length; e2++)
        this.offsets[e2] <<= 1;
  }, ei.preEncode = function() {
    if (null == this.version && (this.version = this.offsets[this.offsets.length - 1] > 65535 ? 1 : 0, 0 === this.version))
      for (var e2 = 0; e2 < this.offsets.length; e2++)
        this.offsets[e2] >>>= 1;
  };
  var ti = new wn.Struct({ controlValueProgram: new wn.Array(wn.uint8) }), ri = new wn.Array(new wn.Buffer());
  function ni(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return ii(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return ii(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function ii(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var ai, oi = function() {
    function e2(e3) {
      this.type = e3;
    }
    var t2 = e2.prototype;
    return t2.getCFFVersion = function(e3) {
      for (; e3 && !e3.hdrSize; )
        e3 = e3.parent;
      return e3 ? e3.version : -1;
    }, t2.decode = function(e3, t3) {
      var r2 = this.getCFFVersion(t3) >= 2 ? e3.readUInt32BE() : e3.readUInt16BE();
      if (0 === r2)
        return [];
      var n2, i2 = e3.readUInt8();
      if (1 === i2)
        n2 = wn.uint8;
      else if (2 === i2)
        n2 = wn.uint16;
      else if (3 === i2)
        n2 = wn.uint24;
      else {
        if (4 !== i2)
          throw new Error("Bad offset size in CFFIndex: " + i2 + " " + e3.pos);
        n2 = wn.uint32;
      }
      for (var a2 = [], o2 = e3.pos + (r2 + 1) * i2 - 1, s2 = n2.decode(e3), u2 = 0; u2 < r2; u2++) {
        var l2 = n2.decode(e3);
        if (null != this.type) {
          var c2 = e3.pos;
          e3.pos = o2 + s2, t3.length = l2 - s2, a2.push(this.type.decode(e3, t3)), e3.pos = c2;
        } else
          a2.push({ offset: o2 + s2, length: l2 - s2 });
        s2 = l2;
      }
      return e3.pos = o2 + s2, a2;
    }, t2.size = function(e3, t3) {
      var r2 = 2;
      if (0 === e3.length)
        return r2;
      for (var n2, i2 = this.type || new wn.Buffer(), a2 = 1, o2 = 0; o2 < e3.length; o2++) {
        var s2 = e3[o2];
        a2 += i2.size(s2, t3);
      }
      if (a2 <= 255)
        n2 = wn.uint8;
      else if (a2 <= 65535)
        n2 = wn.uint16;
      else if (a2 <= 16777215)
        n2 = wn.uint24;
      else {
        if (!(a2 <= 4294967295))
          throw new Error("Bad offset in CFFIndex");
        n2 = wn.uint32;
      }
      return r2 += 1 + n2.size() * (e3.length + 1), r2 += a2 - 1, r2;
    }, t2.encode = function(e3, t3, r2) {
      if (e3.writeUInt16BE(t3.length), 0 !== t3.length) {
        for (var n2, i2, a2 = this.type || new wn.Buffer(), o2 = [], s2 = 1, u2 = ni(t3); !(n2 = u2()).done; ) {
          var l2 = n2.value, c2 = a2.size(l2, r2);
          o2.push(c2), s2 += c2;
        }
        if (s2 <= 255)
          i2 = wn.uint8;
        else if (s2 <= 65535)
          i2 = wn.uint16;
        else if (s2 <= 16777215)
          i2 = wn.uint24;
        else {
          if (!(s2 <= 4294967295))
            throw new Error("Bad offset in CFFIndex");
          i2 = wn.uint32;
        }
        e3.writeUInt8(i2.size()), s2 = 1, i2.encode(e3, s2);
        for (var f2 = 0, h2 = o2; f2 < h2.length; f2++) {
          s2 += h2[f2], i2.encode(e3, s2);
        }
        for (var d2, p2 = ni(t3); !(d2 = p2()).done; ) {
          var y2 = d2.value;
          a2.encode(e3, y2, r2);
        }
      }
    }, e2;
  }(), si = Object.prototype.toString, ui = function(e2) {
    var t2 = si.call(e2), r2 = "[object Arguments]" === t2;
    return r2 || (r2 = "[object Array]" !== t2 && null !== e2 && "object" == typeof e2 && "number" == typeof e2.length && e2.length >= 0 && "[object Function]" === si.call(e2.callee)), r2;
  };
  if (!Object.keys) {
    var li = Object.prototype.hasOwnProperty, ci = Object.prototype.toString, fi = ui, hi = Object.prototype.propertyIsEnumerable, di = !hi.call({ toString: null }, "toString"), pi = hi.call(function() {
    }, "prototype"), yi = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], gi = function(e2) {
      var t2 = e2.constructor;
      return t2 && t2.prototype === e2;
    }, vi = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, bi = function() {
      if ("undefined" == typeof window)
        return false;
      for (var e2 in window)
        try {
          if (!vi["$" + e2] && li.call(window, e2) && null !== window[e2] && "object" == typeof window[e2])
            try {
              gi(window[e2]);
            } catch (e3) {
              return true;
            }
        } catch (e3) {
          return true;
        }
      return false;
    }();
    ai = function(e2) {
      var t2 = null !== e2 && "object" == typeof e2, r2 = "[object Function]" === ci.call(e2), n2 = fi(e2), i2 = t2 && "[object String]" === ci.call(e2), a2 = [];
      if (!t2 && !r2 && !n2)
        throw new TypeError("Object.keys called on a non-object");
      var o2 = pi && r2;
      if (i2 && e2.length > 0 && !li.call(e2, 0))
        for (var s2 = 0; s2 < e2.length; ++s2)
          a2.push(String(s2));
      if (n2 && e2.length > 0)
        for (var u2 = 0; u2 < e2.length; ++u2)
          a2.push(String(u2));
      else
        for (var l2 in e2)
          o2 && "prototype" === l2 || !li.call(e2, l2) || a2.push(String(l2));
      if (di)
        for (var c2 = function(e3) {
          if ("undefined" == typeof window || !bi)
            return gi(e3);
          try {
            return gi(e3);
          } catch (e4) {
            return false;
          }
        }(e2), f2 = 0; f2 < yi.length; ++f2)
          c2 && "constructor" === yi[f2] || !li.call(e2, yi[f2]) || a2.push(yi[f2]);
      return a2;
    };
  }
  var mi = ai, wi = Array.prototype.slice, Si = Object.keys, xi = Si ? function(e2) {
    return Si(e2);
  } : mi, Ai = Object.keys;
  xi.shim = function() {
    Object.keys ? function() {
      var e2 = Object.keys(arguments);
      return e2 && e2.length === arguments.length;
    }(1, 2) || (Object.keys = function(e2) {
      return ui(e2) ? Ai(wi.call(e2)) : Ai(e2);
    }) : Object.keys = xi;
    return Object.keys || xi;
  };
  var ki = xi, Ci = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, Pi = Object.prototype.toString, Ii = function(e2) {
    return !(Ci && e2 && "object" == typeof e2 && Symbol.toStringTag in e2) && "[object Arguments]" === Pi.call(e2);
  }, Oi = function(e2) {
    return !!Ii(e2) || null !== e2 && "object" == typeof e2 && "number" == typeof e2.length && e2.length >= 0 && "[object Array]" !== Pi.call(e2) && "[object Function]" === Pi.call(e2.callee);
  }, Ei = function() {
    return Ii(arguments);
  }();
  Ii.isLegacyArguments = Oi;
  var Bi = Ei ? Ii : Oi, Ti = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"), Li = Object.prototype.toString, zi = Array.prototype.concat, Ui = Object.defineProperty, Di = Ui && function() {
    var e2 = {};
    try {
      for (var t2 in Ui(e2, "x", { enumerable: false, value: e2 }), e2)
        return false;
      return e2.x === e2;
    } catch (e3) {
      return false;
    }
  }(), ji = function(e2, t2, r2, n2) {
    var i2;
    (!(t2 in e2) || "function" == typeof (i2 = n2) && "[object Function]" === Li.call(i2) && n2()) && (Di ? Ui(e2, t2, { configurable: true, enumerable: false, value: r2, writable: true }) : e2[t2] = r2);
  }, Mi = function(e2, t2) {
    var r2 = arguments.length > 2 ? arguments[2] : {}, n2 = ki(t2);
    Ti && (n2 = zi.call(n2, Object.getOwnPropertySymbols(t2)));
    for (var i2 = 0; i2 < n2.length; i2 += 1)
      ji(e2, n2[i2], t2[n2[i2]], r2[n2[i2]]);
  };
  Mi.supportsDescriptors = !!Di;
  var Fi = Mi, Ri = "Function.prototype.bind called on incompatible ", Ni = Array.prototype.slice, qi = Object.prototype.toString, Gi = Function.prototype.bind || function(e2) {
    var t2 = this;
    if ("function" != typeof t2 || "[object Function]" !== qi.call(t2))
      throw new TypeError(Ri + t2);
    for (var r2, n2 = Ni.call(arguments, 1), i2 = function() {
      if (this instanceof r2) {
        var i3 = t2.apply(this, n2.concat(Ni.call(arguments)));
        return Object(i3) === i3 ? i3 : this;
      }
      return t2.apply(e2, n2.concat(Ni.call(arguments)));
    }, a2 = Math.max(0, t2.length - n2.length), o2 = [], s2 = 0; s2 < a2; s2++)
      o2.push("$" + s2);
    if (r2 = Function("binder", "return function (" + o2.join(",") + "){ return binder.apply(this,arguments); }")(i2), t2.prototype) {
      var u2 = function() {
      };
      u2.prototype = t2.prototype, r2.prototype = new u2(), u2.prototype = null;
    }
    return r2;
  }, Vi = e.Symbol, _i = TypeError, Wi = Object.getOwnPropertyDescriptor;
  if (Wi)
    try {
      Wi({}, "");
    } catch (e2) {
      Wi = null;
    }
  var Hi = function() {
    throw new _i();
  }, Yi = Wi ? function() {
    try {
      return arguments.callee, Hi;
    } catch (e2) {
      try {
        return Wi(arguments, "callee").get;
      } catch (e3) {
        return Hi;
      }
    }
  }() : Hi, Xi = "function" == typeof Vi && "function" == typeof Symbol && "symbol" == typeof Vi("foo") && "symbol" == typeof Symbol("bar") && function() {
    if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
      return false;
    if ("symbol" == typeof Symbol.iterator)
      return true;
    var e2 = {}, t2 = Symbol("test"), r2 = Object(t2);
    if ("string" == typeof t2)
      return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(t2))
      return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(r2))
      return false;
    for (t2 in e2[t2] = 42, e2)
      return false;
    if ("function" == typeof Object.keys && 0 !== Object.keys(e2).length)
      return false;
    if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e2).length)
      return false;
    var n2 = Object.getOwnPropertySymbols(e2);
    if (1 !== n2.length || n2[0] !== t2)
      return false;
    if (!Object.prototype.propertyIsEnumerable.call(e2, t2))
      return false;
    if ("function" == typeof Object.getOwnPropertyDescriptor) {
      var i2 = Object.getOwnPropertyDescriptor(e2, t2);
      if (42 !== i2.value || true !== i2.enumerable)
        return false;
    }
    return true;
  }(), Zi = Object.getPrototypeOf || function(e2) {
    return e2.__proto__;
  }, Ki = "undefined" == typeof Uint8Array ? void 0 : Zi(Uint8Array), Ji = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": Xi ? Zi([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": Xi ? Zi(Zi([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && Xi ? Zi((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && Xi ? Zi((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": Xi ? Zi(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": Xi ? Symbol : void 0, "%SymbolPrototype%": Xi ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": Yi, "%TypedArray%": Ki, "%TypedArrayPrototype%": Ki ? Ki.prototype : void 0, "%TypeError%": _i, "%TypeErrorPrototype%": _i.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype }, Qi = Gi.call(Function.call, String.prototype.replace), $i = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ea = /\\(\\)?/g, ta = function(e2) {
    var t2 = [];
    return Qi(e2, $i, function(e3, r2, n2, i2) {
      t2[t2.length] = n2 ? Qi(i2, ea, "$1") : r2 || e3;
    }), t2;
  }, ra = function(e2, t2) {
    if (!(e2 in Ji))
      throw new SyntaxError("intrinsic " + e2 + " does not exist!");
    if (void 0 === Ji[e2] && !t2)
      throw new _i("intrinsic " + e2 + " exists, but is not available. Please file an issue!");
    return Ji[e2];
  }, na = function(e2, t2) {
    if ("string" != typeof e2 || 0 === e2.length)
      throw new TypeError("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && "boolean" != typeof t2)
      throw new TypeError('"allowMissing" argument must be a boolean');
    for (var r2 = ta(e2), n2 = ra("%" + (r2.length > 0 ? r2[0] : "") + "%", t2), i2 = 1; i2 < r2.length; i2 += 1)
      if (null != n2)
        if (Wi && i2 + 1 >= r2.length) {
          var a2 = Wi(n2, r2[i2]);
          if (!t2 && !(r2[i2] in n2))
            throw new _i("base intrinsic for " + e2 + " exists, but the property is not available.");
          n2 = a2 ? a2.get || a2.value : n2[r2[i2]];
        } else
          n2 = n2[r2[i2]];
    return n2;
  }("%Function%"), ia = na.apply, aa = na.call, oa = function() {
    return Gi.apply(aa, arguments);
  };
  oa.apply = function() {
    return Gi.apply(ia, arguments);
  };
  var sa = function(e2) {
    return e2 != e2;
  }, ua = function(e2, t2) {
    return 0 === e2 && 0 === t2 ? 1 / e2 == 1 / t2 : e2 === t2 || !(!sa(e2) || !sa(t2));
  }, la = function() {
    return "function" == typeof Object.is ? Object.is : ua;
  }, ca = oa(la(), Object);
  Fi(ca, { getPolyfill: la, implementation: ua, shim: function() {
    var e2 = la();
    return Fi(Object, { is: e2 }, { is: function() {
      return Object.is !== e2;
    } }), e2;
  } });
  var fa = ca, ha = Gi.call(Function.call, Object.prototype.hasOwnProperty), da = RegExp.prototype.exec, pa = Object.getOwnPropertyDescriptor, ya = Object.prototype.toString, ga = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, va = function(e2) {
    if (!e2 || "object" != typeof e2)
      return false;
    if (!ga)
      return "[object RegExp]" === ya.call(e2);
    var t2 = pa(e2, "lastIndex");
    return !(!t2 || !ha(t2, "value")) && function(e3) {
      try {
        var t3 = e3.lastIndex;
        return e3.lastIndex = 0, da.call(e3), true;
      } catch (e4) {
        return false;
      } finally {
        e3.lastIndex = t3;
      }
    }(e2);
  }, ba = Object, ma = TypeError, wa = function() {
    if (null != this && this !== ba(this))
      throw new ma("RegExp.prototype.flags getter called on non-object");
    var e2 = "";
    return this.global && (e2 += "g"), this.ignoreCase && (e2 += "i"), this.multiline && (e2 += "m"), this.dotAll && (e2 += "s"), this.unicode && (e2 += "u"), this.sticky && (e2 += "y"), e2;
  }, Sa = Fi.supportsDescriptors, xa = Object.getOwnPropertyDescriptor, Aa = TypeError, ka = function() {
    if (!Sa)
      throw new Aa("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    if ("gim" === /a/gim.flags) {
      var e2 = xa(RegExp.prototype, "flags");
      if (e2 && "function" == typeof e2.get && "boolean" == typeof /a/.dotAll)
        return e2.get;
    }
    return wa;
  }, Ca = Fi.supportsDescriptors, Pa = Object.getOwnPropertyDescriptor, Ia = Object.defineProperty, Oa = TypeError, Ea = Object.getPrototypeOf, Ba = /a/, Ta = oa(wa);
  Fi(Ta, { getPolyfill: ka, implementation: wa, shim: function() {
    if (!Ca || !Ea)
      throw new Oa("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    var e2 = ka(), t2 = Ea(Ba), r2 = Pa(t2, "flags");
    return r2 && r2.get === e2 || Ia(t2, "flags", { configurable: true, enumerable: false, get: e2 }), e2;
  } });
  var La = Ta, za = Date.prototype.getDay, Ua = Object.prototype.toString, Da = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, ja = function(e2) {
    return "object" == typeof e2 && null !== e2 && (Da ? function(e3) {
      try {
        return za.call(e3), true;
      } catch (e4) {
        return false;
      }
    }(e2) : "[object Date]" === Ua.call(e2));
  }, Ma = Date.prototype.getTime;
  function Fa(e2, t2, r2) {
    var n2 = r2 || {};
    return !!(n2.strict ? fa(e2, t2) : e2 === t2) || (!e2 || !t2 || "object" != typeof e2 && "object" != typeof t2 ? n2.strict ? fa(e2, t2) : e2 == t2 : function(e3, t3, r3) {
      var n3, i2;
      if (typeof e3 != typeof t3)
        return false;
      if (Ra(e3) || Ra(t3))
        return false;
      if (e3.prototype !== t3.prototype)
        return false;
      if (Bi(e3) !== Bi(t3))
        return false;
      var a2 = va(e3), o2 = va(t3);
      if (a2 !== o2)
        return false;
      if (a2 || o2)
        return e3.source === t3.source && La(e3) === La(t3);
      if (ja(e3) && ja(t3))
        return Ma.call(e3) === Ma.call(t3);
      var s2 = Na(e3), u2 = Na(t3);
      if (s2 !== u2)
        return false;
      if (s2 || u2) {
        if (e3.length !== t3.length)
          return false;
        for (n3 = 0; n3 < e3.length; n3++)
          if (e3[n3] !== t3[n3])
            return false;
        return true;
      }
      if (typeof e3 != typeof t3)
        return false;
      try {
        var l2 = ki(e3), c2 = ki(t3);
      } catch (e4) {
        return false;
      }
      if (l2.length !== c2.length)
        return false;
      for (l2.sort(), c2.sort(), n3 = l2.length - 1; n3 >= 0; n3--)
        if (l2[n3] != c2[n3])
          return false;
      for (n3 = l2.length - 1; n3 >= 0; n3--)
        if (i2 = l2[n3], !Fa(e3[i2], t3[i2], r3))
          return false;
      return true;
    }(e2, t2, n2));
  }
  function Ra(e2) {
    return null == e2;
  }
  function Na(e2) {
    return !(!e2 || "object" != typeof e2 || "number" != typeof e2.length) && ("function" == typeof e2.copy && "function" == typeof e2.slice && !(e2.length > 0 && "number" != typeof e2[0]));
  }
  var qa = Fa, Ga = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"], Va = { ".": 10, E: 11, "E-": 12, "-": 14 }, _a = function() {
    function e2() {
    }
    return e2.decode = function(e3, t2) {
      if (32 <= t2 && t2 <= 246)
        return t2 - 139;
      if (247 <= t2 && t2 <= 250)
        return 256 * (t2 - 247) + e3.readUInt8() + 108;
      if (251 <= t2 && t2 <= 254)
        return 256 * -(t2 - 251) - e3.readUInt8() - 108;
      if (28 === t2)
        return e3.readInt16BE();
      if (29 === t2)
        return e3.readInt32BE();
      if (30 === t2) {
        for (var r2 = ""; ; ) {
          var n2 = e3.readUInt8(), i2 = n2 >> 4;
          if (15 === i2)
            break;
          r2 += Ga[i2];
          var a2 = 15 & n2;
          if (15 === a2)
            break;
          r2 += Ga[a2];
        }
        return parseFloat(r2);
      }
      return null;
    }, e2.size = function(e3) {
      if (e3.forceLarge && (e3 = 32768), (0 | e3) !== e3) {
        var t2 = "" + e3;
        return 1 + Math.ceil((t2.length + 1) / 2);
      }
      return -107 <= e3 && e3 <= 107 ? 1 : 108 <= e3 && e3 <= 1131 || -1131 <= e3 && e3 <= -108 ? 2 : -32768 <= e3 && e3 <= 32767 ? 3 : 5;
    }, e2.encode = function(e3, t2) {
      var r2 = Number(t2);
      if (t2.forceLarge)
        return e3.writeUInt8(29), e3.writeInt32BE(r2);
      if ((0 | r2) === r2)
        return -107 <= r2 && r2 <= 107 ? e3.writeUInt8(r2 + 139) : 108 <= r2 && r2 <= 1131 ? (r2 -= 108, e3.writeUInt8(247 + (r2 >> 8)), e3.writeUInt8(255 & r2)) : -1131 <= r2 && r2 <= -108 ? (r2 = -r2 - 108, e3.writeUInt8(251 + (r2 >> 8)), e3.writeUInt8(255 & r2)) : -32768 <= r2 && r2 <= 32767 ? (e3.writeUInt8(28), e3.writeInt16BE(r2)) : (e3.writeUInt8(29), e3.writeInt32BE(r2));
      e3.writeUInt8(30);
      for (var n2 = "" + r2, i2 = 0; i2 < n2.length; i2 += 2) {
        var a2 = n2[i2], o2 = Va[a2] || +a2;
        if (i2 === n2.length - 1)
          var s2 = 15;
        else {
          var u2 = n2[i2 + 1];
          s2 = Va[u2] || +u2;
        }
        e3.writeUInt8(o2 << 4 | 15 & s2);
      }
      return 15 !== s2 ? e3.writeUInt8(240) : void 0;
    }, e2;
  }();
  function Wa(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Ha(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Ha(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Ha(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Ya = function() {
    function e2(e3) {
      void 0 === e3 && (e3 = []), this.ops = e3, this.fields = {};
      for (var t3, r2 = Wa(e3); !(t3 = r2()).done; ) {
        var n2 = t3.value, i2 = Array.isArray(n2[0]) ? n2[0][0] << 8 | n2[0][1] : n2[0];
        this.fields[i2] = n2;
      }
    }
    var t2 = e2.prototype;
    return t2.decodeOperands = function(e3, t3, r2, n2) {
      var i2 = this;
      if (Array.isArray(e3))
        return n2.map(function(n3, a2) {
          return i2.decodeOperands(e3[a2], t3, r2, [n3]);
        });
      if (null != e3.decode)
        return e3.decode(t3, r2, n2);
      switch (e3) {
        case "number":
        case "offset":
        case "sid":
          return n2[0];
        case "boolean":
          return !!n2[0];
        default:
          return n2;
      }
    }, t2.encodeOperands = function(e3, t3, r2, n2) {
      var i2 = this;
      return Array.isArray(e3) ? n2.map(function(n3, a2) {
        return i2.encodeOperands(e3[a2], t3, r2, n3)[0];
      }) : null != e3.encode ? e3.encode(t3, n2, r2) : "number" == typeof n2 ? [n2] : "boolean" == typeof n2 ? [+n2] : Array.isArray(n2) ? n2 : [n2];
    }, t2.decode = function(e3, t3) {
      var r2 = e3.pos + t3.length, n2 = {}, i2 = [];
      for (var a2 in Object.defineProperties(n2, { parent: { value: t3 }, _startOffset: { value: e3.pos } }), this.fields) {
        var o2 = this.fields[a2];
        n2[o2[1]] = o2[3];
      }
      for (; e3.pos < r2; ) {
        var s2 = e3.readUInt8();
        if (s2 < 28) {
          12 === s2 && (s2 = s2 << 8 | e3.readUInt8());
          var u2 = this.fields[s2];
          if (!u2)
            throw new Error("Unknown operator " + s2);
          var l2 = this.decodeOperands(u2[2], e3, n2, i2);
          null != l2 && (l2 instanceof sn ? Object.defineProperty(n2, u2[1], l2) : n2[u2[1]] = l2), i2 = [];
        } else
          i2.push(_a.decode(e3, s2));
      }
      return n2;
    }, t2.size = function(e3, t3, r2) {
      void 0 === r2 && (r2 = true);
      var n2 = { parent: t3, val: e3, pointerSize: 0, startOffset: t3.startOffset || 0 }, i2 = 0;
      for (var a2 in this.fields) {
        var o2 = this.fields[a2], s2 = e3[o2[1]];
        if (null != s2 && !qa(s2, o2[3])) {
          for (var u2, l2 = Wa(this.encodeOperands(o2[2], null, n2, s2)); !(u2 = l2()).done; ) {
            var c2 = u2.value;
            i2 += _a.size(c2);
          }
          i2 += (Array.isArray(o2[0]) ? o2[0] : [o2[0]]).length;
        }
      }
      return r2 && (i2 += n2.pointerSize), i2;
    }, t2.encode = function(e3, t3, r2) {
      var n2 = { pointers: [], startOffset: e3.pos, parent: r2, val: t3, pointerSize: 0 };
      n2.pointerOffset = e3.pos + this.size(t3, n2, false);
      for (var i2, a2 = Wa(this.ops); !(i2 = a2()).done; ) {
        var o2 = i2.value, s2 = t3[o2[1]];
        if (null != s2 && !qa(s2, o2[3])) {
          for (var u2, l2 = Wa(this.encodeOperands(o2[2], e3, n2, s2)); !(u2 = l2()).done; ) {
            var c2 = u2.value;
            _a.encode(e3, c2);
          }
          for (var f2, h2 = Wa(Array.isArray(o2[0]) ? o2[0] : [o2[0]]); !(f2 = h2()).done; ) {
            var d2 = f2.value;
            e3.writeUInt8(d2);
          }
        }
      }
      for (var p2 = 0; p2 < n2.pointers.length; ) {
        var y2 = n2.pointers[p2++];
        y2.type.encode(e3, y2.val, y2.parent);
      }
    }, e2;
  }();
  var Xa = function(e2) {
    var t2, r2;
    function n2(t3, r3) {
      return void 0 === r3 && (r3 = {}), null == r3.type && (r3.type = "global"), e2.call(this, null, t3, r3) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2.decode = function(t3, r3, n3) {
      return this.offsetType = { decode: function() {
        return n3[0];
      } }, e2.prototype.decode.call(this, t3, r3, n3);
    }, i2.encode = function(t3, r3, n3) {
      if (!t3)
        return this.offsetType = { size: function() {
          return 0;
        } }, this.size(r3, n3), [new Za(0)];
      var i3 = null;
      return this.offsetType = { encode: function(e3, t4) {
        return i3 = t4;
      } }, e2.prototype.encode.call(this, t3, r3, n3), [new Za(i3)];
    }, n2;
  }(wn.Pointer), Za = function() {
    function e2(e3) {
      this.val = e3, this.forceLarge = true;
    }
    return e2.prototype.valueOf = function() {
      return this.val;
    }, e2;
  }(), Ka = new Ya([[6, "BlueValues", "delta", null], [7, "OtherBlues", "delta", null], [8, "FamilyBlues", "delta", null], [9, "FamilyOtherBlues", "delta", null], [[12, 9], "BlueScale", "number", 0.039625], [[12, 10], "BlueShift", "number", 7], [[12, 11], "BlueFuzz", "number", 1], [10, "StdHW", "number", null], [11, "StdVW", "number", null], [[12, 12], "StemSnapH", "delta", null], [[12, 13], "StemSnapV", "delta", null], [[12, 14], "ForceBold", "boolean", false], [[12, 17], "LanguageGroup", "number", 0], [[12, 18], "ExpansionFactor", "number", 0.06], [[12, 19], "initialRandomSeed", "number", 0], [20, "defaultWidthX", "number", 0], [21, "nominalWidthX", "number", 0], [22, "vsindex", "number", 0], [23, "blend", function() {
    function e2() {
    }
    return e2.decode = function(e3, t2, r2) {
      for (var n2 = r2.pop(); r2.length > n2; )
        r2.pop();
    }, e2;
  }(), null], [19, "Subrs", new Xa(new oi(), { type: "local" }), null]]), Ja = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"], Qa = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "", "endash", "dagger", "daggerdbl", "periodcentered", "", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "", "questiondown", "", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "", "ring", "cedilla", "", "hungarumlaut", "ogonek", "caron", "emdash", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "AE", "", "ordfeminine", "", "", "", "", "Lslash", "Oslash", "OE", "ordmasculine", "", "", "", "", "", "ae", "", "", "", "dotlessi", "", "", "lslash", "oslash", "oe", "germandbls"], $a = [".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron"], eo = new wn.Struct({ reserved: new wn.Reserved(wn.uint16), reqFeatureIndex: wn.uint16, featureCount: wn.uint16, featureIndexes: new wn.Array(wn.uint16, "featureCount") }), to = new wn.Struct({ tag: new wn.String(4), langSys: new wn.Pointer(wn.uint16, eo, { type: "parent" }) }), ro = new wn.Struct({ defaultLangSys: new wn.Pointer(wn.uint16, eo), count: wn.uint16, langSysRecords: new wn.Array(to, "count") }), no = new wn.Struct({ tag: new wn.String(4), script: new wn.Pointer(wn.uint16, ro, { type: "parent" }) }), io = new wn.Array(no, wn.uint16), ao = new wn.Struct({ featureParams: wn.uint16, lookupCount: wn.uint16, lookupListIndexes: new wn.Array(wn.uint16, "lookupCount") }), oo = new wn.Struct({ tag: new wn.String(4), feature: new wn.Pointer(wn.uint16, ao, { type: "parent" }) }), so = new wn.Array(oo, wn.uint16), uo = new wn.Struct({ markAttachmentType: wn.uint8, flags: new wn.Bitfield(wn.uint8, ["rightToLeft", "ignoreBaseGlyphs", "ignoreLigatures", "ignoreMarks", "useMarkFilteringSet"]) });
  function lo(e2) {
    var t2 = new wn.Struct({ lookupType: wn.uint16, flags: uo, subTableCount: wn.uint16, subTables: new wn.Array(new wn.Pointer(wn.uint16, e2), "subTableCount"), markFilteringSet: new wn.Optional(wn.uint16, function(e3) {
      return e3.flags.flags.useMarkFilteringSet;
    }) });
    return new wn.LazyArray(new wn.Pointer(wn.uint16, t2), wn.uint16);
  }
  var co, fo = new wn.Struct({ start: wn.uint16, end: wn.uint16, startCoverageIndex: wn.uint16 }), ho = new wn.VersionedStruct(wn.uint16, { 1: { glyphCount: wn.uint16, glyphs: new wn.Array(wn.uint16, "glyphCount") }, 2: { rangeCount: wn.uint16, rangeRecords: new wn.Array(fo, "rangeCount") } }), po = new wn.Struct({ start: wn.uint16, end: wn.uint16, class: wn.uint16 }), yo = new wn.VersionedStruct(wn.uint16, { 1: { startGlyph: wn.uint16, glyphCount: wn.uint16, classValueArray: new wn.Array(wn.uint16, "glyphCount") }, 2: { classRangeCount: wn.uint16, classRangeRecord: new wn.Array(po, "classRangeCount") } }), go = new wn.Struct({ a: wn.uint16, b: wn.uint16, deltaFormat: wn.uint16 }), vo = new wn.Struct({ sequenceIndex: wn.uint16, lookupListIndex: wn.uint16 }), bo = new wn.Struct({ glyphCount: wn.uint16, lookupCount: wn.uint16, input: new wn.Array(wn.uint16, function(e2) {
    return e2.glyphCount - 1;
  }), lookupRecords: new wn.Array(vo, "lookupCount") }), mo = new wn.Array(new wn.Pointer(wn.uint16, bo), wn.uint16), wo = new wn.Struct({ glyphCount: wn.uint16, lookupCount: wn.uint16, classes: new wn.Array(wn.uint16, function(e2) {
    return e2.glyphCount - 1;
  }), lookupRecords: new wn.Array(vo, "lookupCount") }), So = new wn.Array(new wn.Pointer(wn.uint16, wo), wn.uint16), xo = new wn.VersionedStruct(wn.uint16, { 1: { coverage: new wn.Pointer(wn.uint16, ho), ruleSetCount: wn.uint16, ruleSets: new wn.Array(new wn.Pointer(wn.uint16, mo), "ruleSetCount") }, 2: { coverage: new wn.Pointer(wn.uint16, ho), classDef: new wn.Pointer(wn.uint16, yo), classSetCnt: wn.uint16, classSet: new wn.Array(new wn.Pointer(wn.uint16, So), "classSetCnt") }, 3: { glyphCount: wn.uint16, lookupCount: wn.uint16, coverages: new wn.Array(new wn.Pointer(wn.uint16, ho), "glyphCount"), lookupRecords: new wn.Array(vo, "lookupCount") } }), Ao = new wn.Struct({ backtrackGlyphCount: wn.uint16, backtrack: new wn.Array(wn.uint16, "backtrackGlyphCount"), inputGlyphCount: wn.uint16, input: new wn.Array(wn.uint16, function(e2) {
    return e2.inputGlyphCount - 1;
  }), lookaheadGlyphCount: wn.uint16, lookahead: new wn.Array(wn.uint16, "lookaheadGlyphCount"), lookupCount: wn.uint16, lookupRecords: new wn.Array(vo, "lookupCount") }), ko = new wn.Array(new wn.Pointer(wn.uint16, Ao), wn.uint16), Co = new wn.VersionedStruct(wn.uint16, { 1: { coverage: new wn.Pointer(wn.uint16, ho), chainCount: wn.uint16, chainRuleSets: new wn.Array(new wn.Pointer(wn.uint16, ko), "chainCount") }, 2: { coverage: new wn.Pointer(wn.uint16, ho), backtrackClassDef: new wn.Pointer(wn.uint16, yo), inputClassDef: new wn.Pointer(wn.uint16, yo), lookaheadClassDef: new wn.Pointer(wn.uint16, yo), chainCount: wn.uint16, chainClassSet: new wn.Array(new wn.Pointer(wn.uint16, ko), "chainCount") }, 3: { backtrackGlyphCount: wn.uint16, backtrackCoverage: new wn.Array(new wn.Pointer(wn.uint16, ho), "backtrackGlyphCount"), inputGlyphCount: wn.uint16, inputCoverage: new wn.Array(new wn.Pointer(wn.uint16, ho), "inputGlyphCount"), lookaheadGlyphCount: wn.uint16, lookaheadCoverage: new wn.Array(new wn.Pointer(wn.uint16, ho), "lookaheadGlyphCount"), lookupCount: wn.uint16, lookupRecords: new wn.Array(vo, "lookupCount") } }), Po = new wn.Fixed(16, "BE", 14), Io = new wn.Struct({ startCoord: Po, peakCoord: Po, endCoord: Po }), Oo = new wn.Struct({ axisCount: wn.uint16, regionCount: wn.uint16, variationRegions: new wn.Array(new wn.Array(Io, "axisCount"), "regionCount") }), Eo = new wn.Struct({ shortDeltas: new wn.Array(wn.int16, function(e2) {
    return e2.parent.shortDeltaCount;
  }), regionDeltas: new wn.Array(wn.int8, function(e2) {
    return e2.parent.regionIndexCount - e2.parent.shortDeltaCount;
  }), deltas: function(e2) {
    return e2.shortDeltas.concat(e2.regionDeltas);
  } }), Bo = new wn.Struct({ itemCount: wn.uint16, shortDeltaCount: wn.uint16, regionIndexCount: wn.uint16, regionIndexes: new wn.Array(wn.uint16, "regionIndexCount"), deltaSets: new wn.Array(Eo, "itemCount") }), To = new wn.Struct({ format: wn.uint16, variationRegionList: new wn.Pointer(wn.uint32, Oo), variationDataCount: wn.uint16, itemVariationData: new wn.Array(new wn.Pointer(wn.uint32, Bo), "variationDataCount") }), Lo = new wn.VersionedStruct(wn.uint16, { 1: (co = { axisIndex: wn.uint16 }, co.axisIndex = wn.uint16, co.filterRangeMinValue = Po, co.filterRangeMaxValue = Po, co) }), zo = new wn.Struct({ conditionCount: wn.uint16, conditionTable: new wn.Array(new wn.Pointer(wn.uint32, Lo), "conditionCount") }), Uo = new wn.Struct({ featureIndex: wn.uint16, alternateFeatureTable: new wn.Pointer(wn.uint32, ao, { type: "parent" }) }), Do = new wn.Struct({ version: wn.fixed32, substitutionCount: wn.uint16, substitutions: new wn.Array(Uo, "substitutionCount") }), jo = new wn.Struct({ conditionSet: new wn.Pointer(wn.uint32, zo, { type: "parent" }), featureTableSubstitution: new wn.Pointer(wn.uint32, Do, { type: "parent" }) }), Mo = new wn.Struct({ majorVersion: wn.uint16, minorVersion: wn.uint16, featureVariationRecordCount: wn.uint32, featureVariationRecords: new wn.Array(jo, "featureVariationRecordCount") });
  function Fo(e2, t2) {
    e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, e2.__proto__ = t2;
  }
  var Ro = function() {
    function e2(e3, t3) {
      this.predefinedOps = e3, this.type = t3;
    }
    var t2 = e2.prototype;
    return t2.decode = function(e3, t3, r2) {
      return this.predefinedOps[r2[0]] ? this.predefinedOps[r2[0]] : this.type.decode(e3, t3, r2);
    }, t2.size = function(e3, t3) {
      return this.type.size(e3, t3);
    }, t2.encode = function(e3, t3, r2) {
      var n2 = this.predefinedOps.indexOf(t3);
      return -1 !== n2 ? n2 : this.type.encode(e3, t3, r2);
    }, e2;
  }(), No = function(e2) {
    function t2() {
      return e2.call(this, "UInt8") || this;
    }
    return Fo(t2, e2), t2.prototype.decode = function(e3) {
      return 127 & wn.uint8.decode(e3);
    }, t2;
  }(wn.Number), qo = new wn.Struct({ first: wn.uint16, nLeft: wn.uint8 }), Go = new wn.Struct({ first: wn.uint16, nLeft: wn.uint16 }), Vo = new Ro([Qa, ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "space", "exclamsmall", "Hungarumlautsmall", "", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "", "", "isuperior", "", "", "lsuperior", "msuperior", "nsuperior", "osuperior", "", "", "rsuperior", "ssuperior", "tsuperior", "", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "exclamdownsmall", "centoldstyle", "Lslashsmall", "", "", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "", "Dotaccentsmall", "", "", "Macronsmall", "", "", "figuredash", "hypheninferior", "", "", "Ogoneksmall", "Ringsmall", "Cedillasmall", "", "", "", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "", "", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"]], new Xa(new wn.VersionedStruct(new No(), { 0: { nCodes: wn.uint8, codes: new wn.Array(wn.uint8, "nCodes") }, 1: { nRanges: wn.uint8, ranges: new wn.Array(qo, "nRanges") } }), { lazy: true })), _o = function(e2) {
    function t2() {
      return e2.apply(this, arguments) || this;
    }
    return Fo(t2, e2), t2.prototype.decode = function(e3, t3) {
      for (var r2 = on(this.length, e3, t3), n2 = 0, i2 = []; n2 < r2; ) {
        var a2 = this.type.decode(e3, t3);
        a2.offset = n2, n2 += a2.nLeft + 1, i2.push(a2);
      }
      return i2;
    }, t2;
  }(wn.Array), Wo = new Ro([$a, [".notdef", "space", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "onequarter", "onehalf", "threequarters", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall"], [".notdef", "space", "dollaroldstyle", "dollarsuperior", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "comma", "hyphen", "period", "fraction", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "colon", "semicolon", "commasuperior", "threequartersemdash", "periodsuperior", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "fi", "fl", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "hyphensuperior", "colonmonetary", "onefitted", "rupiah", "centoldstyle", "figuredash", "hypheninferior", "onequarter", "onehalf", "threequarters", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "onesuperior", "twosuperior", "threesuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior"]], new Xa(new wn.VersionedStruct(wn.uint8, { 0: { glyphs: new wn.Array(wn.uint16, function(e2) {
    return e2.parent.CharStrings.length - 1;
  }) }, 1: { ranges: new _o(qo, function(e2) {
    return e2.parent.CharStrings.length - 1;
  }) }, 2: { ranges: new _o(Go, function(e2) {
    return e2.parent.CharStrings.length - 1;
  }) } }), { lazy: true })), Ho = new wn.Struct({ first: wn.uint16, fd: wn.uint8 }), Yo = new wn.Struct({ first: wn.uint32, fd: wn.uint16 }), Xo = new wn.VersionedStruct(wn.uint8, { 0: { fds: new wn.Array(wn.uint8, function(e2) {
    return e2.parent.CharStrings.length;
  }) }, 3: { nRanges: wn.uint16, ranges: new wn.Array(Ho, "nRanges"), sentinel: wn.uint16 }, 4: { nRanges: wn.uint32, ranges: new wn.Array(Yo, "nRanges"), sentinel: wn.uint32 } }), Zo = new Xa(Ka), Ko = function() {
    function e2() {
    }
    var t2 = e2.prototype;
    return t2.decode = function(e3, t3, r2) {
      return t3.length = r2[0], Zo.decode(e3, t3, [r2[1]]);
    }, t2.size = function(e3, t3) {
      return [Ka.size(e3, t3, false), Zo.size(e3, t3)[0]];
    }, t2.encode = function(e3, t3, r2) {
      return [Ka.size(t3, r2, false), Zo.encode(e3, t3, r2)[0]];
    }, e2;
  }(), Jo = new Ya([[18, "Private", new Ko(), null], [[12, 38], "FontName", "sid", null]]), Qo = new Ya([[[12, 30], "ROS", ["sid", "sid", "number"], null], [0, "version", "sid", null], [1, "Notice", "sid", null], [[12, 0], "Copyright", "sid", null], [2, "FullName", "sid", null], [3, "FamilyName", "sid", null], [4, "Weight", "sid", null], [[12, 1], "isFixedPitch", "boolean", false], [[12, 2], "ItalicAngle", "number", 0], [[12, 3], "UnderlinePosition", "number", -100], [[12, 4], "UnderlineThickness", "number", 50], [[12, 5], "PaintType", "number", 0], [[12, 6], "CharstringType", "number", 2], [[12, 7], "FontMatrix", "array", [1e-3, 0, 0, 1e-3, 0, 0]], [13, "UniqueID", "number", null], [5, "FontBBox", "array", [0, 0, 0, 0]], [[12, 8], "StrokeWidth", "number", 0], [14, "XUID", "array", null], [15, "charset", Wo, $a], [16, "Encoding", Vo, Qa], [17, "CharStrings", new Xa(new oi()), null], [18, "Private", new Ko(), null], [[12, 20], "SyntheticBase", "number", null], [[12, 21], "PostScript", "sid", null], [[12, 22], "BaseFontName", "sid", null], [[12, 23], "BaseFontBlend", "delta", null], [[12, 31], "CIDFontVersion", "number", 0], [[12, 32], "CIDFontRevision", "number", 0], [[12, 33], "CIDFontType", "number", 0], [[12, 34], "CIDCount", "number", 8720], [[12, 35], "UIDBase", "number", null], [[12, 37], "FDSelect", new Xa(Xo), null], [[12, 36], "FDArray", new Xa(new oi(Jo)), null], [[12, 38], "FontName", "sid", null]]), $o = new wn.Struct({ length: wn.uint16, itemVariationStore: To }), es = new Ya([[[12, 7], "FontMatrix", "array", [1e-3, 0, 0, 1e-3, 0, 0]], [17, "CharStrings", new Xa(new oi()), null], [[12, 37], "FDSelect", new Xa(Xo), null], [[12, 36], "FDArray", new Xa(new oi(Jo)), null], [24, "vstore", new Xa($o), null], [25, "maxstack", "number", 193]]), ts = new wn.VersionedStruct(wn.fixed16, { 1: { hdrSize: wn.uint8, offSize: wn.uint8, nameIndex: new oi(new wn.String("length")), topDictIndex: new oi(Qo), stringIndex: new oi(new wn.String("length")), globalSubrIndex: new oi() }, 2: { hdrSize: wn.uint8, length: wn.uint16, topDict: es, globalSubrIndex: new oi() } });
  function rs(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  var ns = function() {
    function e2(e3) {
      this.stream = e3, this.decode();
    }
    e2.decode = function(t3) {
      return new e2(t3);
    };
    var t2, r2, i2 = e2.prototype;
    return i2.decode = function() {
      this.stream.pos;
      var e3 = ts.decode(this.stream);
      for (var t3 in e3) {
        var r3 = e3[t3];
        this[t3] = r3;
      }
      if (this.version < 2) {
        if (1 !== this.topDictIndex.length)
          throw new Error("Only a single font is allowed in CFF");
        this.topDict = this.topDictIndex[0];
      }
      return this.isCIDFont = null != this.topDict.ROS, this;
    }, i2.string = function(e3) {
      return this.version >= 2 ? null : e3 < Ja.length ? Ja[e3] : this.stringIndex[e3 - Ja.length];
    }, i2.getCharString = function(e3) {
      return this.stream.pos = this.topDict.CharStrings[e3].offset, this.stream.readBuffer(this.topDict.CharStrings[e3].length);
    }, i2.getGlyphName = function(e3) {
      if (this.version >= 2)
        return null;
      if (this.isCIDFont)
        return null;
      var t3 = this.topDict.charset;
      if (Array.isArray(t3))
        return t3[e3];
      if (0 === e3)
        return ".notdef";
      switch (e3 -= 1, t3.version) {
        case 0:
          return this.string(t3.glyphs[e3]);
        case 1:
        case 2:
          for (var r3 = 0; r3 < t3.ranges.length; r3++) {
            var n2 = t3.ranges[r3];
            if (n2.offset <= e3 && e3 <= n2.offset + n2.nLeft)
              return this.string(n2.first + (e3 - n2.offset));
          }
      }
      return null;
    }, i2.fdForGlyph = function(e3) {
      if (!this.topDict.FDSelect)
        return null;
      switch (this.topDict.FDSelect.version) {
        case 0:
          return this.topDict.FDSelect.fds[e3];
        case 3:
        case 4:
          for (var t3 = this.topDict.FDSelect.ranges, r3 = 0, n2 = t3.length - 1; r3 <= n2; ) {
            var i3 = r3 + n2 >> 1;
            if (e3 < t3[i3].first)
              n2 = i3 - 1;
            else {
              if (!(i3 < n2 && e3 > t3[i3 + 1].first))
                return t3[i3].fd;
              r3 = i3 + 1;
            }
          }
        default:
          throw new Error("Unknown FDSelect version: " + this.topDict.FDSelect.version);
      }
    }, i2.privateDictForGlyph = function(e3) {
      if (this.topDict.FDSelect) {
        var t3 = this.fdForGlyph(e3);
        return this.topDict.FDArray[t3] ? this.topDict.FDArray[t3].Private : null;
      }
      return this.version < 2 ? this.topDict.Private : this.topDict.FDArray[0].Private;
    }, t2 = e2, (r2 = [{ key: "postscriptName", get: function() {
      return this.version < 2 ? this.nameIndex[0] : null;
    } }, { key: "fullName", get: function() {
      return this.string(this.topDict.FullName);
    } }, { key: "familyName", get: function() {
      return this.string(this.topDict.FamilyName);
    } }]) && rs(t2.prototype, r2), e2;
  }(), is = new wn.Struct({ glyphIndex: wn.uint16, vertOriginY: wn.int16 }), as = new wn.Struct({ majorVersion: wn.uint16, minorVersion: wn.uint16, defaultVertOriginY: wn.int16, numVertOriginYMetrics: wn.uint16, metrics: new wn.Array(is, "numVertOriginYMetrics") }), os = new wn.Struct({ height: wn.uint8, width: wn.uint8, horiBearingX: wn.int8, horiBearingY: wn.int8, horiAdvance: wn.uint8, vertBearingX: wn.int8, vertBearingY: wn.int8, vertAdvance: wn.uint8 }), ss = new wn.Struct({ height: wn.uint8, width: wn.uint8, bearingX: wn.int8, bearingY: wn.int8, advance: wn.uint8 }), us = new wn.Struct({ glyph: wn.uint16, xOffset: wn.int8, yOffset: wn.int8 }), ls = function() {
  }, cs = function() {
  }, fs = (new wn.VersionedStruct("version", { 1: { metrics: ss, data: ls }, 2: { metrics: ss, data: cs }, 5: { data: cs }, 6: { metrics: os, data: ls }, 7: { metrics: os, data: cs }, 8: { metrics: ss, pad: new wn.Reserved(wn.uint8), numComponents: wn.uint16, components: new wn.Array(us, "numComponents") }, 9: { metrics: os, pad: new wn.Reserved(wn.uint8), numComponents: wn.uint16, components: new wn.Array(us, "numComponents") }, 17: { metrics: ss, dataLen: wn.uint32, data: new wn.Buffer("dataLen") }, 18: { metrics: os, dataLen: wn.uint32, data: new wn.Buffer("dataLen") }, 19: { dataLen: wn.uint32, data: new wn.Buffer("dataLen") } }), new wn.Struct({ ascender: wn.int8, descender: wn.int8, widthMax: wn.uint8, caretSlopeNumerator: wn.int8, caretSlopeDenominator: wn.int8, caretOffset: wn.int8, minOriginSB: wn.int8, minAdvanceSB: wn.int8, maxBeforeBL: wn.int8, minAfterBL: wn.int8, pad: new wn.Reserved(wn.int8, 2) })), hs = new wn.Struct({ glyphCode: wn.uint16, offset: wn.uint16 }), ds = new wn.VersionedStruct(wn.uint16, { header: { imageFormat: wn.uint16, imageDataOffset: wn.uint32 }, 1: { offsetArray: new wn.Array(wn.uint32, function(e2) {
    return e2.parent.lastGlyphIndex - e2.parent.firstGlyphIndex + 1;
  }) }, 2: { imageSize: wn.uint32, bigMetrics: os }, 3: { offsetArray: new wn.Array(wn.uint16, function(e2) {
    return e2.parent.lastGlyphIndex - e2.parent.firstGlyphIndex + 1;
  }) }, 4: { numGlyphs: wn.uint32, glyphArray: new wn.Array(hs, function(e2) {
    return e2.numGlyphs + 1;
  }) }, 5: { imageSize: wn.uint32, bigMetrics: os, numGlyphs: wn.uint32, glyphCodeArray: new wn.Array(wn.uint16, "numGlyphs") } }), ps = new wn.Struct({ firstGlyphIndex: wn.uint16, lastGlyphIndex: wn.uint16, subtable: new wn.Pointer(wn.uint32, ds) }), ys = new wn.Struct({ indexSubTableArray: new wn.Pointer(wn.uint32, new wn.Array(ps, 1), { type: "parent" }), indexTablesSize: wn.uint32, numberOfIndexSubTables: wn.uint32, colorRef: wn.uint32, hori: fs, vert: fs, startGlyphIndex: wn.uint16, endGlyphIndex: wn.uint16, ppemX: wn.uint8, ppemY: wn.uint8, bitDepth: wn.uint8, flags: new wn.Bitfield(wn.uint8, ["horizontal", "vertical"]) }), gs = new wn.Struct({ version: wn.uint32, numSizes: wn.uint32, sizes: new wn.Array(ys, "numSizes") }), vs = new wn.Struct({ ppem: wn.uint16, resolution: wn.uint16, imageOffsets: new wn.Array(new wn.Pointer(wn.uint32, "void"), function(e2) {
    return e2.parent.parent.maxp.numGlyphs + 1;
  }) }), bs = new wn.Struct({ version: wn.uint16, flags: new wn.Bitfield(wn.uint16, ["renderOutlines"]), numImgTables: wn.uint32, imageTables: new wn.Array(new wn.Pointer(wn.uint32, vs), "numImgTables") }), ms = new wn.Struct({ gid: wn.uint16, paletteIndex: wn.uint16 }), ws = new wn.Struct({ gid: wn.uint16, firstLayerIndex: wn.uint16, numLayers: wn.uint16 }), Ss = new wn.Struct({ version: wn.uint16, numBaseGlyphRecords: wn.uint16, baseGlyphRecord: new wn.Pointer(wn.uint32, new wn.Array(ws, "numBaseGlyphRecords")), layerRecords: new wn.Pointer(wn.uint32, new wn.Array(ms, "numLayerRecords"), { lazy: true }), numLayerRecords: wn.uint16 }), xs = new wn.Struct({ blue: wn.uint8, green: wn.uint8, red: wn.uint8, alpha: wn.uint8 }), As = new wn.VersionedStruct(wn.uint16, { header: { numPaletteEntries: wn.uint16, numPalettes: wn.uint16, numColorRecords: wn.uint16, colorRecords: new wn.Pointer(wn.uint32, new wn.Array(xs, "numColorRecords")), colorRecordIndices: new wn.Array(wn.uint16, "numPalettes") }, 0: {}, 1: { offsetPaletteTypeArray: new wn.Pointer(wn.uint32, new wn.Array(wn.uint32, "numPalettes")), offsetPaletteLabelArray: new wn.Pointer(wn.uint32, new wn.Array(wn.uint16, "numPalettes")), offsetPaletteEntryLabelArray: new wn.Pointer(wn.uint32, new wn.Array(wn.uint16, "numPaletteEntries")) } }), ks = new wn.VersionedStruct(wn.uint16, { 1: { coordinate: wn.int16 }, 2: { coordinate: wn.int16, referenceGlyph: wn.uint16, baseCoordPoint: wn.uint16 }, 3: { coordinate: wn.int16, deviceTable: new wn.Pointer(wn.uint16, go) } }), Cs = new wn.Struct({ defaultIndex: wn.uint16, baseCoordCount: wn.uint16, baseCoords: new wn.Array(new wn.Pointer(wn.uint16, ks), "baseCoordCount") }), Ps = new wn.Struct({ tag: new wn.String(4), minCoord: new wn.Pointer(wn.uint16, ks, { type: "parent" }), maxCoord: new wn.Pointer(wn.uint16, ks, { type: "parent" }) }), Is = new wn.Struct({ minCoord: new wn.Pointer(wn.uint16, ks), maxCoord: new wn.Pointer(wn.uint16, ks), featMinMaxCount: wn.uint16, featMinMaxRecords: new wn.Array(Ps, "featMinMaxCount") }), Os = new wn.Struct({ tag: new wn.String(4), minMax: new wn.Pointer(wn.uint16, Is, { type: "parent" }) }), Es = new wn.Struct({ baseValues: new wn.Pointer(wn.uint16, Cs), defaultMinMax: new wn.Pointer(wn.uint16, Is), baseLangSysCount: wn.uint16, baseLangSysRecords: new wn.Array(Os, "baseLangSysCount") }), Bs = new wn.Struct({ tag: new wn.String(4), script: new wn.Pointer(wn.uint16, Es, { type: "parent" }) }), Ts = new wn.Array(Bs, wn.uint16), Ls = new wn.Array(new wn.String(4), wn.uint16), zs = new wn.Struct({ baseTagList: new wn.Pointer(wn.uint16, Ls), baseScriptList: new wn.Pointer(wn.uint16, Ts) }), Us = new wn.VersionedStruct(wn.uint32, { header: { horizAxis: new wn.Pointer(wn.uint16, zs), vertAxis: new wn.Pointer(wn.uint16, zs) }, 65536: {}, 65537: { itemVariationStore: new wn.Pointer(wn.uint32, To) } }), Ds = new wn.Array(wn.uint16, wn.uint16), js = new wn.Struct({ coverage: new wn.Pointer(wn.uint16, ho), glyphCount: wn.uint16, attachPoints: new wn.Array(new wn.Pointer(wn.uint16, Ds), "glyphCount") }), Ms = new wn.VersionedStruct(wn.uint16, { 1: { coordinate: wn.int16 }, 2: { caretValuePoint: wn.uint16 }, 3: { coordinate: wn.int16, deviceTable: new wn.Pointer(wn.uint16, go) } }), Fs = new wn.Array(new wn.Pointer(wn.uint16, Ms), wn.uint16), Rs = new wn.Struct({ coverage: new wn.Pointer(wn.uint16, ho), ligGlyphCount: wn.uint16, ligGlyphs: new wn.Array(new wn.Pointer(wn.uint16, Fs), "ligGlyphCount") }), Ns = new wn.Struct({ markSetTableFormat: wn.uint16, markSetCount: wn.uint16, coverage: new wn.Array(new wn.Pointer(wn.uint32, ho), "markSetCount") }), qs = new wn.VersionedStruct(wn.uint32, { header: { glyphClassDef: new wn.Pointer(wn.uint16, yo), attachList: new wn.Pointer(wn.uint16, js), ligCaretList: new wn.Pointer(wn.uint16, Rs), markAttachClassDef: new wn.Pointer(wn.uint16, yo) }, 65536: {}, 65538: { markGlyphSetsDef: new wn.Pointer(wn.uint16, Ns) }, 65539: { markGlyphSetsDef: new wn.Pointer(wn.uint16, Ns), itemVariationStore: new wn.Pointer(wn.uint32, To) } }), Gs = new wn.Bitfield(wn.uint16, ["xPlacement", "yPlacement", "xAdvance", "yAdvance", "xPlaDevice", "yPlaDevice", "xAdvDevice", "yAdvDevice"]), Vs = { xPlacement: wn.int16, yPlacement: wn.int16, xAdvance: wn.int16, yAdvance: wn.int16, xPlaDevice: new wn.Pointer(wn.uint16, go, { type: "global", relativeTo: "rel" }), yPlaDevice: new wn.Pointer(wn.uint16, go, { type: "global", relativeTo: "rel" }), xAdvDevice: new wn.Pointer(wn.uint16, go, { type: "global", relativeTo: "rel" }), yAdvDevice: new wn.Pointer(wn.uint16, go, { type: "global", relativeTo: "rel" }) }, _s = function() {
    function e2(e3) {
      void 0 === e3 && (e3 = "valueFormat"), this.key = e3;
    }
    var t2 = e2.prototype;
    return t2.buildStruct = function(e3) {
      for (var t3 = e3; !t3[this.key] && t3.parent; )
        t3 = t3.parent;
      if (t3[this.key]) {
        var r2 = { rel: function() {
          return t3._startOffset;
        } }, n2 = t3[this.key];
        for (var i2 in n2)
          n2[i2] && (r2[i2] = Vs[i2]);
        return new wn.Struct(r2);
      }
    }, t2.size = function(e3, t3) {
      return this.buildStruct(t3).size(e3, t3);
    }, t2.decode = function(e3, t3) {
      var r2 = this.buildStruct(t3).decode(e3, t3);
      return delete r2.rel, r2;
    }, e2;
  }(), Ws = new wn.Struct({ secondGlyph: wn.uint16, value1: new _s("valueFormat1"), value2: new _s("valueFormat2") }), Hs = new wn.Array(Ws, wn.uint16), Ys = new wn.Struct({ value1: new _s("valueFormat1"), value2: new _s("valueFormat2") }), Xs = new wn.VersionedStruct(wn.uint16, { 1: { xCoordinate: wn.int16, yCoordinate: wn.int16 }, 2: { xCoordinate: wn.int16, yCoordinate: wn.int16, anchorPoint: wn.uint16 }, 3: { xCoordinate: wn.int16, yCoordinate: wn.int16, xDeviceTable: new wn.Pointer(wn.uint16, go), yDeviceTable: new wn.Pointer(wn.uint16, go) } }), Zs = new wn.Struct({ entryAnchor: new wn.Pointer(wn.uint16, Xs, { type: "parent" }), exitAnchor: new wn.Pointer(wn.uint16, Xs, { type: "parent" }) }), Ks = new wn.Struct({ class: wn.uint16, markAnchor: new wn.Pointer(wn.uint16, Xs, { type: "parent" }) }), Js = new wn.Array(Ks, wn.uint16), Qs = new wn.Array(new wn.Pointer(wn.uint16, Xs), function(e2) {
    return e2.parent.classCount;
  }), $s = new wn.Array(Qs, wn.uint16), eu = new wn.Array(new wn.Pointer(wn.uint16, Xs), function(e2) {
    return e2.parent.parent.classCount;
  }), tu = new wn.Array(eu, wn.uint16), ru = new wn.Array(new wn.Pointer(wn.uint16, tu), wn.uint16), nu = new wn.VersionedStruct("lookupType", { 1: new wn.VersionedStruct(wn.uint16, { 1: { coverage: new wn.Pointer(wn.uint16, ho), valueFormat: Gs, value: new _s() }, 2: { coverage: new wn.Pointer(wn.uint16, ho), valueFormat: Gs, valueCount: wn.uint16, values: new wn.LazyArray(new _s(), "valueCount") } }), 2: new wn.VersionedStruct(wn.uint16, { 1: { coverage: new wn.Pointer(wn.uint16, ho), valueFormat1: Gs, valueFormat2: Gs, pairSetCount: wn.uint16, pairSets: new wn.LazyArray(new wn.Pointer(wn.uint16, Hs), "pairSetCount") }, 2: { coverage: new wn.Pointer(wn.uint16, ho), valueFormat1: Gs, valueFormat2: Gs, classDef1: new wn.Pointer(wn.uint16, yo), classDef2: new wn.Pointer(wn.uint16, yo), class1Count: wn.uint16, class2Count: wn.uint16, classRecords: new wn.LazyArray(new wn.LazyArray(Ys, "class2Count"), "class1Count") } }), 3: { format: wn.uint16, coverage: new wn.Pointer(wn.uint16, ho), entryExitCount: wn.uint16, entryExitRecords: new wn.Array(Zs, "entryExitCount") }, 4: { format: wn.uint16, markCoverage: new wn.Pointer(wn.uint16, ho), baseCoverage: new wn.Pointer(wn.uint16, ho), classCount: wn.uint16, markArray: new wn.Pointer(wn.uint16, Js), baseArray: new wn.Pointer(wn.uint16, $s) }, 5: { format: wn.uint16, markCoverage: new wn.Pointer(wn.uint16, ho), ligatureCoverage: new wn.Pointer(wn.uint16, ho), classCount: wn.uint16, markArray: new wn.Pointer(wn.uint16, Js), ligatureArray: new wn.Pointer(wn.uint16, ru) }, 6: { format: wn.uint16, mark1Coverage: new wn.Pointer(wn.uint16, ho), mark2Coverage: new wn.Pointer(wn.uint16, ho), classCount: wn.uint16, mark1Array: new wn.Pointer(wn.uint16, Js), mark2Array: new wn.Pointer(wn.uint16, $s) }, 7: xo, 8: Co, 9: { posFormat: wn.uint16, lookupType: wn.uint16, extension: new wn.Pointer(wn.uint32, nu) } });
  nu.versions[9].extension.type = nu;
  var iu = new wn.VersionedStruct(wn.uint32, { header: { scriptList: new wn.Pointer(wn.uint16, io), featureList: new wn.Pointer(wn.uint16, so), lookupList: new wn.Pointer(wn.uint16, new lo(nu)) }, 65536: {}, 65537: { featureVariations: new wn.Pointer(wn.uint32, Mo) } }), au = new wn.Array(wn.uint16, wn.uint16), ou = au, su = new wn.Struct({ glyph: wn.uint16, compCount: wn.uint16, components: new wn.Array(wn.uint16, function(e2) {
    return e2.compCount - 1;
  }) }), uu = new wn.Array(new wn.Pointer(wn.uint16, su), wn.uint16), lu = new wn.VersionedStruct("lookupType", { 1: new wn.VersionedStruct(wn.uint16, { 1: { coverage: new wn.Pointer(wn.uint16, ho), deltaGlyphID: wn.int16 }, 2: { coverage: new wn.Pointer(wn.uint16, ho), glyphCount: wn.uint16, substitute: new wn.LazyArray(wn.uint16, "glyphCount") } }), 2: { substFormat: wn.uint16, coverage: new wn.Pointer(wn.uint16, ho), count: wn.uint16, sequences: new wn.LazyArray(new wn.Pointer(wn.uint16, au), "count") }, 3: { substFormat: wn.uint16, coverage: new wn.Pointer(wn.uint16, ho), count: wn.uint16, alternateSet: new wn.LazyArray(new wn.Pointer(wn.uint16, ou), "count") }, 4: { substFormat: wn.uint16, coverage: new wn.Pointer(wn.uint16, ho), count: wn.uint16, ligatureSets: new wn.LazyArray(new wn.Pointer(wn.uint16, uu), "count") }, 5: xo, 6: Co, 7: { substFormat: wn.uint16, lookupType: wn.uint16, extension: new wn.Pointer(wn.uint32, lu) }, 8: { substFormat: wn.uint16, coverage: new wn.Pointer(wn.uint16, ho), backtrackCoverage: new wn.Array(new wn.Pointer(wn.uint16, ho), "backtrackGlyphCount"), lookaheadGlyphCount: wn.uint16, lookaheadCoverage: new wn.Array(new wn.Pointer(wn.uint16, ho), "lookaheadGlyphCount"), glyphCount: wn.uint16, substitutes: new wn.Array(wn.uint16, "glyphCount") } });
  lu.versions[7].extension.type = lu;
  var cu = new wn.VersionedStruct(wn.uint32, { header: { scriptList: new wn.Pointer(wn.uint16, io), featureList: new wn.Pointer(wn.uint16, so), lookupList: new wn.Pointer(wn.uint16, new lo(lu)) }, 65536: {}, 65537: { featureVariations: new wn.Pointer(wn.uint32, Mo) } }), fu = new wn.Array(wn.uint16, wn.uint16), hu = new wn.Struct({ shrinkageEnableGSUB: new wn.Pointer(wn.uint16, fu), shrinkageDisableGSUB: new wn.Pointer(wn.uint16, fu), shrinkageEnableGPOS: new wn.Pointer(wn.uint16, fu), shrinkageDisableGPOS: new wn.Pointer(wn.uint16, fu), shrinkageJstfMax: new wn.Pointer(wn.uint16, new lo(nu)), extensionEnableGSUB: new wn.Pointer(wn.uint16, fu), extensionDisableGSUB: new wn.Pointer(wn.uint16, fu), extensionEnableGPOS: new wn.Pointer(wn.uint16, fu), extensionDisableGPOS: new wn.Pointer(wn.uint16, fu), extensionJstfMax: new wn.Pointer(wn.uint16, new lo(nu)) }), du = new wn.Array(new wn.Pointer(wn.uint16, hu), wn.uint16), pu = new wn.Struct({ tag: new wn.String(4), jstfLangSys: new wn.Pointer(wn.uint16, du) }), yu = new wn.Struct({ extenderGlyphs: new wn.Pointer(wn.uint16, new wn.Array(wn.uint16, wn.uint16)), defaultLangSys: new wn.Pointer(wn.uint16, du), langSysCount: wn.uint16, langSysRecords: new wn.Array(pu, "langSysCount") }), gu = new wn.Struct({ tag: new wn.String(4), script: new wn.Pointer(wn.uint16, yu, { type: "parent" }) }), vu = new wn.Struct({ version: wn.uint32, scriptCount: wn.uint16, scriptList: new wn.Array(gu, "scriptCount") }), bu = function() {
    function e2(e3) {
      this._size = e3;
    }
    var t2 = e2.prototype;
    return t2.decode = function(e3, t3) {
      switch (this.size(0, t3)) {
        case 1:
          return e3.readUInt8();
        case 2:
          return e3.readUInt16BE();
        case 3:
          return e3.readUInt24BE();
        case 4:
          return e3.readUInt32BE();
      }
    }, t2.size = function(e3, t3) {
      return on(this._size, null, t3);
    }, e2;
  }(), mu = new wn.Struct({ entry: new bu(function(e2) {
    return 1 + ((48 & e2.parent.entryFormat) >> 4);
  }), outerIndex: function(e2) {
    return e2.entry >> 1 + (15 & e2.parent.entryFormat);
  }, innerIndex: function(e2) {
    return e2.entry & (1 << 1 + (15 & e2.parent.entryFormat)) - 1;
  } }), wu = new wn.Struct({ entryFormat: wn.uint16, mapCount: wn.uint16, mapData: new wn.Array(mu, "mapCount") }), Su = new wn.Struct({ majorVersion: wn.uint16, minorVersion: wn.uint16, itemVariationStore: new wn.Pointer(wn.uint32, To), advanceWidthMapping: new wn.Pointer(wn.uint32, wu), LSBMapping: new wn.Pointer(wn.uint32, wu), RSBMapping: new wn.Pointer(wn.uint32, wu) }), xu = new wn.Struct({ format: wn.uint32, length: wn.uint32, offset: wn.uint32 }), Au = new wn.Struct({ reserved: new wn.Reserved(wn.uint16, 2), cbSignature: wn.uint32, signature: new wn.Buffer("cbSignature") }), ku = new wn.Struct({ ulVersion: wn.uint32, usNumSigs: wn.uint16, usFlag: wn.uint16, signatures: new wn.Array(xu, "usNumSigs"), signatureBlocks: new wn.Array(Au, "usNumSigs") }), Cu = new wn.Struct({ rangeMaxPPEM: wn.uint16, rangeGaspBehavior: new wn.Bitfield(wn.uint16, ["grayscale", "gridfit", "symmetricSmoothing", "symmetricGridfit"]) }), Pu = new wn.Struct({ version: wn.uint16, numRanges: wn.uint16, gaspRanges: new wn.Array(Cu, "numRanges") }), Iu = new wn.Struct({ pixelSize: wn.uint8, maximumWidth: wn.uint8, widths: new wn.Array(wn.uint8, function(e2) {
    return e2.parent.parent.maxp.numGlyphs;
  }) }), Ou = new wn.Struct({ version: wn.uint16, numRecords: wn.int16, sizeDeviceRecord: wn.int32, records: new wn.Array(Iu, "numRecords") }), Eu = new wn.Struct({ left: wn.uint16, right: wn.uint16, value: wn.int16 }), Bu = new wn.Struct({ firstGlyph: wn.uint16, nGlyphs: wn.uint16, offsets: new wn.Array(wn.uint16, "nGlyphs"), max: function(e2) {
    return e2.offsets.length && Math.max.apply(Math, e2.offsets);
  } }), Tu = new wn.Struct({ off: function(e2) {
    return e2._startOffset - e2.parent.parent._startOffset;
  }, len: function(e2) {
    return ((e2.parent.leftTable.max - e2.off) / e2.parent.rowWidth + 1) * (e2.parent.rowWidth / 2);
  }, values: new wn.LazyArray(wn.int16, "len") }), Lu = new wn.VersionedStruct("format", { 0: { nPairs: wn.uint16, searchRange: wn.uint16, entrySelector: wn.uint16, rangeShift: wn.uint16, pairs: new wn.Array(Eu, "nPairs") }, 2: { rowWidth: wn.uint16, leftTable: new wn.Pointer(wn.uint16, Bu, { type: "parent" }), rightTable: new wn.Pointer(wn.uint16, Bu, { type: "parent" }), array: new wn.Pointer(wn.uint16, Tu, { type: "parent" }) }, 3: { glyphCount: wn.uint16, kernValueCount: wn.uint8, leftClassCount: wn.uint8, rightClassCount: wn.uint8, flags: wn.uint8, kernValue: new wn.Array(wn.int16, "kernValueCount"), leftClass: new wn.Array(wn.uint8, "glyphCount"), rightClass: new wn.Array(wn.uint8, "glyphCount"), kernIndex: new wn.Array(wn.uint8, function(e2) {
    return e2.leftClassCount * e2.rightClassCount;
  }) } }), zu = new wn.VersionedStruct("version", { 0: { subVersion: wn.uint16, length: wn.uint16, format: wn.uint8, coverage: new wn.Bitfield(wn.uint8, ["horizontal", "minimum", "crossStream", "override"]), subtable: Lu, padding: new wn.Reserved(wn.uint8, function(e2) {
    return e2.length - e2._currentOffset;
  }) }, 1: { length: wn.uint32, coverage: new wn.Bitfield(wn.uint8, [null, null, null, null, null, "variation", "crossStream", "vertical"]), format: wn.uint8, tupleIndex: wn.uint16, subtable: Lu, padding: new wn.Reserved(wn.uint8, function(e2) {
    return e2.length - e2._currentOffset;
  }) } }), Uu = new wn.VersionedStruct(wn.uint16, { 0: { nTables: wn.uint16, tables: new wn.Array(zu, "nTables") }, 1: { reserved: new wn.Reserved(wn.uint16), nTables: wn.uint32, tables: new wn.Array(zu, "nTables") } }), Du = new wn.Struct({ version: wn.uint16, numGlyphs: wn.uint16, yPels: new wn.Array(wn.uint8, "numGlyphs") }), ju = new wn.Struct({ version: wn.uint16, fontNumber: wn.uint32, pitch: wn.uint16, xHeight: wn.uint16, style: wn.uint16, typeFamily: wn.uint16, capHeight: wn.uint16, symbolSet: wn.uint16, typeface: new wn.String(16), characterComplement: new wn.String(8), fileName: new wn.String(6), strokeWeight: new wn.String(1), widthType: new wn.String(1), serifStyle: wn.uint8, reserved: new wn.Reserved(wn.uint8) }), Mu = new wn.Struct({ bCharSet: wn.uint8, xRatio: wn.uint8, yStartRatio: wn.uint8, yEndRatio: wn.uint8 }), Fu = new wn.Struct({ yPelHeight: wn.uint16, yMax: wn.int16, yMin: wn.int16 }), Ru = new wn.Struct({ recs: wn.uint16, startsz: wn.uint8, endsz: wn.uint8, entries: new wn.Array(Fu, "recs") }), Nu = new wn.Struct({ version: wn.uint16, numRecs: wn.uint16, numRatios: wn.uint16, ratioRanges: new wn.Array(Mu, "numRatios"), offsets: new wn.Array(wn.uint16, "numRatios"), groups: new wn.Array(Ru, "numRecs") }), qu = new wn.Struct({ version: wn.uint16, ascent: wn.int16, descent: wn.int16, lineGap: wn.int16, advanceHeightMax: wn.int16, minTopSideBearing: wn.int16, minBottomSideBearing: wn.int16, yMaxExtent: wn.int16, caretSlopeRise: wn.int16, caretSlopeRun: wn.int16, caretOffset: wn.int16, reserved: new wn.Reserved(wn.int16, 4), metricDataFormat: wn.int16, numberOfMetrics: wn.uint16 }), Gu = new wn.Struct({ advance: wn.uint16, bearing: wn.int16 }), Vu = new wn.Struct({ metrics: new wn.LazyArray(Gu, function(e2) {
    return e2.parent.vhea.numberOfMetrics;
  }), bearings: new wn.LazyArray(wn.int16, function(e2) {
    return e2.parent.maxp.numGlyphs - e2.parent.vhea.numberOfMetrics;
  }) }), _u = new wn.Fixed(16, "BE", 14), Wu = new wn.Struct({ fromCoord: _u, toCoord: _u }), Hu = new wn.Struct({ pairCount: wn.uint16, correspondence: new wn.Array(Wu, "pairCount") }), Yu = new wn.Struct({ version: wn.fixed32, axisCount: wn.uint32, segment: new wn.Array(Hu, "axisCount") });
  var Xu = function() {
    function e2(e3, t3, r2) {
      this.type = e3, this.stream = t3, this.parent = r2, this.base = this.stream.pos, this._items = [];
    }
    var t2 = e2.prototype;
    return t2.getItem = function(e3) {
      if (null == this._items[e3]) {
        var t3 = this.stream.pos;
        this.stream.pos = this.base + this.type.size(null, this.parent) * e3, this._items[e3] = this.type.decode(this.stream, this.parent), this.stream.pos = t3;
      }
      return this._items[e3];
    }, t2.inspect = function() {
      return "[UnboundedArray " + this.type.constructor.name + "]";
    }, e2;
  }(), Zu = function(e2) {
    var t2, r2;
    function n2(t3) {
      return e2.call(this, t3, 0) || this;
    }
    return r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.prototype.decode = function(e3, t3) {
      return new Xu(this.type, e3, t3);
    }, n2;
  }(wn.Array), Ku = function(e2) {
    void 0 === e2 && (e2 = wn.uint16), e2 = new (function() {
      function e3(e4) {
        this.type = e4;
      }
      var t3 = e3.prototype;
      return t3.decode = function(e4, t4) {
        return t4 = t4.parent.parent, this.type.decode(e4, t4);
      }, t3.size = function(e4, t4) {
        return t4 = t4.parent.parent, this.type.size(e4, t4);
      }, t3.encode = function(e4, t4, r3) {
        return r3 = r3.parent.parent, this.type.encode(e4, t4, r3);
      }, e3;
    }())(e2);
    var t2 = new wn.Struct({ unitSize: wn.uint16, nUnits: wn.uint16, searchRange: wn.uint16, entrySelector: wn.uint16, rangeShift: wn.uint16 }), r2 = new wn.Struct({ lastGlyph: wn.uint16, firstGlyph: wn.uint16, value: e2 }), n2 = new wn.Struct({ lastGlyph: wn.uint16, firstGlyph: wn.uint16, values: new wn.Pointer(wn.uint16, new wn.Array(e2, function(e3) {
      return e3.lastGlyph - e3.firstGlyph + 1;
    }), { type: "parent" }) }), i2 = new wn.Struct({ glyph: wn.uint16, value: e2 });
    return new wn.VersionedStruct(wn.uint16, { 0: { values: new Zu(e2) }, 2: { binarySearchHeader: t2, segments: new wn.Array(r2, function(e3) {
      return e3.binarySearchHeader.nUnits;
    }) }, 4: { binarySearchHeader: t2, segments: new wn.Array(n2, function(e3) {
      return e3.binarySearchHeader.nUnits;
    }) }, 6: { binarySearchHeader: t2, segments: new wn.Array(i2, function(e3) {
      return e3.binarySearchHeader.nUnits;
    }) }, 8: { firstGlyph: wn.uint16, count: wn.uint16, values: new wn.Array(e2, "count") } });
  };
  function Ju(e2, t2) {
    void 0 === e2 && (e2 = {}), void 0 === t2 && (t2 = wn.uint16);
    var r2 = Object.assign({ newState: wn.uint16, flags: wn.uint16 }, e2), n2 = new wn.Struct(r2), i2 = new Zu(new wn.Array(wn.uint16, function(e3) {
      return e3.nClasses;
    }));
    return new wn.Struct({ nClasses: wn.uint32, classTable: new wn.Pointer(wn.uint32, new Ku(t2)), stateArray: new wn.Pointer(wn.uint32, i2), entryTable: new wn.Pointer(wn.uint32, new Zu(n2)) });
  }
  var Qu = new wn.VersionedStruct("format", { 0: { deltas: new wn.Array(wn.int16, 32) }, 1: { deltas: new wn.Array(wn.int16, 32), mappingData: new Ku(wn.uint16) }, 2: { standardGlyph: wn.uint16, controlPoints: new wn.Array(wn.uint16, 32) }, 3: { standardGlyph: wn.uint16, controlPoints: new wn.Array(wn.uint16, 32), mappingData: new Ku(wn.uint16) } }), $u = new wn.Struct({ version: wn.fixed32, format: wn.uint16, defaultBaseline: wn.uint16, subtable: Qu }), el = new wn.Struct({ setting: wn.uint16, nameIndex: wn.int16, name: function(e2) {
    return e2.parent.parent.parent.name.records.fontFeatures[e2.nameIndex];
  } }), tl = new wn.Struct({ feature: wn.uint16, nSettings: wn.uint16, settingTable: new wn.Pointer(wn.uint32, new wn.Array(el, "nSettings"), { type: "parent" }), featureFlags: new wn.Bitfield(wn.uint8, [null, null, null, null, null, null, "hasDefault", "exclusive"]), defaultSetting: wn.uint8, nameIndex: wn.int16, name: function(e2) {
    return e2.parent.parent.name.records.fontFeatures[e2.nameIndex];
  } }), rl = new wn.Struct({ version: wn.fixed32, featureNameCount: wn.uint16, reserved1: new wn.Reserved(wn.uint16), reserved2: new wn.Reserved(wn.uint32), featureNames: new wn.Array(tl, "featureNameCount") }), nl = new wn.Struct({ axisTag: new wn.String(4), minValue: wn.fixed32, defaultValue: wn.fixed32, maxValue: wn.fixed32, flags: wn.uint16, nameID: wn.uint16, name: function(e2) {
    return e2.parent.parent.name.records.fontFeatures[e2.nameID];
  } }), il = new wn.Struct({ nameID: wn.uint16, name: function(e2) {
    return e2.parent.parent.name.records.fontFeatures[e2.nameID];
  }, flags: wn.uint16, coord: new wn.Array(wn.fixed32, function(e2) {
    return e2.parent.axisCount;
  }), postscriptNameID: new wn.Optional(wn.uint16, function(e2) {
    return e2.parent.instanceSize - e2._currentOffset > 0;
  }) }), al = new wn.Struct({ version: wn.fixed32, offsetToData: wn.uint16, countSizePairs: wn.uint16, axisCount: wn.uint16, axisSize: wn.uint16, instanceCount: wn.uint16, instanceSize: wn.uint16, axis: new wn.Array(nl, "axisCount"), instance: new wn.Array(il, "instanceCount") }), ol = new wn.Fixed(16, "BE", 14), sl = function() {
    function e2() {
    }
    return e2.decode = function(e3, t2) {
      return t2.flags ? e3.readUInt32BE() : 2 * e3.readUInt16BE();
    }, e2;
  }(), ul = new wn.Struct({ version: wn.uint16, reserved: new wn.Reserved(wn.uint16), axisCount: wn.uint16, globalCoordCount: wn.uint16, globalCoords: new wn.Pointer(wn.uint32, new wn.Array(new wn.Array(ol, "axisCount"), "globalCoordCount")), glyphCount: wn.uint16, flags: wn.uint16, offsetToData: wn.uint32, offsets: new wn.Array(new wn.Pointer(sl, "void", { relativeTo: "offsetToData", allowNull: false }), function(e2) {
    return e2.glyphCount + 1;
  }) }), ll = new wn.Struct({ length: wn.uint16, coverage: wn.uint16, subFeatureFlags: wn.uint32, stateTable: new function(e2, t2) {
    void 0 === e2 && (e2 = {}), void 0 === t2 && (t2 = wn.uint16);
    var r2 = new wn.Struct({ version: function() {
      return 8;
    }, firstGlyph: wn.uint16, values: new wn.Array(wn.uint8, wn.uint16) }), n2 = Object.assign({ newStateOffset: wn.uint16, newState: function(e3) {
      return (e3.newStateOffset - (e3.parent.stateArray.base - e3.parent._startOffset)) / e3.parent.nClasses;
    }, flags: wn.uint16 }, e2), i2 = new wn.Struct(n2), a2 = new Zu(new wn.Array(wn.uint8, function(e3) {
      return e3.nClasses;
    }));
    return new wn.Struct({ nClasses: wn.uint16, classTable: new wn.Pointer(wn.uint16, r2), stateArray: new wn.Pointer(wn.uint16, a2), entryTable: new wn.Pointer(wn.uint16, new Zu(i2)) });
  }() }), cl = new wn.Struct({ justClass: wn.uint32, beforeGrowLimit: wn.fixed32, beforeShrinkLimit: wn.fixed32, afterGrowLimit: wn.fixed32, afterShrinkLimit: wn.fixed32, growFlags: wn.uint16, shrinkFlags: wn.uint16 }), fl = new wn.Array(cl, wn.uint32), hl = new wn.VersionedStruct("actionType", { 0: { lowerLimit: wn.fixed32, upperLimit: wn.fixed32, order: wn.uint16, glyphs: new wn.Array(wn.uint16, wn.uint16) }, 1: { addGlyph: wn.uint16 }, 2: { substThreshold: wn.fixed32, addGlyph: wn.uint16, substGlyph: wn.uint16 }, 3: {}, 4: { variationAxis: wn.uint32, minimumLimit: wn.fixed32, noStretchValue: wn.fixed32, maximumLimit: wn.fixed32 }, 5: { flags: wn.uint16, glyph: wn.uint16 } }), dl = new wn.Struct({ actionClass: wn.uint16, actionType: wn.uint16, actionLength: wn.uint32, actionData: hl, padding: new wn.Reserved(wn.uint8, function(e2) {
    return e2.actionLength - e2._currentOffset;
  }) }), pl = new wn.Array(dl, wn.uint32), yl = new wn.Struct({ lookupTable: new Ku(new wn.Pointer(wn.uint16, pl)) }), gl = new wn.Struct({ classTable: new wn.Pointer(wn.uint16, ll, { type: "parent" }), wdcOffset: wn.uint16, postCompensationTable: new wn.Pointer(wn.uint16, yl, { type: "parent" }), widthDeltaClusters: new Ku(new wn.Pointer(wn.uint16, fl, { type: "parent", relativeTo: "wdcOffset" })) }), vl = new wn.Struct({ version: wn.uint32, format: wn.uint16, horizontal: new wn.Pointer(wn.uint16, gl), vertical: new wn.Pointer(wn.uint16, gl) }), bl = { action: wn.uint16 }, ml = { markIndex: wn.uint16, currentIndex: wn.uint16 }, wl = { currentInsertIndex: wn.uint16, markedInsertIndex: wn.uint16 }, Sl = new wn.Struct({ items: new Zu(new wn.Pointer(wn.uint32, new Ku())) }), xl = new wn.VersionedStruct("type", { 0: { stateTable: new Ju() }, 1: { stateTable: new Ju(ml), substitutionTable: new wn.Pointer(wn.uint32, Sl) }, 2: { stateTable: new Ju(bl), ligatureActions: new wn.Pointer(wn.uint32, new Zu(wn.uint32)), components: new wn.Pointer(wn.uint32, new Zu(wn.uint16)), ligatureList: new wn.Pointer(wn.uint32, new Zu(wn.uint16)) }, 4: { lookupTable: new Ku() }, 5: { stateTable: new Ju(wl), insertionActions: new wn.Pointer(wn.uint32, new Zu(wn.uint16)) } }), Al = new wn.Struct({ length: wn.uint32, coverage: wn.uint24, type: wn.uint8, subFeatureFlags: wn.uint32, table: xl, padding: new wn.Reserved(wn.uint8, function(e2) {
    return e2.length - e2._currentOffset;
  }) }), kl = new wn.Struct({ featureType: wn.uint16, featureSetting: wn.uint16, enableFlags: wn.uint32, disableFlags: wn.uint32 }), Cl = new wn.Struct({ defaultFlags: wn.uint32, chainLength: wn.uint32, nFeatureEntries: wn.uint32, nSubtables: wn.uint32, features: new wn.Array(kl, "nFeatureEntries"), subtables: new wn.Array(Al, "nSubtables") }), Pl = new wn.Struct({ version: wn.uint16, unused: new wn.Reserved(wn.uint16), nChains: wn.uint32, chains: new wn.Array(Cl, "nChains") }), Il = new wn.Struct({ left: wn.int16, top: wn.int16, right: wn.int16, bottom: wn.int16 }), Ol = new wn.Struct({ version: wn.fixed32, format: wn.uint16, lookupTable: new Ku(Il) }), El = {};
  function Bl(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Tl(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Tl(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Tl(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  El.cmap = zn, El.head = Un, El.hhea = Dn, El.hmtx = Mn, El.maxp = Fn, El.name = Yn, El["OS/2"] = Zn, El.post = Jn, El.fpgm = $n, El.loca = ei, El.prep = ti, El["cvt "] = Qn, El.glyf = ri, El["CFF "] = ns, El.CFF2 = ns, El.VORG = as, El.EBLC = gs, El.CBLC = El.EBLC, El.sbix = bs, El.COLR = Ss, El.CPAL = As, El.BASE = Us, El.GDEF = qs, El.GPOS = iu, El.GSUB = cu, El.JSTF = vu, El.HVAR = Su, El.DSIG = ku, El.gasp = Pu, El.hdmx = Ou, El.kern = Uu, El.LTSH = Du, El.PCLT = ju, El.VDMX = Nu, El.vhea = qu, El.vmtx = Vu, El.avar = Yu, El.bsln = $u, El.feat = rl, El.fvar = al, El.gvar = ul, El.just = vl, El.morx = Pl, El.opbd = Ol;
  var Ll, zl = new wn.Struct({ tag: new wn.String(4), checkSum: wn.uint32, offset: new wn.Pointer(wn.uint32, "void", { type: "global" }), length: wn.uint32 }), Ul = new wn.Struct({ tag: new wn.String(4), numTables: wn.uint16, searchRange: wn.uint16, entrySelector: wn.uint16, rangeShift: wn.uint16, tables: new wn.Array(zl, "numTables") });
  function Dl(e2, t2) {
    for (var r2 = 0, n2 = e2.length - 1; r2 <= n2; ) {
      var i2 = r2 + n2 >> 1, a2 = t2(e2[i2]);
      if (a2 < 0)
        n2 = i2 - 1;
      else {
        if (!(a2 > 0))
          return i2;
        r2 = i2 + 1;
      }
    }
    return -1;
  }
  function jl(e2, t2) {
    for (var r2 = []; e2 < t2; )
      r2.push(e2++);
    return r2;
  }
  function Ml(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Fl(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Fl(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Fl(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  function Rl(e2, t2, r2, n2, i2) {
    var a2 = {};
    return Object.keys(n2).forEach(function(e3) {
      a2[e3] = n2[e3];
    }), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = r2.slice().reverse().reduce(function(r3, n3) {
      return n3(e2, t2, r3) || r3;
    }, a2), i2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(i2) : void 0, a2.initializer = void 0), void 0 === a2.initializer && (Object.defineProperty(e2, t2, a2), a2 = null), a2;
  }
  Ul.process = function() {
    for (var e2, t2 = {}, r2 = Bl(this.tables); !(e2 = r2()).done; ) {
      var n2 = e2.value;
      t2[n2.tag] = n2;
    }
    this.tables = t2;
  }, Ul.preEncode = function(e2) {
    var t2 = [];
    for (var r2 in this.tables) {
      var n2 = this.tables[r2];
      n2 && t2.push({ tag: r2, checkSum: 0, offset: new wn.VoidPointer(El[r2], n2), length: El[r2].size(n2) });
    }
    this.tag = "true", this.numTables = t2.length, this.tables = t2;
    var i2 = Math.floor(Math.log(this.numTables) / Math.LN2), a2 = Math.pow(2, i2);
    this.searchRange = 16 * a2, this.entrySelector = Math.log(a2) / Math.LN2, this.rangeShift = 16 * this.numTables - this.searchRange;
  };
  var Nl = (Rl((Ll = function() {
    function e2(e3) {
      if (this.encoding = null, this.cmap = this.findSubtable(e3, [[3, 10], [0, 6], [0, 4], [3, 1], [0, 3], [0, 2], [0, 1], [0, 0]]), !this.cmap && en)
        for (var t3, r2 = Ml(e3.tables); !(t3 = r2()).done; ) {
          var n2 = t3.value, i2 = Rn(n2.platformID, n2.encodingID, n2.table.language - 1);
          en.encodingExists(i2) && (this.cmap = n2.table, this.encoding = i2);
        }
      if (!this.cmap)
        throw new Error("Could not find a supported cmap table");
      this.uvs = this.findSubtable(e3, [[0, 5]]), this.uvs && 14 !== this.uvs.version && (this.uvs = null);
    }
    var t2 = e2.prototype;
    return t2.findSubtable = function(e3, t3) {
      for (var r2, n2 = Ml(t3); !(r2 = n2()).done; )
        for (var i2, a2 = r2.value, o2 = a2[0], s2 = a2[1], u2 = Ml(e3.tables); !(i2 = u2()).done; ) {
          var l2 = i2.value;
          if (l2.platformID === o2 && l2.encodingID === s2)
            return l2.table;
        }
      return null;
    }, t2.lookup = function(e3, t3) {
      if (this.encoding) {
        var r2 = en.encode(String.fromCodePoint(e3), this.encoding);
        e3 = 0;
        for (var n2 = 0; n2 < r2.length; n2++)
          e3 = e3 << 8 | r2[n2];
      } else if (t3) {
        var i2 = this.getVariationSelector(e3, t3);
        if (i2)
          return i2;
      }
      var a2 = this.cmap;
      switch (a2.version) {
        case 0:
          return a2.codeMap.get(e3) || 0;
        case 4:
          for (var o2 = 0, s2 = a2.segCount - 1; o2 <= s2; ) {
            var u2 = o2 + s2 >> 1;
            if (e3 < a2.startCode.get(u2))
              s2 = u2 - 1;
            else {
              if (!(e3 > a2.endCode.get(u2))) {
                var l2 = a2.idRangeOffset.get(u2), c2 = void 0;
                if (0 === l2)
                  c2 = e3 + a2.idDelta.get(u2);
                else {
                  var f2 = l2 / 2 + (e3 - a2.startCode.get(u2)) - (a2.segCount - u2);
                  0 !== (c2 = a2.glyphIndexArray.get(f2) || 0) && (c2 += a2.idDelta.get(u2));
                }
                return 65535 & c2;
              }
              o2 = u2 + 1;
            }
          }
          return 0;
        case 8:
          throw new Error("TODO: cmap format 8");
        case 6:
        case 10:
          return a2.glyphIndices.get(e3 - a2.firstCode) || 0;
        case 12:
        case 13:
          for (var h2 = 0, d2 = a2.nGroups - 1; h2 <= d2; ) {
            var p2 = h2 + d2 >> 1, y2 = a2.groups.get(p2);
            if (e3 < y2.startCharCode)
              d2 = p2 - 1;
            else {
              if (!(e3 > y2.endCharCode))
                return 12 === a2.version ? y2.glyphID + (e3 - y2.startCharCode) : y2.glyphID;
              h2 = p2 + 1;
            }
          }
          return 0;
        case 14:
          throw new Error("TODO: cmap format 14");
        default:
          throw new Error("Unknown cmap format " + a2.version);
      }
    }, t2.getVariationSelector = function(e3, t3) {
      if (!this.uvs)
        return 0;
      var r2 = this.uvs.varSelectors.toArray(), n2 = Dl(r2, function(e4) {
        return t3 - e4.varSelector;
      }), i2 = r2[n2];
      return -1 !== n2 && i2.defaultUVS && (n2 = Dl(i2.defaultUVS, function(t4) {
        return e3 < t4.startUnicodeValue ? -1 : e3 > t4.startUnicodeValue + t4.additionalCount ? 1 : 0;
      })), -1 !== n2 && i2.nonDefaultUVS && -1 !== (n2 = Dl(i2.nonDefaultUVS, function(t4) {
        return e3 - t4.unicodeValue;
      })) ? i2.nonDefaultUVS[n2].glyphID : 0;
    }, t2.getCharacterSet = function() {
      var e3 = this.cmap;
      switch (e3.version) {
        case 0:
          return jl(0, e3.codeMap.length);
        case 4:
          for (var t3 = [], r2 = e3.endCode.toArray(), n2 = 0; n2 < r2.length; n2++) {
            var i2 = r2[n2] + 1, a2 = e3.startCode.get(n2);
            t3.push.apply(t3, jl(a2, i2));
          }
          return t3;
        case 8:
          throw new Error("TODO: cmap format 8");
        case 6:
        case 10:
          return jl(e3.firstCode, e3.firstCode + e3.glyphIndices.length);
        case 12:
        case 13:
          for (var o2, s2 = [], u2 = Ml(e3.groups.toArray()); !(o2 = u2()).done; ) {
            var l2 = o2.value;
            s2.push.apply(s2, jl(l2.startCharCode, l2.endCharCode + 1));
          }
          return s2;
        case 14:
          throw new Error("TODO: cmap format 14");
        default:
          throw new Error("Unknown cmap format " + e3.version);
      }
    }, t2.codePointsForGlyph = function(e3) {
      var t3 = this.cmap;
      switch (t3.version) {
        case 0:
          for (var r2 = [], n2 = 0; n2 < 256; n2++)
            t3.codeMap.get(n2) === e3 && r2.push(n2);
          return r2;
        case 4:
          for (var i2 = [], a2 = 0; a2 < t3.segCount; a2++)
            for (var o2 = t3.endCode.get(a2), s2 = t3.startCode.get(a2), u2 = t3.idRangeOffset.get(a2), l2 = t3.idDelta.get(a2), c2 = s2; c2 <= o2; c2++) {
              var f2 = 0;
              if (0 === u2)
                f2 = c2 + l2;
              else {
                var h2 = u2 / 2 + (c2 - s2) - (t3.segCount - a2);
                0 !== (f2 = t3.glyphIndexArray.get(h2) || 0) && (f2 += l2);
              }
              f2 === e3 && i2.push(c2);
            }
          return i2;
        case 12:
          for (var d2, p2 = [], y2 = Ml(t3.groups.toArray()); !(d2 = y2()).done; ) {
            var g2 = d2.value;
            e3 >= g2.glyphID && e3 <= g2.glyphID + (g2.endCharCode - g2.startCharCode) && p2.push(g2.startCharCode + (e3 - g2.glyphID));
          }
          return p2;
        case 13:
          for (var v2, b2 = [], m2 = Ml(t3.groups.toArray()); !(v2 = m2()).done; ) {
            var w2 = v2.value;
            e3 === w2.glyphID && b2.push.apply(b2, jl(w2.startCharCode, w2.endCharCode + 1));
          }
          return b2;
        default:
          throw new Error("Unknown cmap format " + t3.version);
      }
    }, e2;
  }()).prototype, "getCharacterSet", [An], Object.getOwnPropertyDescriptor(Ll.prototype, "getCharacterSet"), Ll.prototype), Rl(Ll.prototype, "codePointsForGlyph", [An], Object.getOwnPropertyDescriptor(Ll.prototype, "codePointsForGlyph"), Ll.prototype), Ll);
  function ql(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Gl(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Gl(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Gl(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Vl = function() {
    function e2(e3) {
      this.kern = e3.kern;
    }
    var t2 = e2.prototype;
    return t2.process = function(e3, t3) {
      for (var r2 = 0; r2 < e3.length - 1; r2++) {
        var n2 = e3[r2].id, i2 = e3[r2 + 1].id;
        t3[r2].xAdvance += this.getKerning(n2, i2);
      }
    }, t2.getKerning = function(e3, t3) {
      for (var r2, n2 = 0, i2 = ql(this.kern.tables); !(r2 = i2()).done; ) {
        var a2 = r2.value;
        if (!a2.coverage.crossStream) {
          switch (a2.version) {
            case 0:
              if (!a2.coverage.horizontal)
                continue;
              break;
            case 1:
              if (a2.coverage.vertical || a2.coverage.variation)
                continue;
              break;
            default:
              throw new Error("Unsupported kerning table version " + a2.version);
          }
          var o2 = 0, s2 = a2.subtable;
          switch (a2.format) {
            case 0:
              var u2 = Dl(s2.pairs, function(r3) {
                return e3 - r3.left || t3 - r3.right;
              });
              u2 >= 0 && (o2 = s2.pairs[u2].value);
              break;
            case 2:
              var l2 = 0, c2 = 0;
              l2 = e3 >= s2.leftTable.firstGlyph && e3 < s2.leftTable.firstGlyph + s2.leftTable.nGlyphs ? s2.leftTable.offsets[e3 - s2.leftTable.firstGlyph] : s2.array.off, t3 >= s2.rightTable.firstGlyph && t3 < s2.rightTable.firstGlyph + s2.rightTable.nGlyphs && (c2 = s2.rightTable.offsets[t3 - s2.rightTable.firstGlyph]);
              var f2 = (l2 + c2 - s2.array.off) / 2;
              o2 = s2.array.values.get(f2);
              break;
            case 3:
              if (e3 >= s2.glyphCount || t3 >= s2.glyphCount)
                return 0;
              o2 = s2.kernValue[s2.kernIndex[s2.leftClass[e3] * s2.rightClassCount + s2.rightClass[t3]]];
              break;
            default:
              throw new Error("Unsupported kerning sub-table format " + a2.format);
          }
          a2.coverage.override ? n2 = o2 : n2 += o2;
        }
      }
      return n2;
    }, e2;
  }();
  function _l() {
    this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
  }
  function Wl(e2, t2) {
    this.source = e2, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t2, this.destLen = 0, this.ltree = new _l(), this.dtree = new _l();
  }
  var Hl = new _l(), Yl = new _l(), Xl = new Uint8Array(30), Zl = new Uint16Array(30), Kl = new Uint8Array(30), Jl = new Uint16Array(30), Ql = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), $l = new _l(), ec = new Uint8Array(320);
  function tc(e2, t2, r2, n2) {
    var i2, a2;
    for (i2 = 0; i2 < r2; ++i2)
      e2[i2] = 0;
    for (i2 = 0; i2 < 30 - r2; ++i2)
      e2[i2 + r2] = i2 / r2 | 0;
    for (a2 = n2, i2 = 0; i2 < 30; ++i2)
      t2[i2] = a2, a2 += 1 << e2[i2];
  }
  var rc, nc = new Uint16Array(16);
  function ic(e2, t2, r2, n2) {
    var i2, a2;
    for (i2 = 0; i2 < 16; ++i2)
      e2.table[i2] = 0;
    for (i2 = 0; i2 < n2; ++i2)
      e2.table[t2[r2 + i2]]++;
    for (e2.table[0] = 0, a2 = 0, i2 = 0; i2 < 16; ++i2)
      nc[i2] = a2, a2 += e2.table[i2];
    for (i2 = 0; i2 < n2; ++i2)
      t2[r2 + i2] && (e2.trans[nc[t2[r2 + i2]]++] = i2);
  }
  function ac(e2) {
    e2.bitcount-- || (e2.tag = e2.source[e2.sourceIndex++], e2.bitcount = 7);
    var t2 = 1 & e2.tag;
    return e2.tag >>>= 1, t2;
  }
  function oc(e2, t2, r2) {
    if (!t2)
      return r2;
    for (; e2.bitcount < 24; )
      e2.tag |= e2.source[e2.sourceIndex++] << e2.bitcount, e2.bitcount += 8;
    var n2 = e2.tag & 65535 >>> 16 - t2;
    return e2.tag >>>= t2, e2.bitcount -= t2, n2 + r2;
  }
  function sc(e2, t2) {
    for (; e2.bitcount < 24; )
      e2.tag |= e2.source[e2.sourceIndex++] << e2.bitcount, e2.bitcount += 8;
    var r2 = 0, n2 = 0, i2 = 0, a2 = e2.tag;
    do {
      n2 = 2 * n2 + (1 & a2), a2 >>>= 1, ++i2, r2 += t2.table[i2], n2 -= t2.table[i2];
    } while (n2 >= 0);
    return e2.tag = a2, e2.bitcount -= i2, t2.trans[r2 + n2];
  }
  function uc(e2, t2, r2) {
    var n2, i2, a2, o2, s2, u2;
    for (n2 = oc(e2, 5, 257), i2 = oc(e2, 5, 1), a2 = oc(e2, 4, 4), o2 = 0; o2 < 19; ++o2)
      ec[o2] = 0;
    for (o2 = 0; o2 < a2; ++o2) {
      var l2 = oc(e2, 3, 0);
      ec[Ql[o2]] = l2;
    }
    for (ic($l, ec, 0, 19), s2 = 0; s2 < n2 + i2; ) {
      var c2 = sc(e2, $l);
      switch (c2) {
        case 16:
          var f2 = ec[s2 - 1];
          for (u2 = oc(e2, 2, 3); u2; --u2)
            ec[s2++] = f2;
          break;
        case 17:
          for (u2 = oc(e2, 3, 3); u2; --u2)
            ec[s2++] = 0;
          break;
        case 18:
          for (u2 = oc(e2, 7, 11); u2; --u2)
            ec[s2++] = 0;
          break;
        default:
          ec[s2++] = c2;
      }
    }
    ic(t2, ec, 0, n2), ic(r2, ec, n2, i2);
  }
  function lc(e2, t2, r2) {
    for (; ; ) {
      var n2, i2, a2, o2, s2 = sc(e2, t2);
      if (256 === s2)
        return 0;
      if (s2 < 256)
        e2.dest[e2.destLen++] = s2;
      else
        for (n2 = oc(e2, Xl[s2 -= 257], Zl[s2]), i2 = sc(e2, r2), o2 = a2 = e2.destLen - oc(e2, Kl[i2], Jl[i2]); o2 < a2 + n2; ++o2)
          e2.dest[e2.destLen++] = e2.dest[o2];
    }
  }
  function cc(e2) {
    for (var t2, r2; e2.bitcount > 8; )
      e2.sourceIndex--, e2.bitcount -= 8;
    if ((t2 = 256 * (t2 = e2.source[e2.sourceIndex + 1]) + e2.source[e2.sourceIndex]) !== (65535 & ~(256 * e2.source[e2.sourceIndex + 3] + e2.source[e2.sourceIndex + 2])))
      return -3;
    for (e2.sourceIndex += 4, r2 = t2; r2; --r2)
      e2.dest[e2.destLen++] = e2.source[e2.sourceIndex++];
    return e2.bitcount = 0, 0;
  }
  !function(e2, t2) {
    var r2;
    for (r2 = 0; r2 < 7; ++r2)
      e2.table[r2] = 0;
    for (e2.table[7] = 24, e2.table[8] = 152, e2.table[9] = 112, r2 = 0; r2 < 24; ++r2)
      e2.trans[r2] = 256 + r2;
    for (r2 = 0; r2 < 144; ++r2)
      e2.trans[24 + r2] = r2;
    for (r2 = 0; r2 < 8; ++r2)
      e2.trans[168 + r2] = 280 + r2;
    for (r2 = 0; r2 < 112; ++r2)
      e2.trans[176 + r2] = 144 + r2;
    for (r2 = 0; r2 < 5; ++r2)
      t2.table[r2] = 0;
    for (t2.table[5] = 32, r2 = 0; r2 < 32; ++r2)
      t2.trans[r2] = r2;
  }(Hl, Yl), tc(Xl, Zl, 4, 3), tc(Kl, Jl, 2, 1), Xl[28] = 0, Zl[28] = 258, rc = function(e2, t2) {
    var r2, n2, i2 = new Wl(e2, t2);
    do {
      switch (r2 = ac(i2), oc(i2, 2, 0)) {
        case 0:
          n2 = cc(i2);
          break;
        case 1:
          n2 = lc(i2, Hl, Yl);
          break;
        case 2:
          uc(i2, i2.ltree, i2.dtree), n2 = lc(i2, i2.ltree, i2.dtree);
          break;
        default:
          n2 = -3;
      }
      if (0 !== n2)
        throw new Error("Data error");
    } while (!r2);
    return i2.destLen < i2.dest.length ? "function" == typeof i2.dest.slice ? i2.dest.slice(0, i2.destLen) : i2.dest.subarray(0, i2.destLen) : i2.dest;
  };
  var fc = function() {
    function e2(e3) {
      var t2, r2, n2;
      (t2 = "function" == typeof e3.readUInt32BE && "function" == typeof e3.slice) || e3 instanceof Uint8Array ? (t2 ? (this.highStart = e3.readUInt32BE(0), this.errorValue = e3.readUInt32BE(4), r2 = e3.readUInt32BE(8), e3 = e3.slice(12)) : (n2 = new DataView(e3.buffer), this.highStart = n2.getUint32(0), this.errorValue = n2.getUint32(4), r2 = n2.getUint32(8), e3 = e3.subarray(12)), e3 = rc(e3, new Uint8Array(r2)), e3 = rc(e3, new Uint8Array(r2)), this.data = new Uint32Array(e3.buffer)) : (this.data = e3.data, this.highStart = e3.highStart, this.errorValue = e3.errorValue);
    }
    return e2.prototype.get = function(e3) {
      var t2;
      return e3 < 0 || e3 > 1114111 ? this.errorValue : e3 < 55296 || e3 > 56319 && e3 <= 65535 ? (t2 = (this.data[e3 >> 5] << 2) + (31 & e3), this.data[t2]) : e3 <= 65535 ? (t2 = (this.data[2048 + (e3 - 55296 >> 5)] << 2) + (31 & e3), this.data[t2]) : e3 < this.highStart ? (t2 = this.data[2080 + (e3 >> 11)], t2 = ((t2 = this.data[t2 + (e3 >> 5 & 63)]) << 2) + (31 & e3), this.data[t2]) : this.data[this.data.length - 4];
    }, e2;
  }(), hc = t(function(e2, t2) {
    var r2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
    function n2(e3, t3) {
      return Object.prototype.hasOwnProperty.call(e3, t3);
    }
    t2.assign = function(e3) {
      for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
        var r3 = t3.shift();
        if (r3) {
          if ("object" != typeof r3)
            throw new TypeError(r3 + "must be non-object");
          for (var i3 in r3)
            n2(r3, i3) && (e3[i3] = r3[i3]);
        }
      }
      return e3;
    }, t2.shrinkBuf = function(e3, t3) {
      return e3.length === t3 ? e3 : e3.subarray ? e3.subarray(0, t3) : (e3.length = t3, e3);
    };
    var i2 = { arraySet: function(e3, t3, r3, n3, i3) {
      if (t3.subarray && e3.subarray)
        e3.set(t3.subarray(r3, r3 + n3), i3);
      else
        for (var a3 = 0; a3 < n3; a3++)
          e3[i3 + a3] = t3[r3 + a3];
    }, flattenChunks: function(e3) {
      var t3, r3, n3, i3, a3, o2;
      for (n3 = 0, t3 = 0, r3 = e3.length; t3 < r3; t3++)
        n3 += e3[t3].length;
      for (o2 = new Uint8Array(n3), i3 = 0, t3 = 0, r3 = e3.length; t3 < r3; t3++)
        a3 = e3[t3], o2.set(a3, i3), i3 += a3.length;
      return o2;
    } }, a2 = { arraySet: function(e3, t3, r3, n3, i3) {
      for (var a3 = 0; a3 < n3; a3++)
        e3[i3 + a3] = t3[r3 + a3];
    }, flattenChunks: function(e3) {
      return [].concat.apply([], e3);
    } };
    t2.setTyped = function(e3) {
      e3 ? (t2.Buf8 = Uint8Array, t2.Buf16 = Uint16Array, t2.Buf32 = Int32Array, t2.assign(t2, i2)) : (t2.Buf8 = Array, t2.Buf16 = Array, t2.Buf32 = Array, t2.assign(t2, a2));
    }, t2.setTyped(r2);
  });
  hc.assign, hc.shrinkBuf, hc.setTyped, hc.Buf8, hc.Buf16, hc.Buf32;
  function dc(e2) {
    for (var t2 = e2.length; --t2 >= 0; )
      e2[t2] = 0;
  }
  var pc = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], yc = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], gc = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], vc = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], bc = new Array(576);
  dc(bc);
  var mc = new Array(60);
  dc(mc);
  var wc = new Array(512);
  dc(wc);
  var Sc = new Array(256);
  dc(Sc);
  var xc = new Array(29);
  dc(xc);
  var Ac, kc, Cc, Pc = new Array(30);
  function Ic(e2, t2, r2, n2, i2) {
    this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
  }
  function Oc(e2, t2) {
    this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
  }
  function Ec(e2) {
    return e2 < 256 ? wc[e2] : wc[256 + (e2 >>> 7)];
  }
  function Bc(e2, t2) {
    e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
  }
  function Tc(e2, t2, r2) {
    e2.bi_valid > 16 - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, Bc(e2, e2.bi_buf), e2.bi_buf = t2 >> 16 - e2.bi_valid, e2.bi_valid += r2 - 16) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
  }
  function Lc(e2, t2, r2) {
    Tc(e2, r2[2 * t2], r2[2 * t2 + 1]);
  }
  function zc(e2, t2) {
    var r2 = 0;
    do {
      r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1;
    } while (--t2 > 0);
    return r2 >>> 1;
  }
  function Uc(e2, t2, r2) {
    var n2, i2, a2 = new Array(16), o2 = 0;
    for (n2 = 1; n2 <= 15; n2++)
      a2[n2] = o2 = o2 + r2[n2 - 1] << 1;
    for (i2 = 0; i2 <= t2; i2++) {
      var s2 = e2[2 * i2 + 1];
      0 !== s2 && (e2[2 * i2] = zc(a2[s2]++, s2));
    }
  }
  function Dc(e2) {
    var t2;
    for (t2 = 0; t2 < 286; t2++)
      e2.dyn_ltree[2 * t2] = 0;
    for (t2 = 0; t2 < 30; t2++)
      e2.dyn_dtree[2 * t2] = 0;
    for (t2 = 0; t2 < 19; t2++)
      e2.bl_tree[2 * t2] = 0;
    e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
  }
  function jc(e2) {
    e2.bi_valid > 8 ? Bc(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
  }
  function Mc(e2, t2, r2, n2) {
    var i2 = 2 * t2, a2 = 2 * r2;
    return e2[i2] < e2[a2] || e2[i2] === e2[a2] && n2[t2] <= n2[r2];
  }
  function Fc(e2, t2, r2) {
    for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && Mc(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !Mc(t2, n2, e2.heap[i2], e2.depth)); )
      e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
    e2.heap[r2] = n2;
  }
  function Rc(e2, t2, r2) {
    var n2, i2, a2, o2, s2 = 0;
    if (0 !== e2.last_lit)
      do {
        n2 = e2.pending_buf[e2.d_buf + 2 * s2] << 8 | e2.pending_buf[e2.d_buf + 2 * s2 + 1], i2 = e2.pending_buf[e2.l_buf + s2], s2++, 0 === n2 ? Lc(e2, i2, t2) : (Lc(e2, (a2 = Sc[i2]) + 256 + 1, t2), 0 !== (o2 = pc[a2]) && Tc(e2, i2 -= xc[a2], o2), Lc(e2, a2 = Ec(--n2), r2), 0 !== (o2 = yc[a2]) && Tc(e2, n2 -= Pc[a2], o2));
      } while (s2 < e2.last_lit);
    Lc(e2, 256, t2);
  }
  function Nc(e2, t2) {
    var r2, n2, i2, a2 = t2.dyn_tree, o2 = t2.stat_desc.static_tree, s2 = t2.stat_desc.has_stree, u2 = t2.stat_desc.elems, l2 = -1;
    for (e2.heap_len = 0, e2.heap_max = 573, r2 = 0; r2 < u2; r2++)
      0 !== a2[2 * r2] ? (e2.heap[++e2.heap_len] = l2 = r2, e2.depth[r2] = 0) : a2[2 * r2 + 1] = 0;
    for (; e2.heap_len < 2; )
      a2[2 * (i2 = e2.heap[++e2.heap_len] = l2 < 2 ? ++l2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, s2 && (e2.static_len -= o2[2 * i2 + 1]);
    for (t2.max_code = l2, r2 = e2.heap_len >> 1; r2 >= 1; r2--)
      Fc(e2, a2, r2);
    i2 = u2;
    do {
      r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], Fc(e2, a2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, a2[2 * i2] = a2[2 * r2] + a2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, a2[2 * r2 + 1] = a2[2 * n2 + 1] = i2, e2.heap[1] = i2++, Fc(e2, a2, 1);
    } while (e2.heap_len >= 2);
    e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
      var r3, n3, i3, a3, o3, s3, u3 = t3.dyn_tree, l3 = t3.max_code, c2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, h2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, y2 = 0;
      for (a3 = 0; a3 <= 15; a3++)
        e3.bl_count[a3] = 0;
      for (u3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < 573; r3++)
        (a3 = u3[2 * u3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) > p2 && (a3 = p2, y2++), u3[2 * n3 + 1] = a3, n3 > l3 || (e3.bl_count[a3]++, o3 = 0, n3 >= d2 && (o3 = h2[n3 - d2]), s3 = u3[2 * n3], e3.opt_len += s3 * (a3 + o3), f2 && (e3.static_len += s3 * (c2[2 * n3 + 1] + o3)));
      if (0 !== y2) {
        do {
          for (a3 = p2 - 1; 0 === e3.bl_count[a3]; )
            a3--;
          e3.bl_count[a3]--, e3.bl_count[a3 + 1] += 2, e3.bl_count[p2]--, y2 -= 2;
        } while (y2 > 0);
        for (a3 = p2; 0 !== a3; a3--)
          for (n3 = e3.bl_count[a3]; 0 !== n3; )
            (i3 = e3.heap[--r3]) > l3 || (u3[2 * i3 + 1] !== a3 && (e3.opt_len += (a3 - u3[2 * i3 + 1]) * u3[2 * i3], u3[2 * i3 + 1] = a3), n3--);
      }
    }(e2, t2), Uc(a2, l2, e2.bl_count);
  }
  function qc(e2, t2, r2) {
    var n2, i2, a2 = -1, o2 = t2[1], s2 = 0, u2 = 7, l2 = 4;
    for (0 === o2 && (u2 = 138, l2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
      i2 = o2, o2 = t2[2 * (n2 + 1) + 1], ++s2 < u2 && i2 === o2 || (s2 < l2 ? e2.bl_tree[2 * i2] += s2 : 0 !== i2 ? (i2 !== a2 && e2.bl_tree[2 * i2]++, e2.bl_tree[32]++) : s2 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, s2 = 0, a2 = i2, 0 === o2 ? (u2 = 138, l2 = 3) : i2 === o2 ? (u2 = 6, l2 = 3) : (u2 = 7, l2 = 4));
  }
  function Gc(e2, t2, r2) {
    var n2, i2, a2 = -1, o2 = t2[1], s2 = 0, u2 = 7, l2 = 4;
    for (0 === o2 && (u2 = 138, l2 = 3), n2 = 0; n2 <= r2; n2++)
      if (i2 = o2, o2 = t2[2 * (n2 + 1) + 1], !(++s2 < u2 && i2 === o2)) {
        if (s2 < l2)
          do {
            Lc(e2, i2, e2.bl_tree);
          } while (0 != --s2);
        else
          0 !== i2 ? (i2 !== a2 && (Lc(e2, i2, e2.bl_tree), s2--), Lc(e2, 16, e2.bl_tree), Tc(e2, s2 - 3, 2)) : s2 <= 10 ? (Lc(e2, 17, e2.bl_tree), Tc(e2, s2 - 3, 3)) : (Lc(e2, 18, e2.bl_tree), Tc(e2, s2 - 11, 7));
        s2 = 0, a2 = i2, 0 === o2 ? (u2 = 138, l2 = 3) : i2 === o2 ? (u2 = 6, l2 = 3) : (u2 = 7, l2 = 4);
      }
  }
  dc(Pc);
  var Vc = false;
  function _c(e2, t2, r2, n2) {
    Tc(e2, 0 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
      jc(e3), n3 && (Bc(e3, r3), Bc(e3, ~r3)), hc.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
    }(e2, t2, r2, true);
  }
  var Wc = { _tr_init: function(e2) {
    Vc || (!function() {
      var e3, t2, r2, n2, i2, a2 = new Array(16);
      for (r2 = 0, n2 = 0; n2 < 28; n2++)
        for (xc[n2] = r2, e3 = 0; e3 < 1 << pc[n2]; e3++)
          Sc[r2++] = n2;
      for (Sc[r2 - 1] = n2, i2 = 0, n2 = 0; n2 < 16; n2++)
        for (Pc[n2] = i2, e3 = 0; e3 < 1 << yc[n2]; e3++)
          wc[i2++] = n2;
      for (i2 >>= 7; n2 < 30; n2++)
        for (Pc[n2] = i2 << 7, e3 = 0; e3 < 1 << yc[n2] - 7; e3++)
          wc[256 + i2++] = n2;
      for (t2 = 0; t2 <= 15; t2++)
        a2[t2] = 0;
      for (e3 = 0; e3 <= 143; )
        bc[2 * e3 + 1] = 8, e3++, a2[8]++;
      for (; e3 <= 255; )
        bc[2 * e3 + 1] = 9, e3++, a2[9]++;
      for (; e3 <= 279; )
        bc[2 * e3 + 1] = 7, e3++, a2[7]++;
      for (; e3 <= 287; )
        bc[2 * e3 + 1] = 8, e3++, a2[8]++;
      for (Uc(bc, 287, a2), e3 = 0; e3 < 30; e3++)
        mc[2 * e3 + 1] = 5, mc[2 * e3] = zc(e3, 5);
      Ac = new Ic(bc, pc, 257, 286, 15), kc = new Ic(mc, yc, 0, 30, 15), Cc = new Ic(new Array(0), gc, 0, 19, 7);
    }(), Vc = true), e2.l_desc = new Oc(e2.dyn_ltree, Ac), e2.d_desc = new Oc(e2.dyn_dtree, kc), e2.bl_desc = new Oc(e2.bl_tree, Cc), e2.bi_buf = 0, e2.bi_valid = 0, Dc(e2);
  }, _tr_stored_block: _c, _tr_flush_block: function(e2, t2, r2, n2) {
    var i2, a2, o2 = 0;
    e2.level > 0 ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
      var t3, r3 = 4093624447;
      for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
        if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
          return 0;
      if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
        return 1;
      for (t3 = 32; t3 < 256; t3++)
        if (0 !== e3.dyn_ltree[2 * t3])
          return 1;
      return 0;
    }(e2)), Nc(e2, e2.l_desc), Nc(e2, e2.d_desc), o2 = function(e3) {
      var t3;
      for (qc(e3, e3.dyn_ltree, e3.l_desc.max_code), qc(e3, e3.dyn_dtree, e3.d_desc.max_code), Nc(e3, e3.bl_desc), t3 = 18; t3 >= 3 && 0 === e3.bl_tree[2 * vc[t3] + 1]; t3--)
        ;
      return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
    }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (a2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = a2)) : i2 = a2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? _c(e2, t2, r2, n2) : 4 === e2.strategy || a2 === i2 ? (Tc(e2, 2 + (n2 ? 1 : 0), 3), Rc(e2, bc, mc)) : (Tc(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
      var i3;
      for (Tc(e3, t3 - 257, 5), Tc(e3, r3 - 1, 5), Tc(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
        Tc(e3, e3.bl_tree[2 * vc[i3] + 1], 3);
      Gc(e3, e3.dyn_ltree, t3 - 1), Gc(e3, e3.dyn_dtree, r3 - 1);
    }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, o2 + 1), Rc(e2, e2.dyn_ltree, e2.dyn_dtree)), Dc(e2), n2 && jc(e2);
  }, _tr_tally: function(e2, t2, r2) {
    return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (Sc[r2] + 256 + 1)]++, e2.dyn_dtree[2 * Ec(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
  }, _tr_align: function(e2) {
    Tc(e2, 2, 3), Lc(e2, 256, bc), function(e3) {
      16 === e3.bi_valid ? (Bc(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
    }(e2);
  } };
  var Hc = function(e2, t2, r2, n2) {
    for (var i2 = 65535 & e2 | 0, a2 = e2 >>> 16 & 65535 | 0, o2 = 0; 0 !== r2; ) {
      r2 -= o2 = r2 > 2e3 ? 2e3 : r2;
      do {
        a2 = a2 + (i2 = i2 + t2[n2++] | 0) | 0;
      } while (--o2);
      i2 %= 65521, a2 %= 65521;
    }
    return i2 | a2 << 16 | 0;
  };
  var Yc = function() {
    for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
      e2 = r2;
      for (var n2 = 0; n2 < 8; n2++)
        e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
      t2[r2] = e2;
    }
    return t2;
  }();
  var Xc, Zc = function(e2, t2, r2, n2) {
    var i2 = Yc, a2 = n2 + r2;
    e2 ^= -1;
    for (var o2 = n2; o2 < a2; o2++)
      e2 = e2 >>> 8 ^ i2[255 & (e2 ^ t2[o2])];
    return -1 ^ e2;
  }, Kc = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
  function Jc(e2, t2) {
    return e2.msg = Kc[t2], t2;
  }
  function Qc(e2) {
    return (e2 << 1) - (e2 > 4 ? 9 : 0);
  }
  function $c(e2) {
    for (var t2 = e2.length; --t2 >= 0; )
      e2[t2] = 0;
  }
  function ef(e2) {
    var t2 = e2.state, r2 = t2.pending;
    r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (hc.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
  }
  function tf(e2, t2) {
    Wc._tr_flush_block(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, ef(e2.strm);
  }
  function rf(e2, t2) {
    e2.pending_buf[e2.pending++] = t2;
  }
  function nf(e2, t2) {
    e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
  }
  function af(e2, t2, r2, n2) {
    var i2 = e2.avail_in;
    return i2 > n2 && (i2 = n2), 0 === i2 ? 0 : (e2.avail_in -= i2, hc.arraySet(t2, e2.input, e2.next_in, i2, r2), 1 === e2.state.wrap ? e2.adler = Hc(e2.adler, t2, i2, r2) : 2 === e2.state.wrap && (e2.adler = Zc(e2.adler, t2, i2, r2)), e2.next_in += i2, e2.total_in += i2, i2);
  }
  function of(e2, t2) {
    var r2, n2, i2 = e2.max_chain_length, a2 = e2.strstart, o2 = e2.prev_length, s2 = e2.nice_match, u2 = e2.strstart > e2.w_size - 262 ? e2.strstart - (e2.w_size - 262) : 0, l2 = e2.window, c2 = e2.w_mask, f2 = e2.prev, h2 = e2.strstart + 258, d2 = l2[a2 + o2 - 1], p2 = l2[a2 + o2];
    e2.prev_length >= e2.good_match && (i2 >>= 2), s2 > e2.lookahead && (s2 = e2.lookahead);
    do {
      if (l2[(r2 = t2) + o2] === p2 && l2[r2 + o2 - 1] === d2 && l2[r2] === l2[a2] && l2[++r2] === l2[a2 + 1]) {
        a2 += 2, r2++;
        do {
        } while (l2[++a2] === l2[++r2] && l2[++a2] === l2[++r2] && l2[++a2] === l2[++r2] && l2[++a2] === l2[++r2] && l2[++a2] === l2[++r2] && l2[++a2] === l2[++r2] && l2[++a2] === l2[++r2] && l2[++a2] === l2[++r2] && a2 < h2);
        if (n2 = 258 - (h2 - a2), a2 = h2 - 258, n2 > o2) {
          if (e2.match_start = t2, o2 = n2, n2 >= s2)
            break;
          d2 = l2[a2 + o2 - 1], p2 = l2[a2 + o2];
        }
      }
    } while ((t2 = f2[t2 & c2]) > u2 && 0 != --i2);
    return o2 <= e2.lookahead ? o2 : e2.lookahead;
  }
  function sf(e2) {
    var t2, r2, n2, i2, a2, o2 = e2.w_size;
    do {
      if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= o2 + (o2 - 262)) {
        hc.arraySet(e2.window, e2.window, o2, o2, 0), e2.match_start -= o2, e2.strstart -= o2, e2.block_start -= o2, t2 = r2 = e2.hash_size;
        do {
          n2 = e2.head[--t2], e2.head[t2] = n2 >= o2 ? n2 - o2 : 0;
        } while (--r2);
        t2 = r2 = o2;
        do {
          n2 = e2.prev[--t2], e2.prev[t2] = n2 >= o2 ? n2 - o2 : 0;
        } while (--r2);
        i2 += o2;
      }
      if (0 === e2.strm.avail_in)
        break;
      if (r2 = af(e2.strm, e2.window, e2.strstart + e2.lookahead, i2), e2.lookahead += r2, e2.lookahead + e2.insert >= 3)
        for (a2 = e2.strstart - e2.insert, e2.ins_h = e2.window[a2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[a2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[a2 + 3 - 1]) & e2.hash_mask, e2.prev[a2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = a2, a2++, e2.insert--, !(e2.lookahead + e2.insert < 3)); )
          ;
    } while (e2.lookahead < 262 && 0 !== e2.strm.avail_in);
  }
  function uf(e2, t2) {
    for (var r2, n2; ; ) {
      if (e2.lookahead < 262) {
        if (sf(e2), e2.lookahead < 262 && 0 === t2)
          return 1;
        if (0 === e2.lookahead)
          break;
      }
      if (r2 = 0, e2.lookahead >= 3 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - 262 && (e2.match_length = of(e2, r2)), e2.match_length >= 3)
        if (n2 = Wc._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - 3), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= 3) {
          e2.match_length--;
          do {
            e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
          } while (0 != --e2.match_length);
          e2.strstart++;
        } else
          e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
      else
        n2 = Wc._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
      if (n2 && (tf(e2, false), 0 === e2.strm.avail_out))
        return 1;
    }
    return e2.insert = e2.strstart < 2 ? e2.strstart : 2, 4 === t2 ? (tf(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.last_lit && (tf(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
  }
  function lf(e2, t2) {
    for (var r2, n2, i2; ; ) {
      if (e2.lookahead < 262) {
        if (sf(e2), e2.lookahead < 262 && 0 === t2)
          return 1;
        if (0 === e2.lookahead)
          break;
      }
      if (r2 = 0, e2.lookahead >= 3 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = 2, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - 262 && (e2.match_length = of(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || 3 === e2.match_length && e2.strstart - e2.match_start > 4096) && (e2.match_length = 2)), e2.prev_length >= 3 && e2.match_length <= e2.prev_length) {
        i2 = e2.strstart + e2.lookahead - 3, n2 = Wc._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - 3), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
        do {
          ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
        } while (0 != --e2.prev_length);
        if (e2.match_available = 0, e2.match_length = 2, e2.strstart++, n2 && (tf(e2, false), 0 === e2.strm.avail_out))
          return 1;
      } else if (e2.match_available) {
        if ((n2 = Wc._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && tf(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
          return 1;
      } else
        e2.match_available = 1, e2.strstart++, e2.lookahead--;
    }
    return e2.match_available && (n2 = Wc._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < 2 ? e2.strstart : 2, 4 === t2 ? (tf(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : e2.last_lit && (tf(e2, false), 0 === e2.strm.avail_out) ? 1 : 2;
  }
  function cf(e2, t2, r2, n2, i2) {
    this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
  }
  function ff() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new hc.Buf16(1146), this.dyn_dtree = new hc.Buf16(122), this.bl_tree = new hc.Buf16(78), $c(this.dyn_ltree), $c(this.dyn_dtree), $c(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new hc.Buf16(16), this.heap = new hc.Buf16(573), $c(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new hc.Buf16(573), $c(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function hf(e2) {
    var t2;
    return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = 2, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? 42 : 113, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = 0, Wc._tr_init(t2), 0) : Jc(e2, -2);
  }
  function df(e2) {
    var t2, r2 = hf(e2);
    return 0 === r2 && ((t2 = e2.state).window_size = 2 * t2.w_size, $c(t2.head), t2.max_lazy_match = Xc[t2.level].max_lazy, t2.good_match = Xc[t2.level].good_length, t2.nice_match = Xc[t2.level].nice_length, t2.max_chain_length = Xc[t2.level].max_chain, t2.strstart = 0, t2.block_start = 0, t2.lookahead = 0, t2.insert = 0, t2.match_length = t2.prev_length = 2, t2.match_available = 0, t2.ins_h = 0), r2;
  }
  function pf(e2, t2, r2, n2, i2, a2) {
    if (!e2)
      return -2;
    var o2 = 1;
    if (-1 === t2 && (t2 = 6), n2 < 0 ? (o2 = 0, n2 = -n2) : n2 > 15 && (o2 = 2, n2 -= 16), i2 < 1 || i2 > 9 || 8 !== r2 || n2 < 8 || n2 > 15 || t2 < 0 || t2 > 9 || a2 < 0 || a2 > 4)
      return Jc(e2, -2);
    8 === n2 && (n2 = 9);
    var s2 = new ff();
    return e2.state = s2, s2.strm = e2, s2.wrap = o2, s2.gzhead = null, s2.w_bits = n2, s2.w_size = 1 << s2.w_bits, s2.w_mask = s2.w_size - 1, s2.hash_bits = i2 + 7, s2.hash_size = 1 << s2.hash_bits, s2.hash_mask = s2.hash_size - 1, s2.hash_shift = ~~((s2.hash_bits + 3 - 1) / 3), s2.window = new hc.Buf8(2 * s2.w_size), s2.head = new hc.Buf16(s2.hash_size), s2.prev = new hc.Buf16(s2.w_size), s2.lit_bufsize = 1 << i2 + 6, s2.pending_buf_size = 4 * s2.lit_bufsize, s2.pending_buf = new hc.Buf8(s2.pending_buf_size), s2.d_buf = 1 * s2.lit_bufsize, s2.l_buf = 3 * s2.lit_bufsize, s2.level = t2, s2.strategy = a2, s2.method = r2, df(e2);
  }
  Xc = [new cf(0, 0, 0, 0, function(e2, t2) {
    var r2 = 65535;
    for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
      if (e2.lookahead <= 1) {
        if (sf(e2), 0 === e2.lookahead && 0 === t2)
          return 1;
        if (0 === e2.lookahead)
          break;
      }
      e2.strstart += e2.lookahead, e2.lookahead = 0;
      var n2 = e2.block_start + r2;
      if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, tf(e2, false), 0 === e2.strm.avail_out))
        return 1;
      if (e2.strstart - e2.block_start >= e2.w_size - 262 && (tf(e2, false), 0 === e2.strm.avail_out))
        return 1;
    }
    return e2.insert = 0, 4 === t2 ? (tf(e2, true), 0 === e2.strm.avail_out ? 3 : 4) : (e2.strstart > e2.block_start && (tf(e2, false), e2.strm.avail_out), 1);
  }), new cf(4, 4, 8, 4, uf), new cf(4, 5, 16, 8, uf), new cf(4, 6, 32, 32, uf), new cf(4, 4, 16, 16, lf), new cf(8, 16, 32, 32, lf), new cf(8, 16, 128, 128, lf), new cf(8, 32, 128, 256, lf), new cf(32, 128, 258, 1024, lf), new cf(32, 258, 258, 4096, lf)];
  var yf = { deflateInit: function(e2, t2) {
    return pf(e2, t2, 8, 15, 8, 0);
  }, deflateInit2: pf, deflateReset: df, deflateResetKeep: hf, deflateSetHeader: function(e2, t2) {
    return e2 && e2.state ? 2 !== e2.state.wrap ? -2 : (e2.state.gzhead = t2, 0) : -2;
  }, deflate: function(e2, t2) {
    var r2, n2, i2, a2;
    if (!e2 || !e2.state || t2 > 5 || t2 < 0)
      return e2 ? Jc(e2, -2) : -2;
    if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && 4 !== t2)
      return Jc(e2, 0 === e2.avail_out ? -5 : -2);
    if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, 42 === n2.status)
      if (2 === n2.wrap)
        e2.adler = 0, rf(n2, 31), rf(n2, 139), rf(n2, 8), n2.gzhead ? (rf(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), rf(n2, 255 & n2.gzhead.time), rf(n2, n2.gzhead.time >> 8 & 255), rf(n2, n2.gzhead.time >> 16 & 255), rf(n2, n2.gzhead.time >> 24 & 255), rf(n2, 9 === n2.level ? 2 : n2.strategy >= 2 || n2.level < 2 ? 4 : 0), rf(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (rf(n2, 255 & n2.gzhead.extra.length), rf(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = Zc(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (rf(n2, 0), rf(n2, 0), rf(n2, 0), rf(n2, 0), rf(n2, 0), rf(n2, 9 === n2.level ? 2 : n2.strategy >= 2 || n2.level < 2 ? 4 : 0), rf(n2, 3), n2.status = 113);
      else {
        var o2 = 8 + (n2.w_bits - 8 << 4) << 8;
        o2 |= (n2.strategy >= 2 || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (o2 |= 32), o2 += 31 - o2 % 31, n2.status = 113, nf(n2, o2), 0 !== n2.strstart && (nf(n2, e2.adler >>> 16), nf(n2, 65535 & e2.adler)), e2.adler = 1;
      }
    if (69 === n2.status)
      if (n2.gzhead.extra) {
        for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zc(e2.adler, n2.pending_buf, n2.pending - i2, i2)), ef(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
          rf(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
        n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zc(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
      } else
        n2.status = 73;
    if (73 === n2.status)
      if (n2.gzhead.name) {
        i2 = n2.pending;
        do {
          if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zc(e2.adler, n2.pending_buf, n2.pending - i2, i2)), ef(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
            a2 = 1;
            break;
          }
          a2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, rf(n2, a2);
        } while (0 !== a2);
        n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zc(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === a2 && (n2.gzindex = 0, n2.status = 91);
      } else
        n2.status = 91;
    if (91 === n2.status)
      if (n2.gzhead.comment) {
        i2 = n2.pending;
        do {
          if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zc(e2.adler, n2.pending_buf, n2.pending - i2, i2)), ef(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
            a2 = 1;
            break;
          }
          a2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, rf(n2, a2);
        } while (0 !== a2);
        n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = Zc(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === a2 && (n2.status = 103);
      } else
        n2.status = 103;
    if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && ef(e2), n2.pending + 2 <= n2.pending_buf_size && (rf(n2, 255 & e2.adler), rf(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = 113)) : n2.status = 113), 0 !== n2.pending) {
      if (ef(e2), 0 === e2.avail_out)
        return n2.last_flush = -1, 0;
    } else if (0 === e2.avail_in && Qc(t2) <= Qc(r2) && 4 !== t2)
      return Jc(e2, -5);
    if (666 === n2.status && 0 !== e2.avail_in)
      return Jc(e2, -5);
    if (0 !== e2.avail_in || 0 !== n2.lookahead || 0 !== t2 && 666 !== n2.status) {
      var s2 = 2 === n2.strategy ? function(e3, t3) {
        for (var r3; ; ) {
          if (0 === e3.lookahead && (sf(e3), 0 === e3.lookahead)) {
            if (0 === t3)
              return 1;
            break;
          }
          if (e3.match_length = 0, r3 = Wc._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (tf(e3, false), 0 === e3.strm.avail_out))
            return 1;
        }
        return e3.insert = 0, 4 === t3 ? (tf(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (tf(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
      }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
        for (var r3, n3, i3, a3, o3 = e3.window; ; ) {
          if (e3.lookahead <= 258) {
            if (sf(e3), e3.lookahead <= 258 && 0 === t3)
              return 1;
            if (0 === e3.lookahead)
              break;
          }
          if (e3.match_length = 0, e3.lookahead >= 3 && e3.strstart > 0 && (n3 = o3[i3 = e3.strstart - 1]) === o3[++i3] && n3 === o3[++i3] && n3 === o3[++i3]) {
            a3 = e3.strstart + 258;
            do {
            } while (n3 === o3[++i3] && n3 === o3[++i3] && n3 === o3[++i3] && n3 === o3[++i3] && n3 === o3[++i3] && n3 === o3[++i3] && n3 === o3[++i3] && n3 === o3[++i3] && i3 < a3);
            e3.match_length = 258 - (a3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
          }
          if (e3.match_length >= 3 ? (r3 = Wc._tr_tally(e3, 1, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = Wc._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (tf(e3, false), 0 === e3.strm.avail_out))
            return 1;
        }
        return e3.insert = 0, 4 === t3 ? (tf(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (tf(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
      }(n2, t2) : Xc[n2.level].func(n2, t2);
      if (3 !== s2 && 4 !== s2 || (n2.status = 666), 1 === s2 || 3 === s2)
        return 0 === e2.avail_out && (n2.last_flush = -1), 0;
      if (2 === s2 && (1 === t2 ? Wc._tr_align(n2) : 5 !== t2 && (Wc._tr_stored_block(n2, 0, 0, false), 3 === t2 && ($c(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), ef(e2), 0 === e2.avail_out))
        return n2.last_flush = -1, 0;
    }
    return 4 !== t2 ? 0 : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (rf(n2, 255 & e2.adler), rf(n2, e2.adler >> 8 & 255), rf(n2, e2.adler >> 16 & 255), rf(n2, e2.adler >> 24 & 255), rf(n2, 255 & e2.total_in), rf(n2, e2.total_in >> 8 & 255), rf(n2, e2.total_in >> 16 & 255), rf(n2, e2.total_in >> 24 & 255)) : (nf(n2, e2.adler >>> 16), nf(n2, 65535 & e2.adler)), ef(e2), n2.wrap > 0 && (n2.wrap = -n2.wrap), 0 !== n2.pending ? 0 : 1);
  }, deflateEnd: function(e2) {
    var t2;
    return e2 && e2.state ? 42 !== (t2 = e2.state.status) && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && 113 !== t2 && 666 !== t2 ? Jc(e2, -2) : (e2.state = null, 113 === t2 ? Jc(e2, -3) : 0) : -2;
  }, deflateSetDictionary: function(e2, t2) {
    var r2, n2, i2, a2, o2, s2, u2, l2, c2 = t2.length;
    if (!e2 || !e2.state)
      return -2;
    if (2 === (a2 = (r2 = e2.state).wrap) || 1 === a2 && 42 !== r2.status || r2.lookahead)
      return -2;
    for (1 === a2 && (e2.adler = Hc(e2.adler, t2, c2, 0)), r2.wrap = 0, c2 >= r2.w_size && (0 === a2 && ($c(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), l2 = new hc.Buf8(r2.w_size), hc.arraySet(l2, t2, c2 - r2.w_size, r2.w_size, 0), t2 = l2, c2 = r2.w_size), o2 = e2.avail_in, s2 = e2.next_in, u2 = e2.input, e2.avail_in = c2, e2.next_in = 0, e2.input = t2, sf(r2); r2.lookahead >= 3; ) {
      n2 = r2.strstart, i2 = r2.lookahead - 2;
      do {
        r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + 3 - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++;
      } while (--i2);
      r2.strstart = n2, r2.lookahead = 2, sf(r2);
    }
    return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = 2, r2.match_available = 0, e2.next_in = s2, e2.input = u2, e2.avail_in = o2, r2.wrap = a2, 0;
  }, deflateInfo: "pako deflate (from Nodeca project)" }, gf = true, vf = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (e2) {
    gf = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (e2) {
    vf = false;
  }
  for (var bf = new hc.Buf8(256), mf = 0; mf < 256; mf++)
    bf[mf] = mf >= 252 ? 6 : mf >= 248 ? 5 : mf >= 240 ? 4 : mf >= 224 ? 3 : mf >= 192 ? 2 : 1;
  bf[254] = bf[254] = 1;
  function wf(e2, t2) {
    if (t2 < 65534 && (e2.subarray && vf || !e2.subarray && gf))
      return String.fromCharCode.apply(null, hc.shrinkBuf(e2, t2));
    for (var r2 = "", n2 = 0; n2 < t2; n2++)
      r2 += String.fromCharCode(e2[n2]);
    return r2;
  }
  var Sf = function(e2) {
    var t2, r2, n2, i2, a2, o2 = e2.length, s2 = 0;
    for (i2 = 0; i2 < o2; i2++)
      55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < o2 && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), s2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
    for (t2 = new hc.Buf8(s2), a2 = 0, i2 = 0; a2 < s2; i2++)
      55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < o2 && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[a2++] = r2 : r2 < 2048 ? (t2[a2++] = 192 | r2 >>> 6, t2[a2++] = 128 | 63 & r2) : r2 < 65536 ? (t2[a2++] = 224 | r2 >>> 12, t2[a2++] = 128 | r2 >>> 6 & 63, t2[a2++] = 128 | 63 & r2) : (t2[a2++] = 240 | r2 >>> 18, t2[a2++] = 128 | r2 >>> 12 & 63, t2[a2++] = 128 | r2 >>> 6 & 63, t2[a2++] = 128 | 63 & r2);
    return t2;
  }, xf = function(e2) {
    return wf(e2, e2.length);
  }, Af = function(e2) {
    for (var t2 = new hc.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
      t2[r2] = e2.charCodeAt(r2);
    return t2;
  }, kf = function(e2, t2) {
    var r2, n2, i2, a2, o2 = t2 || e2.length, s2 = new Array(2 * o2);
    for (n2 = 0, r2 = 0; r2 < o2; )
      if ((i2 = e2[r2++]) < 128)
        s2[n2++] = i2;
      else if ((a2 = bf[i2]) > 4)
        s2[n2++] = 65533, r2 += a2 - 1;
      else {
        for (i2 &= 2 === a2 ? 31 : 3 === a2 ? 15 : 7; a2 > 1 && r2 < o2; )
          i2 = i2 << 6 | 63 & e2[r2++], a2--;
        a2 > 1 ? s2[n2++] = 65533 : i2 < 65536 ? s2[n2++] = i2 : (i2 -= 65536, s2[n2++] = 55296 | i2 >> 10 & 1023, s2[n2++] = 56320 | 1023 & i2);
      }
    return wf(s2, n2);
  }, Cf = function(e2, t2) {
    var r2;
    for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; r2 >= 0 && 128 == (192 & e2[r2]); )
      r2--;
    return r2 < 0 || 0 === r2 ? t2 : r2 + bf[e2[r2]] > t2 ? r2 : t2;
  };
  var Pf = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }, If = Object.prototype.toString;
  function Of(e2) {
    if (!(this instanceof Of))
      return new Of(e2);
    this.options = hc.assign({ level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, to: "" }, e2 || {});
    var t2 = this.options;
    t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Pf(), this.strm.avail_out = 0;
    var r2 = yf.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
    if (0 !== r2)
      throw new Error(Kc[r2]);
    if (t2.header && yf.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
      var n2;
      if (n2 = "string" == typeof t2.dictionary ? Sf(t2.dictionary) : "[object ArrayBuffer]" === If.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, 0 !== (r2 = yf.deflateSetDictionary(this.strm, n2)))
        throw new Error(Kc[r2]);
      this._dict_set = true;
    }
  }
  function Ef(e2, t2) {
    var r2 = new Of(t2);
    if (r2.push(e2, true), r2.err)
      throw r2.msg || Kc[r2.err];
    return r2.result;
  }
  Of.prototype.push = function(e2, t2) {
    var r2, n2, i2 = this.strm, a2 = this.options.chunkSize;
    if (this.ended)
      return false;
    n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = Sf(e2) : "[object ArrayBuffer]" === If.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
    do {
      if (0 === i2.avail_out && (i2.output = new hc.Buf8(a2), i2.next_out = 0, i2.avail_out = a2), 1 !== (r2 = yf.deflate(i2, n2)) && 0 !== r2)
        return this.onEnd(r2), this.ended = true, false;
      0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(xf(hc.shrinkBuf(i2.output, i2.next_out))) : this.onData(hc.shrinkBuf(i2.output, i2.next_out)));
    } while ((i2.avail_in > 0 || 0 === i2.avail_out) && 1 !== r2);
    return 4 === n2 ? (r2 = yf.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, 0 === r2) : 2 !== n2 || (this.onEnd(0), i2.avail_out = 0, true);
  }, Of.prototype.onData = function(e2) {
    this.chunks.push(e2);
  }, Of.prototype.onEnd = function(e2) {
    0 === e2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = hc.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
  };
  var Bf = { Deflate: Of, deflate: Ef, deflateRaw: function(e2, t2) {
    return (t2 = t2 || {}).raw = true, Ef(e2, t2);
  }, gzip: function(e2, t2) {
    return (t2 = t2 || {}).gzip = true, Ef(e2, t2);
  } }, Tf = function(e2, t2) {
    var r2, n2, i2, a2, o2, s2, u2, l2, c2, f2, h2, d2, p2, y2, g2, v2, b2, m2, w2, S2, x2, A2, k2, C2, P2;
    r2 = e2.state, n2 = e2.next_in, C2 = e2.input, i2 = n2 + (e2.avail_in - 5), a2 = e2.next_out, P2 = e2.output, o2 = a2 - (t2 - e2.avail_out), s2 = a2 + (e2.avail_out - 257), u2 = r2.dmax, l2 = r2.wsize, c2 = r2.whave, f2 = r2.wnext, h2 = r2.window, d2 = r2.hold, p2 = r2.bits, y2 = r2.lencode, g2 = r2.distcode, v2 = (1 << r2.lenbits) - 1, b2 = (1 << r2.distbits) - 1;
    e:
      do {
        p2 < 15 && (d2 += C2[n2++] << p2, p2 += 8, d2 += C2[n2++] << p2, p2 += 8), m2 = y2[d2 & v2];
        t:
          for (; ; ) {
            if (d2 >>>= w2 = m2 >>> 24, p2 -= w2, 0 === (w2 = m2 >>> 16 & 255))
              P2[a2++] = 65535 & m2;
            else {
              if (!(16 & w2)) {
                if (0 == (64 & w2)) {
                  m2 = y2[(65535 & m2) + (d2 & (1 << w2) - 1)];
                  continue t;
                }
                if (32 & w2) {
                  r2.mode = 12;
                  break e;
                }
                e2.msg = "invalid literal/length code", r2.mode = 30;
                break e;
              }
              S2 = 65535 & m2, (w2 &= 15) && (p2 < w2 && (d2 += C2[n2++] << p2, p2 += 8), S2 += d2 & (1 << w2) - 1, d2 >>>= w2, p2 -= w2), p2 < 15 && (d2 += C2[n2++] << p2, p2 += 8, d2 += C2[n2++] << p2, p2 += 8), m2 = g2[d2 & b2];
              r:
                for (; ; ) {
                  if (d2 >>>= w2 = m2 >>> 24, p2 -= w2, !(16 & (w2 = m2 >>> 16 & 255))) {
                    if (0 == (64 & w2)) {
                      m2 = g2[(65535 & m2) + (d2 & (1 << w2) - 1)];
                      continue r;
                    }
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break e;
                  }
                  if (x2 = 65535 & m2, p2 < (w2 &= 15) && (d2 += C2[n2++] << p2, (p2 += 8) < w2 && (d2 += C2[n2++] << p2, p2 += 8)), (x2 += d2 & (1 << w2) - 1) > u2) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break e;
                  }
                  if (d2 >>>= w2, p2 -= w2, x2 > (w2 = a2 - o2)) {
                    if ((w2 = x2 - w2) > c2 && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break e;
                    }
                    if (A2 = 0, k2 = h2, 0 === f2) {
                      if (A2 += l2 - w2, w2 < S2) {
                        S2 -= w2;
                        do {
                          P2[a2++] = h2[A2++];
                        } while (--w2);
                        A2 = a2 - x2, k2 = P2;
                      }
                    } else if (f2 < w2) {
                      if (A2 += l2 + f2 - w2, (w2 -= f2) < S2) {
                        S2 -= w2;
                        do {
                          P2[a2++] = h2[A2++];
                        } while (--w2);
                        if (A2 = 0, f2 < S2) {
                          S2 -= w2 = f2;
                          do {
                            P2[a2++] = h2[A2++];
                          } while (--w2);
                          A2 = a2 - x2, k2 = P2;
                        }
                      }
                    } else if (A2 += f2 - w2, w2 < S2) {
                      S2 -= w2;
                      do {
                        P2[a2++] = h2[A2++];
                      } while (--w2);
                      A2 = a2 - x2, k2 = P2;
                    }
                    for (; S2 > 2; )
                      P2[a2++] = k2[A2++], P2[a2++] = k2[A2++], P2[a2++] = k2[A2++], S2 -= 3;
                    S2 && (P2[a2++] = k2[A2++], S2 > 1 && (P2[a2++] = k2[A2++]));
                  } else {
                    A2 = a2 - x2;
                    do {
                      P2[a2++] = P2[A2++], P2[a2++] = P2[A2++], P2[a2++] = P2[A2++], S2 -= 3;
                    } while (S2 > 2);
                    S2 && (P2[a2++] = P2[A2++], S2 > 1 && (P2[a2++] = P2[A2++]));
                  }
                  break;
                }
            }
            break;
          }
      } while (n2 < i2 && a2 < s2);
    n2 -= S2 = p2 >> 3, d2 &= (1 << (p2 -= S2 << 3)) - 1, e2.next_in = n2, e2.next_out = a2, e2.avail_in = n2 < i2 ? i2 - n2 + 5 : 5 - (n2 - i2), e2.avail_out = a2 < s2 ? s2 - a2 + 257 : 257 - (a2 - s2), r2.hold = d2, r2.bits = p2;
  }, Lf = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], zf = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], Uf = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], Df = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64], jf = function(e2, t2, r2, n2, i2, a2, o2, s2) {
    var u2, l2, c2, f2, h2, d2, p2, y2, g2, v2 = s2.bits, b2 = 0, m2 = 0, w2 = 0, S2 = 0, x2 = 0, A2 = 0, k2 = 0, C2 = 0, P2 = 0, I2 = 0, O2 = null, E2 = 0, B2 = new hc.Buf16(16), T2 = new hc.Buf16(16), L2 = null, z2 = 0;
    for (b2 = 0; b2 <= 15; b2++)
      B2[b2] = 0;
    for (m2 = 0; m2 < n2; m2++)
      B2[t2[r2 + m2]]++;
    for (x2 = v2, S2 = 15; S2 >= 1 && 0 === B2[S2]; S2--)
      ;
    if (x2 > S2 && (x2 = S2), 0 === S2)
      return i2[a2++] = 20971520, i2[a2++] = 20971520, s2.bits = 1, 0;
    for (w2 = 1; w2 < S2 && 0 === B2[w2]; w2++)
      ;
    for (x2 < w2 && (x2 = w2), C2 = 1, b2 = 1; b2 <= 15; b2++)
      if (C2 <<= 1, (C2 -= B2[b2]) < 0)
        return -1;
    if (C2 > 0 && (0 === e2 || 1 !== S2))
      return -1;
    for (T2[1] = 0, b2 = 1; b2 < 15; b2++)
      T2[b2 + 1] = T2[b2] + B2[b2];
    for (m2 = 0; m2 < n2; m2++)
      0 !== t2[r2 + m2] && (o2[T2[t2[r2 + m2]]++] = m2);
    if (0 === e2 ? (O2 = L2 = o2, d2 = 19) : 1 === e2 ? (O2 = Lf, E2 -= 257, L2 = zf, z2 -= 257, d2 = 256) : (O2 = Uf, L2 = Df, d2 = -1), I2 = 0, m2 = 0, b2 = w2, h2 = a2, A2 = x2, k2 = 0, c2 = -1, f2 = (P2 = 1 << x2) - 1, 1 === e2 && P2 > 852 || 2 === e2 && P2 > 592)
      return 1;
    for (; ; ) {
      p2 = b2 - k2, o2[m2] < d2 ? (y2 = 0, g2 = o2[m2]) : o2[m2] > d2 ? (y2 = L2[z2 + o2[m2]], g2 = O2[E2 + o2[m2]]) : (y2 = 96, g2 = 0), u2 = 1 << b2 - k2, w2 = l2 = 1 << A2;
      do {
        i2[h2 + (I2 >> k2) + (l2 -= u2)] = p2 << 24 | y2 << 16 | g2 | 0;
      } while (0 !== l2);
      for (u2 = 1 << b2 - 1; I2 & u2; )
        u2 >>= 1;
      if (0 !== u2 ? (I2 &= u2 - 1, I2 += u2) : I2 = 0, m2++, 0 == --B2[b2]) {
        if (b2 === S2)
          break;
        b2 = t2[r2 + o2[m2]];
      }
      if (b2 > x2 && (I2 & f2) !== c2) {
        for (0 === k2 && (k2 = x2), h2 += w2, C2 = 1 << (A2 = b2 - k2); A2 + k2 < S2 && !((C2 -= B2[A2 + k2]) <= 0); )
          A2++, C2 <<= 1;
        if (P2 += 1 << A2, 1 === e2 && P2 > 852 || 2 === e2 && P2 > 592)
          return 1;
        i2[c2 = I2 & f2] = x2 << 24 | A2 << 16 | h2 - a2 | 0;
      }
    }
    return 0 !== I2 && (i2[h2 + I2] = b2 - k2 << 24 | 64 << 16 | 0), s2.bits = x2, 0;
  };
  function Mf(e2) {
    return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
  }
  function Ff() {
    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new hc.Buf16(320), this.work = new hc.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function Rf(e2) {
    var t2;
    return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = 1, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new hc.Buf32(852), t2.distcode = t2.distdyn = new hc.Buf32(592), t2.sane = 1, t2.back = -1, 0) : -2;
  }
  function Nf(e2) {
    var t2;
    return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, Rf(e2)) : -2;
  }
  function qf(e2, t2) {
    var r2, n2;
    return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || t2 > 15) ? -2 : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, Nf(e2))) : -2;
  }
  function Gf(e2, t2) {
    var r2, n2;
    return e2 ? (n2 = new Ff(), e2.state = n2, n2.window = null, 0 !== (r2 = qf(e2, t2)) && (e2.state = null), r2) : -2;
  }
  var Vf, _f, Wf = true;
  function Hf(e2) {
    if (Wf) {
      var t2;
      for (Vf = new hc.Buf32(512), _f = new hc.Buf32(32), t2 = 0; t2 < 144; )
        e2.lens[t2++] = 8;
      for (; t2 < 256; )
        e2.lens[t2++] = 9;
      for (; t2 < 280; )
        e2.lens[t2++] = 7;
      for (; t2 < 288; )
        e2.lens[t2++] = 8;
      for (jf(1, e2.lens, 0, 288, Vf, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
        e2.lens[t2++] = 5;
      jf(2, e2.lens, 0, 32, _f, 0, e2.work, { bits: 5 }), Wf = false;
    }
    e2.lencode = Vf, e2.lenbits = 9, e2.distcode = _f, e2.distbits = 5;
  }
  function Yf(e2, t2, r2, n2) {
    var i2, a2 = e2.state;
    return null === a2.window && (a2.wsize = 1 << a2.wbits, a2.wnext = 0, a2.whave = 0, a2.window = new hc.Buf8(a2.wsize)), n2 >= a2.wsize ? (hc.arraySet(a2.window, t2, r2 - a2.wsize, a2.wsize, 0), a2.wnext = 0, a2.whave = a2.wsize) : ((i2 = a2.wsize - a2.wnext) > n2 && (i2 = n2), hc.arraySet(a2.window, t2, r2 - n2, i2, a2.wnext), (n2 -= i2) ? (hc.arraySet(a2.window, t2, r2 - n2, n2, 0), a2.wnext = n2, a2.whave = a2.wsize) : (a2.wnext += i2, a2.wnext === a2.wsize && (a2.wnext = 0), a2.whave < a2.wsize && (a2.whave += i2))), 0;
  }
  var Xf = { inflateReset: Nf, inflateReset2: qf, inflateResetKeep: Rf, inflateInit: function(e2) {
    return Gf(e2, 15);
  }, inflateInit2: Gf, inflate: function(e2, t2) {
    var r2, n2, i2, a2, o2, s2, u2, l2, c2, f2, h2, d2, p2, y2, g2, v2, b2, m2, w2, S2, x2, A2, k2, C2, P2 = 0, I2 = new hc.Buf8(4), O2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
      return -2;
    12 === (r2 = e2.state).mode && (r2.mode = 13), o2 = e2.next_out, i2 = e2.output, u2 = e2.avail_out, a2 = e2.next_in, n2 = e2.input, s2 = e2.avail_in, l2 = r2.hold, c2 = r2.bits, f2 = s2, h2 = u2, A2 = 0;
    e:
      for (; ; )
        switch (r2.mode) {
          case 1:
            if (0 === r2.wrap) {
              r2.mode = 13;
              break;
            }
            for (; c2 < 16; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            if (2 & r2.wrap && 35615 === l2) {
              r2.check = 0, I2[0] = 255 & l2, I2[1] = l2 >>> 8 & 255, r2.check = Zc(r2.check, I2, 2, 0), l2 = 0, c2 = 0, r2.mode = 2;
              break;
            }
            if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & l2) << 8) + (l2 >> 8)) % 31) {
              e2.msg = "incorrect header check", r2.mode = 30;
              break;
            }
            if (8 != (15 & l2)) {
              e2.msg = "unknown compression method", r2.mode = 30;
              break;
            }
            if (c2 -= 4, x2 = 8 + (15 & (l2 >>>= 4)), 0 === r2.wbits)
              r2.wbits = x2;
            else if (x2 > r2.wbits) {
              e2.msg = "invalid window size", r2.mode = 30;
              break;
            }
            r2.dmax = 1 << x2, e2.adler = r2.check = 1, r2.mode = 512 & l2 ? 10 : 12, l2 = 0, c2 = 0;
            break;
          case 2:
            for (; c2 < 16; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            if (r2.flags = l2, 8 != (255 & r2.flags)) {
              e2.msg = "unknown compression method", r2.mode = 30;
              break;
            }
            if (57344 & r2.flags) {
              e2.msg = "unknown header flags set", r2.mode = 30;
              break;
            }
            r2.head && (r2.head.text = l2 >> 8 & 1), 512 & r2.flags && (I2[0] = 255 & l2, I2[1] = l2 >>> 8 & 255, r2.check = Zc(r2.check, I2, 2, 0)), l2 = 0, c2 = 0, r2.mode = 3;
          case 3:
            for (; c2 < 32; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            r2.head && (r2.head.time = l2), 512 & r2.flags && (I2[0] = 255 & l2, I2[1] = l2 >>> 8 & 255, I2[2] = l2 >>> 16 & 255, I2[3] = l2 >>> 24 & 255, r2.check = Zc(r2.check, I2, 4, 0)), l2 = 0, c2 = 0, r2.mode = 4;
          case 4:
            for (; c2 < 16; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            r2.head && (r2.head.xflags = 255 & l2, r2.head.os = l2 >> 8), 512 & r2.flags && (I2[0] = 255 & l2, I2[1] = l2 >>> 8 & 255, r2.check = Zc(r2.check, I2, 2, 0)), l2 = 0, c2 = 0, r2.mode = 5;
          case 5:
            if (1024 & r2.flags) {
              for (; c2 < 16; ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              r2.length = l2, r2.head && (r2.head.extra_len = l2), 512 & r2.flags && (I2[0] = 255 & l2, I2[1] = l2 >>> 8 & 255, r2.check = Zc(r2.check, I2, 2, 0)), l2 = 0, c2 = 0;
            } else
              r2.head && (r2.head.extra = null);
            r2.mode = 6;
          case 6:
            if (1024 & r2.flags && ((d2 = r2.length) > s2 && (d2 = s2), d2 && (r2.head && (x2 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), hc.arraySet(r2.head.extra, n2, a2, d2, x2)), 512 & r2.flags && (r2.check = Zc(r2.check, n2, d2, a2)), s2 -= d2, a2 += d2, r2.length -= d2), r2.length))
              break e;
            r2.length = 0, r2.mode = 7;
          case 7:
            if (2048 & r2.flags) {
              if (0 === s2)
                break e;
              d2 = 0;
              do {
                x2 = n2[a2 + d2++], r2.head && x2 && r2.length < 65536 && (r2.head.name += String.fromCharCode(x2));
              } while (x2 && d2 < s2);
              if (512 & r2.flags && (r2.check = Zc(r2.check, n2, d2, a2)), s2 -= d2, a2 += d2, x2)
                break e;
            } else
              r2.head && (r2.head.name = null);
            r2.length = 0, r2.mode = 8;
          case 8:
            if (4096 & r2.flags) {
              if (0 === s2)
                break e;
              d2 = 0;
              do {
                x2 = n2[a2 + d2++], r2.head && x2 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(x2));
              } while (x2 && d2 < s2);
              if (512 & r2.flags && (r2.check = Zc(r2.check, n2, d2, a2)), s2 -= d2, a2 += d2, x2)
                break e;
            } else
              r2.head && (r2.head.comment = null);
            r2.mode = 9;
          case 9:
            if (512 & r2.flags) {
              for (; c2 < 16; ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              if (l2 !== (65535 & r2.check)) {
                e2.msg = "header crc mismatch", r2.mode = 30;
                break;
              }
              l2 = 0, c2 = 0;
            }
            r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
            break;
          case 10:
            for (; c2 < 32; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            e2.adler = r2.check = Mf(l2), l2 = 0, c2 = 0, r2.mode = 11;
          case 11:
            if (0 === r2.havedict)
              return e2.next_out = o2, e2.avail_out = u2, e2.next_in = a2, e2.avail_in = s2, r2.hold = l2, r2.bits = c2, 2;
            e2.adler = r2.check = 1, r2.mode = 12;
          case 12:
            if (5 === t2 || 6 === t2)
              break e;
          case 13:
            if (r2.last) {
              l2 >>>= 7 & c2, c2 -= 7 & c2, r2.mode = 27;
              break;
            }
            for (; c2 < 3; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            switch (r2.last = 1 & l2, c2 -= 1, 3 & (l2 >>>= 1)) {
              case 0:
                r2.mode = 14;
                break;
              case 1:
                if (Hf(r2), r2.mode = 20, 6 === t2) {
                  l2 >>>= 2, c2 -= 2;
                  break e;
                }
                break;
              case 2:
                r2.mode = 17;
                break;
              case 3:
                e2.msg = "invalid block type", r2.mode = 30;
            }
            l2 >>>= 2, c2 -= 2;
            break;
          case 14:
            for (l2 >>>= 7 & c2, c2 -= 7 & c2; c2 < 32; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            if ((65535 & l2) != (l2 >>> 16 ^ 65535)) {
              e2.msg = "invalid stored block lengths", r2.mode = 30;
              break;
            }
            if (r2.length = 65535 & l2, l2 = 0, c2 = 0, r2.mode = 15, 6 === t2)
              break e;
          case 15:
            r2.mode = 16;
          case 16:
            if (d2 = r2.length) {
              if (d2 > s2 && (d2 = s2), d2 > u2 && (d2 = u2), 0 === d2)
                break e;
              hc.arraySet(i2, n2, a2, d2, o2), s2 -= d2, a2 += d2, u2 -= d2, o2 += d2, r2.length -= d2;
              break;
            }
            r2.mode = 12;
            break;
          case 17:
            for (; c2 < 14; ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            if (r2.nlen = 257 + (31 & l2), l2 >>>= 5, c2 -= 5, r2.ndist = 1 + (31 & l2), l2 >>>= 5, c2 -= 5, r2.ncode = 4 + (15 & l2), l2 >>>= 4, c2 -= 4, r2.nlen > 286 || r2.ndist > 30) {
              e2.msg = "too many length or distance symbols", r2.mode = 30;
              break;
            }
            r2.have = 0, r2.mode = 18;
          case 18:
            for (; r2.have < r2.ncode; ) {
              for (; c2 < 3; ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              r2.lens[O2[r2.have++]] = 7 & l2, l2 >>>= 3, c2 -= 3;
            }
            for (; r2.have < 19; )
              r2.lens[O2[r2.have++]] = 0;
            if (r2.lencode = r2.lendyn, r2.lenbits = 7, k2 = { bits: r2.lenbits }, A2 = jf(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, k2), r2.lenbits = k2.bits, A2) {
              e2.msg = "invalid code lengths set", r2.mode = 30;
              break;
            }
            r2.have = 0, r2.mode = 19;
          case 19:
            for (; r2.have < r2.nlen + r2.ndist; ) {
              for (; v2 = (P2 = r2.lencode[l2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & P2, !((g2 = P2 >>> 24) <= c2); ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              if (b2 < 16)
                l2 >>>= g2, c2 -= g2, r2.lens[r2.have++] = b2;
              else {
                if (16 === b2) {
                  for (C2 = g2 + 2; c2 < C2; ) {
                    if (0 === s2)
                      break e;
                    s2--, l2 += n2[a2++] << c2, c2 += 8;
                  }
                  if (l2 >>>= g2, c2 -= g2, 0 === r2.have) {
                    e2.msg = "invalid bit length repeat", r2.mode = 30;
                    break;
                  }
                  x2 = r2.lens[r2.have - 1], d2 = 3 + (3 & l2), l2 >>>= 2, c2 -= 2;
                } else if (17 === b2) {
                  for (C2 = g2 + 3; c2 < C2; ) {
                    if (0 === s2)
                      break e;
                    s2--, l2 += n2[a2++] << c2, c2 += 8;
                  }
                  c2 -= g2, x2 = 0, d2 = 3 + (7 & (l2 >>>= g2)), l2 >>>= 3, c2 -= 3;
                } else {
                  for (C2 = g2 + 7; c2 < C2; ) {
                    if (0 === s2)
                      break e;
                    s2--, l2 += n2[a2++] << c2, c2 += 8;
                  }
                  c2 -= g2, x2 = 0, d2 = 11 + (127 & (l2 >>>= g2)), l2 >>>= 7, c2 -= 7;
                }
                if (r2.have + d2 > r2.nlen + r2.ndist) {
                  e2.msg = "invalid bit length repeat", r2.mode = 30;
                  break;
                }
                for (; d2--; )
                  r2.lens[r2.have++] = x2;
              }
            }
            if (30 === r2.mode)
              break;
            if (0 === r2.lens[256]) {
              e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
              break;
            }
            if (r2.lenbits = 9, k2 = { bits: r2.lenbits }, A2 = jf(1, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, k2), r2.lenbits = k2.bits, A2) {
              e2.msg = "invalid literal/lengths set", r2.mode = 30;
              break;
            }
            if (r2.distbits = 6, r2.distcode = r2.distdyn, k2 = { bits: r2.distbits }, A2 = jf(2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, k2), r2.distbits = k2.bits, A2) {
              e2.msg = "invalid distances set", r2.mode = 30;
              break;
            }
            if (r2.mode = 20, 6 === t2)
              break e;
          case 20:
            r2.mode = 21;
          case 21:
            if (s2 >= 6 && u2 >= 258) {
              e2.next_out = o2, e2.avail_out = u2, e2.next_in = a2, e2.avail_in = s2, r2.hold = l2, r2.bits = c2, Tf(e2, h2), o2 = e2.next_out, i2 = e2.output, u2 = e2.avail_out, a2 = e2.next_in, n2 = e2.input, s2 = e2.avail_in, l2 = r2.hold, c2 = r2.bits, 12 === r2.mode && (r2.back = -1);
              break;
            }
            for (r2.back = 0; v2 = (P2 = r2.lencode[l2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & P2, !((g2 = P2 >>> 24) <= c2); ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            if (v2 && 0 == (240 & v2)) {
              for (m2 = g2, w2 = v2, S2 = b2; v2 = (P2 = r2.lencode[S2 + ((l2 & (1 << m2 + w2) - 1) >> m2)]) >>> 16 & 255, b2 = 65535 & P2, !(m2 + (g2 = P2 >>> 24) <= c2); ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              l2 >>>= m2, c2 -= m2, r2.back += m2;
            }
            if (l2 >>>= g2, c2 -= g2, r2.back += g2, r2.length = b2, 0 === v2) {
              r2.mode = 26;
              break;
            }
            if (32 & v2) {
              r2.back = -1, r2.mode = 12;
              break;
            }
            if (64 & v2) {
              e2.msg = "invalid literal/length code", r2.mode = 30;
              break;
            }
            r2.extra = 15 & v2, r2.mode = 22;
          case 22:
            if (r2.extra) {
              for (C2 = r2.extra; c2 < C2; ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              r2.length += l2 & (1 << r2.extra) - 1, l2 >>>= r2.extra, c2 -= r2.extra, r2.back += r2.extra;
            }
            r2.was = r2.length, r2.mode = 23;
          case 23:
            for (; v2 = (P2 = r2.distcode[l2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b2 = 65535 & P2, !((g2 = P2 >>> 24) <= c2); ) {
              if (0 === s2)
                break e;
              s2--, l2 += n2[a2++] << c2, c2 += 8;
            }
            if (0 == (240 & v2)) {
              for (m2 = g2, w2 = v2, S2 = b2; v2 = (P2 = r2.distcode[S2 + ((l2 & (1 << m2 + w2) - 1) >> m2)]) >>> 16 & 255, b2 = 65535 & P2, !(m2 + (g2 = P2 >>> 24) <= c2); ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              l2 >>>= m2, c2 -= m2, r2.back += m2;
            }
            if (l2 >>>= g2, c2 -= g2, r2.back += g2, 64 & v2) {
              e2.msg = "invalid distance code", r2.mode = 30;
              break;
            }
            r2.offset = b2, r2.extra = 15 & v2, r2.mode = 24;
          case 24:
            if (r2.extra) {
              for (C2 = r2.extra; c2 < C2; ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              r2.offset += l2 & (1 << r2.extra) - 1, l2 >>>= r2.extra, c2 -= r2.extra, r2.back += r2.extra;
            }
            if (r2.offset > r2.dmax) {
              e2.msg = "invalid distance too far back", r2.mode = 30;
              break;
            }
            r2.mode = 25;
          case 25:
            if (0 === u2)
              break e;
            if (d2 = h2 - u2, r2.offset > d2) {
              if ((d2 = r2.offset - d2) > r2.whave && r2.sane) {
                e2.msg = "invalid distance too far back", r2.mode = 30;
                break;
              }
              d2 > r2.wnext ? (d2 -= r2.wnext, p2 = r2.wsize - d2) : p2 = r2.wnext - d2, d2 > r2.length && (d2 = r2.length), y2 = r2.window;
            } else
              y2 = i2, p2 = o2 - r2.offset, d2 = r2.length;
            d2 > u2 && (d2 = u2), u2 -= d2, r2.length -= d2;
            do {
              i2[o2++] = y2[p2++];
            } while (--d2);
            0 === r2.length && (r2.mode = 21);
            break;
          case 26:
            if (0 === u2)
              break e;
            i2[o2++] = r2.length, u2--, r2.mode = 21;
            break;
          case 27:
            if (r2.wrap) {
              for (; c2 < 32; ) {
                if (0 === s2)
                  break e;
                s2--, l2 |= n2[a2++] << c2, c2 += 8;
              }
              if (h2 -= u2, e2.total_out += h2, r2.total += h2, h2 && (e2.adler = r2.check = r2.flags ? Zc(r2.check, i2, h2, o2 - h2) : Hc(r2.check, i2, h2, o2 - h2)), h2 = u2, (r2.flags ? l2 : Mf(l2)) !== r2.check) {
                e2.msg = "incorrect data check", r2.mode = 30;
                break;
              }
              l2 = 0, c2 = 0;
            }
            r2.mode = 28;
          case 28:
            if (r2.wrap && r2.flags) {
              for (; c2 < 32; ) {
                if (0 === s2)
                  break e;
                s2--, l2 += n2[a2++] << c2, c2 += 8;
              }
              if (l2 !== (4294967295 & r2.total)) {
                e2.msg = "incorrect length check", r2.mode = 30;
                break;
              }
              l2 = 0, c2 = 0;
            }
            r2.mode = 29;
          case 29:
            A2 = 1;
            break e;
          case 30:
            A2 = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return -2;
        }
    return e2.next_out = o2, e2.avail_out = u2, e2.next_in = a2, e2.avail_in = s2, r2.hold = l2, r2.bits = c2, (r2.wsize || h2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Yf(e2, e2.output, e2.next_out, h2 - e2.avail_out), f2 -= e2.avail_in, h2 -= e2.avail_out, e2.total_in += f2, e2.total_out += h2, r2.total += h2, r2.wrap && h2 && (e2.adler = r2.check = r2.flags ? Zc(r2.check, i2, h2, e2.next_out - h2) : Hc(r2.check, i2, h2, e2.next_out - h2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 === f2 && 0 === h2 || 4 === t2) && 0 === A2 && (A2 = -5), A2;
  }, inflateEnd: function(e2) {
    if (!e2 || !e2.state)
      return -2;
    var t2 = e2.state;
    return t2.window && (t2.window = null), e2.state = null, 0;
  }, inflateGetHeader: function(e2, t2) {
    var r2;
    return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? -2 : (r2.head = t2, t2.done = false, 0) : -2;
  }, inflateSetDictionary: function(e2, t2) {
    var r2, n2 = t2.length;
    return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? -2 : 11 === r2.mode && Hc(1, t2, n2, 0) !== r2.check ? -3 : Yf(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, 0) : -2;
  }, inflateInfo: "pako inflate (from Nodeca project)" }, Zf = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  var Kf = function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
  }, Jf = Object.prototype.toString;
  function Qf(e2) {
    if (!(this instanceof Qf))
      return new Qf(e2);
    this.options = hc.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
    var t2 = this.options;
    t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Pf(), this.strm.avail_out = 0;
    var r2 = Xf.inflateInit2(this.strm, t2.windowBits);
    if (r2 !== Zf.Z_OK)
      throw new Error(Kc[r2]);
    if (this.header = new Kf(), Xf.inflateGetHeader(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = Sf(t2.dictionary) : "[object ArrayBuffer]" === Jf.call(t2.dictionary) && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (r2 = Xf.inflateSetDictionary(this.strm, t2.dictionary)) !== Zf.Z_OK))
      throw new Error(Kc[r2]);
  }
  function $f(e2, t2) {
    var r2 = new Qf(t2);
    if (r2.push(e2, true), r2.err)
      throw r2.msg || Kc[r2.err];
    return r2.result;
  }
  Qf.prototype.push = function(e2, t2) {
    var r2, n2, i2, a2, o2, s2 = this.strm, u2 = this.options.chunkSize, l2 = this.options.dictionary, c2 = false;
    if (this.ended)
      return false;
    n2 = t2 === ~~t2 ? t2 : true === t2 ? Zf.Z_FINISH : Zf.Z_NO_FLUSH, "string" == typeof e2 ? s2.input = Af(e2) : "[object ArrayBuffer]" === Jf.call(e2) ? s2.input = new Uint8Array(e2) : s2.input = e2, s2.next_in = 0, s2.avail_in = s2.input.length;
    do {
      if (0 === s2.avail_out && (s2.output = new hc.Buf8(u2), s2.next_out = 0, s2.avail_out = u2), (r2 = Xf.inflate(s2, Zf.Z_NO_FLUSH)) === Zf.Z_NEED_DICT && l2 && (r2 = Xf.inflateSetDictionary(this.strm, l2)), r2 === Zf.Z_BUF_ERROR && true === c2 && (r2 = Zf.Z_OK, c2 = false), r2 !== Zf.Z_STREAM_END && r2 !== Zf.Z_OK)
        return this.onEnd(r2), this.ended = true, false;
      s2.next_out && (0 !== s2.avail_out && r2 !== Zf.Z_STREAM_END && (0 !== s2.avail_in || n2 !== Zf.Z_FINISH && n2 !== Zf.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = Cf(s2.output, s2.next_out), a2 = s2.next_out - i2, o2 = kf(s2.output, i2), s2.next_out = a2, s2.avail_out = u2 - a2, a2 && hc.arraySet(s2.output, s2.output, i2, a2, 0), this.onData(o2)) : this.onData(hc.shrinkBuf(s2.output, s2.next_out)))), 0 === s2.avail_in && 0 === s2.avail_out && (c2 = true);
    } while ((s2.avail_in > 0 || 0 === s2.avail_out) && r2 !== Zf.Z_STREAM_END);
    return r2 === Zf.Z_STREAM_END && (n2 = Zf.Z_FINISH), n2 === Zf.Z_FINISH ? (r2 = Xf.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === Zf.Z_OK) : n2 !== Zf.Z_SYNC_FLUSH || (this.onEnd(Zf.Z_OK), s2.avail_out = 0, true);
  }, Qf.prototype.onData = function(e2) {
    this.chunks.push(e2);
  }, Qf.prototype.onEnd = function(e2) {
    e2 === Zf.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = hc.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
  };
  var eh = { Inflate: Qf, inflate: $f, inflateRaw: function(e2, t2) {
    return (t2 = t2 || {}).raw = true, $f(e2, t2);
  }, ungzip: $f }, th = {};
  (0, hc.assign)(th, Bf, eh, Zf);
  var rh = th, nh = t(function(e2, t2) {
    !function() {
      for (var e3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r2 = new Uint8Array(256), n2 = 0; n2 < e3.length; n2++)
        r2[e3.charCodeAt(n2)] = n2;
      t2.encode = function(t3) {
        var r3, n3 = new Uint8Array(t3), i2 = n3.length, a2 = "";
        for (r3 = 0; r3 < i2; r3 += 3)
          a2 += e3[n3[r3] >> 2], a2 += e3[(3 & n3[r3]) << 4 | n3[r3 + 1] >> 4], a2 += e3[(15 & n3[r3 + 1]) << 2 | n3[r3 + 2] >> 6], a2 += e3[63 & n3[r3 + 2]];
        return i2 % 3 == 2 ? a2 = a2.substring(0, a2.length - 1) + "=" : i2 % 3 == 1 && (a2 = a2.substring(0, a2.length - 2) + "=="), a2;
      }, t2.decode = function(e4) {
        var t3, n3, i2, a2, o2, s2 = 0.75 * e4.length, u2 = e4.length, l2 = 0;
        "=" === e4[e4.length - 1] && (s2--, "=" === e4[e4.length - 2] && s2--);
        var c2 = new ArrayBuffer(s2), f2 = new Uint8Array(c2);
        for (t3 = 0; t3 < u2; t3 += 4)
          n3 = r2[e4.charCodeAt(t3)], i2 = r2[e4.charCodeAt(t3 + 1)], a2 = r2[e4.charCodeAt(t3 + 2)], o2 = r2[e4.charCodeAt(t3 + 3)], f2[l2++] = n3 << 2 | i2 >> 4, f2[l2++] = (15 & i2) << 4 | a2 >> 2, f2[l2++] = (3 & a2) << 6 | 63 & o2;
        return c2;
      };
    }();
  }), ih = (nh.encode, nh.decode), ah = JSON.parse(String.fromCharCode.apply(String, rh.inflate(ih("eJxtVtty4zYM/Rc/70Ni97LbN1tJ49SXeGI3O93OjgayGBERRXoo0h5Np/9eAKTcpNOHECAFAgfAAZ2/JkcIqnEeVT/55c9JcZx8mnzradk5Wva83clW8bZjraZly8s68lnLZ2y3Nrzla2tedkhL8crGsmVtHXhhLxvLCzvd8N0t3/0my4mvccjCTb5/mhxdV6FF2xQG+j6h3LpQPivna+UVA5lX7qxGWT5joznOQhl34dMQ4KhVXX78fD0e7Z7OyhsYSHt0Acp9rPqjxxPb3rlYGXW1zNsxrBz/61eirNUrb4qiuL3J8jbLaZazLH/I8scsf8ry5yw/Z/klyWn2N83+ptnfNPubZn/T7G+W7WfZfjbaZ//T7H+a/c+yn1n2Mxv9MK5tbAOQfEEPHaQPn7PhlzHBmzGzmzGFaw4j2Nsx2u0I71ZwfezVtba5mlmswEL54vBIrMjYGVtqAFEmtS3x2XWdY6qtISDLhTu5zr0yIx+tVh6DMOjBK9UK504BmZDF4NEYUee+UxaBby9V5ZVwykMlH/dkB6wcNBAsLlErk0PlIedyawO2BrG+U2cyauiLpGYbMKw9RN/FVif1DTxhZT56HNjhATrkyTgoE5uY8rdQg3gmwtIfT9QerSY1QUFJmYEcsFIZxgCWQHEQmp0mZwS2iez9Pmh0p5Q71cW1istfENyaLLkfHhu0wLZPjZaQz9HKhQOlZFyT3EXrOO4iaqzTtwrshXGtdKc4/MbZxpkUf41dFcUMqctcPnUpZROl/ZFiql5li0OKu6Cy5dN9pNpmfQEBWqHJ6ag54JMpC42tFNsD9ZOtHgxw9NTmA75STo1O0HklYjepkSt2l9Q/pJ7YM9IXKe4CuihVH4wLWG6hkZ7uNDR9uQNhQPTQ6+CTrwF0uWaTZ/UGwtvf4DwiL1JenOILKub4RqmgsNzAILy00RiBYBX4csHqcEwVLIhNojyZunwMkEj74Kifx3y6U76Tze9MvfD+vE937wiHl8B7Defsr+/ACgPvTQV9DhaP0Ash6MyOPRRUcxmbk0fHfh67E00XmHLOL4WE3IHpBq+stBkqKq/KHKQiWameo0nLea2HOikbYiODLpdIWmOGk+7fHxeRspDHYqXBOyq5TBInuHcx6FKG9VqirfMfzmg6keiSoMzPqk/T8mjTM4KOOE8dpUv4vx+0oYIx+B5MUP7dCUc7RN9e672Mthm7RYTUHQo1MAHeO0+/Oo7qlp41DW2XhlwDUQZTc3ya/JV2b0LsTTQhfVzpWMOFxlXeM7BBZuCAXkd5s/dY14lnGydGB2iFtHPt+PQr+bZNWaC8PjuIpNpyCUz6IlqFr86z3X0zUPZEgY/9mFsIMtX/7ZOX54B+vOnRBi2uNVx0uaSXmRPdoDxUd/Fk3CC12WNjvzJR03dla1WusIU2Ir/vCi7yX4DQiCMzeOYR/f06+f73P0+ms+k=")))), oh = new fc(rh.inflate(ih("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"))), sh = Math.log2 || function(e2) {
    return Math.log(e2) / Math.LN2;
  }, uh = function(e2) {
    return sh(e2) + 1 | 0;
  }, lh = uh(ah.categories.length - 1), ch = uh(ah.combiningClasses.length - 1), fh = uh(ah.scripts.length - 1), hh = uh(ah.eaw.length - 1), dh = ch + fh + hh + 10, ph = fh + hh + 10, yh = hh + 10, gh = (1 << lh) - 1, vh = (1 << ch) - 1, bh = (1 << fh) - 1, mh = function(e2) {
    var t2 = oh.get(e2);
    return ah.categories[t2 >> dh & gh];
  }, wh = mh, Sh = function(e2) {
    var t2 = oh.get(e2);
    return ah.combiningClasses[t2 >> ph & vh];
  }, xh = function(e2) {
    var t2 = oh.get(e2);
    return ah.scripts[t2 >> yh & bh];
  }, Ah = function(e2) {
    return "Nd" === mh(e2);
  }, kh = function(e2) {
    var t2 = mh(e2);
    return "Mn" === t2 || "Me" === t2 || "Mc" === t2;
  }, Ch = function() {
    function e2(e3) {
      this.font = e3;
    }
    var t2 = e2.prototype;
    return t2.positionGlyphs = function(e3, t3) {
      for (var r2 = 0, n2 = 0, i2 = 0; i2 < e3.length; i2++) {
        e3[i2].isMark ? n2 = i2 : (r2 !== n2 && this.positionCluster(e3, t3, r2, n2), r2 = n2 = i2);
      }
      return r2 !== n2 && this.positionCluster(e3, t3, r2, n2), t3;
    }, t2.positionCluster = function(e3, t3, r2, n2) {
      var i2 = e3[r2], a2 = i2.cbox.copy();
      i2.codePoints.length > 1 && (a2.minX += (i2.codePoints.length - 1) * a2.width / i2.codePoints.length);
      for (var o2 = -t3[r2].xAdvance, s2 = 0, u2 = this.font.unitsPerEm / 16, l2 = r2 + 1; l2 <= n2; l2++) {
        var c2 = e3[l2], f2 = c2.cbox, h2 = t3[l2], d2 = this.getCombiningClass(c2.codePoints[0]);
        if ("Not_Reordered" !== d2) {
          switch (h2.xOffset = h2.yOffset = 0, d2) {
            case "Double_Above":
            case "Double_Below":
              h2.xOffset += a2.minX - f2.width / 2 - f2.minX;
              break;
            case "Attached_Below_Left":
            case "Below_Left":
            case "Above_Left":
              h2.xOffset += a2.minX - f2.minX;
              break;
            case "Attached_Above_Right":
            case "Below_Right":
            case "Above_Right":
              h2.xOffset += a2.maxX - f2.width - f2.minX;
              break;
            default:
              h2.xOffset += a2.minX + (a2.width - f2.width) / 2 - f2.minX;
          }
          switch (d2) {
            case "Double_Below":
            case "Below_Left":
            case "Below":
            case "Below_Right":
            case "Attached_Below_Left":
            case "Attached_Below":
              "Attached_Below_Left" !== d2 && "Attached_Below" !== d2 || (a2.minY += u2), h2.yOffset = -a2.minY - f2.maxY, a2.minY += f2.height;
              break;
            case "Double_Above":
            case "Above_Left":
            case "Above":
            case "Above_Right":
            case "Attached_Above":
            case "Attached_Above_Right":
              "Attached_Above" !== d2 && "Attached_Above_Right" !== d2 || (a2.maxY += u2), h2.yOffset = a2.maxY - f2.minY, a2.maxY += f2.height;
          }
          h2.xAdvance = h2.yAdvance = 0, h2.xOffset += o2, h2.yOffset += s2;
        } else
          o2 -= h2.xAdvance, s2 -= h2.yAdvance;
      }
    }, t2.getCombiningClass = function(e3) {
      var t3 = Sh(e3);
      if (3584 == (-256 & e3)) {
        if ("Not_Reordered" === t3)
          switch (e3) {
            case 3633:
            case 3636:
            case 3637:
            case 3638:
            case 3639:
            case 3655:
            case 3660:
            case 3645:
            case 3662:
              return "Above_Right";
            case 3761:
            case 3764:
            case 3765:
            case 3766:
            case 3767:
            case 3771:
            case 3788:
            case 3789:
              return "Above";
            case 3772:
              return "Below";
          }
        else if (3642 === e3)
          return "Below_Right";
      }
      switch (t3) {
        case "CCC10":
        case "CCC11":
        case "CCC12":
        case "CCC13":
        case "CCC14":
        case "CCC15":
        case "CCC16":
        case "CCC17":
        case "CCC18":
        case "CCC20":
        case "CCC22":
          return "Below";
        case "CCC23":
          return "Attached_Above";
        case "CCC24":
          return "Above_Right";
        case "CCC25":
        case "CCC19":
          return "Above_Left";
        case "CCC26":
          return "Above";
        case "CCC21":
          break;
        case "CCC27":
        case "CCC28":
        case "CCC30":
        case "CCC31":
        case "CCC33":
        case "CCC34":
        case "CCC35":
        case "CCC36":
          return "Above";
        case "CCC29":
        case "CCC32":
          return "Below";
        case "CCC103":
          return "Below_Right";
        case "CCC107":
          return "Above_Right";
        case "CCC118":
          return "Below";
        case "CCC122":
          return "Above";
        case "CCC129":
        case "CCC132":
          return "Below";
        case "CCC130":
          return "Above";
      }
      return t3;
    }, e2;
  }();
  function Ph(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  var Ih = function() {
    function e2(e3, t3, r3, n2) {
      void 0 === e3 && (e3 = 1 / 0), void 0 === t3 && (t3 = 1 / 0), void 0 === r3 && (r3 = -1 / 0), void 0 === n2 && (n2 = -1 / 0), this.minX = e3, this.minY = t3, this.maxX = r3, this.maxY = n2;
    }
    var t2, r2, i2 = e2.prototype;
    return i2.addPoint = function(e3, t3) {
      Math.abs(e3) !== 1 / 0 && (e3 < this.minX && (this.minX = e3), e3 > this.maxX && (this.maxX = e3)), Math.abs(t3) !== 1 / 0 && (t3 < this.minY && (this.minY = t3), t3 > this.maxY && (this.maxY = t3));
    }, i2.copy = function() {
      return new e2(this.minX, this.minY, this.maxX, this.maxY);
    }, t2 = e2, (r2 = [{ key: "width", get: function() {
      return this.maxX - this.minX;
    } }, { key: "height", get: function() {
      return this.maxY - this.minY;
    } }]) && Ph(t2.prototype, r2), e2;
  }();
  function Oh(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Eh(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Eh(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Eh(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Bh = { Caucasian_Albanian: "aghb", Arabic: "arab", Imperial_Aramaic: "armi", Armenian: "armn", Avestan: "avst", Balinese: "bali", Bamum: "bamu", Bassa_Vah: "bass", Batak: "batk", Bengali: ["bng2", "beng"], Bopomofo: "bopo", Brahmi: "brah", Braille: "brai", Buginese: "bugi", Buhid: "buhd", Chakma: "cakm", Canadian_Aboriginal: "cans", Carian: "cari", Cham: "cham", Cherokee: "cher", Coptic: "copt", Cypriot: "cprt", Cyrillic: "cyrl", Devanagari: ["dev2", "deva"], Deseret: "dsrt", Duployan: "dupl", Egyptian_Hieroglyphs: "egyp", Elbasan: "elba", Ethiopic: "ethi", Georgian: "geor", Glagolitic: "glag", Gothic: "goth", Grantha: "gran", Greek: "grek", Gujarati: ["gjr2", "gujr"], Gurmukhi: ["gur2", "guru"], Hangul: "hang", Han: "hani", Hanunoo: "hano", Hebrew: "hebr", Hiragana: "hira", Pahawh_Hmong: "hmng", Katakana_Or_Hiragana: "hrkt", Old_Italic: "ital", Javanese: "java", Kayah_Li: "kali", Katakana: "kana", Kharoshthi: "khar", Khmer: "khmr", Khojki: "khoj", Kannada: ["knd2", "knda"], Kaithi: "kthi", Tai_Tham: "lana", Lao: "lao ", Latin: "latn", Lepcha: "lepc", Limbu: "limb", Linear_A: "lina", Linear_B: "linb", Lisu: "lisu", Lycian: "lyci", Lydian: "lydi", Mahajani: "mahj", Mandaic: "mand", Manichaean: "mani", Mende_Kikakui: "mend", Meroitic_Cursive: "merc", Meroitic_Hieroglyphs: "mero", Malayalam: ["mlm2", "mlym"], Modi: "modi", Mongolian: "mong", Mro: "mroo", Meetei_Mayek: "mtei", Myanmar: ["mym2", "mymr"], Old_North_Arabian: "narb", Nabataean: "nbat", Nko: "nko ", Ogham: "ogam", Ol_Chiki: "olck", Old_Turkic: "orkh", Oriya: ["ory2", "orya"], Osmanya: "osma", Palmyrene: "palm", Pau_Cin_Hau: "pauc", Old_Permic: "perm", Phags_Pa: "phag", Inscriptional_Pahlavi: "phli", Psalter_Pahlavi: "phlp", Phoenician: "phnx", Miao: "plrd", Inscriptional_Parthian: "prti", Rejang: "rjng", Runic: "runr", Samaritan: "samr", Old_South_Arabian: "sarb", Saurashtra: "saur", Shavian: "shaw", Sharada: "shrd", Siddham: "sidd", Khudawadi: "sind", Sinhala: "sinh", Sora_Sompeng: "sora", Sundanese: "sund", Syloti_Nagri: "sylo", Syriac: "syrc", Tagbanwa: "tagb", Takri: "takr", Tai_Le: "tale", New_Tai_Lue: "talu", Tamil: ["tml2", "taml"], Tai_Viet: "tavt", Telugu: ["tel2", "telu"], Tifinagh: "tfng", Tagalog: "tglg", Thaana: "thaa", Thai: "thai", Tibetan: "tibt", Tirhuta: "tirh", Ugaritic: "ugar", Vai: "vai ", Warang_Citi: "wara", Old_Persian: "xpeo", Cuneiform: "xsux", Yi: "yi  ", Inherited: "zinh", Common: "zyyy", Unknown: "zzzz" }, Th = {};
  for (var Lh in Bh) {
    var zh = Bh[Lh];
    if (Array.isArray(zh))
      for (var Uh, Dh = Oh(zh); !(Uh = Dh()).done; ) {
        var jh = Uh.value;
        Th[jh] = Lh;
      }
    else
      Th[zh] = Lh;
  }
  var Mh = { arab: true, hebr: true, syrc: true, thaa: true, cprt: true, khar: true, phnx: true, "nko ": true, lydi: true, avst: true, armi: true, phli: true, prti: true, sarb: true, orkh: true, samr: true, mand: true, merc: true, mero: true, mani: true, mend: true, nbat: true, narb: true, palm: true, phlp: true };
  function Fh(e2) {
    return Mh[e2] ? "rtl" : "ltr";
  }
  function Rh(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Nh(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Nh(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Nh(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  function qh(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  for (var Gh = function() {
    function e2(e3, t3, r3, n2, i2) {
      if (this.glyphs = e3, this.positions = null, this.script = r3, this.language = n2 || null, this.direction = i2 || Fh(r3), this.features = {}, Array.isArray(t3))
        for (var a2, o2 = Rh(t3); !(a2 = o2()).done; ) {
          var s2 = a2.value;
          this.features[s2] = true;
        }
      else
        "object" == typeof t3 && (this.features = t3);
    }
    var t2, r2;
    return t2 = e2, (r2 = [{ key: "advanceWidth", get: function() {
      for (var e3, t3 = 0, r3 = Rh(this.positions); !(e3 = r3()).done; )
        t3 += e3.value.xAdvance;
      return t3;
    } }, { key: "advanceHeight", get: function() {
      for (var e3, t3 = 0, r3 = Rh(this.positions); !(e3 = r3()).done; )
        t3 += e3.value.yAdvance;
      return t3;
    } }, { key: "bbox", get: function() {
      for (var e3 = new Ih(), t3 = 0, r3 = 0, n2 = 0; n2 < this.glyphs.length; n2++) {
        var i2 = this.glyphs[n2], a2 = this.positions[n2], o2 = i2.bbox;
        e3.addPoint(o2.minX + t3 + a2.xOffset, o2.minY + r3 + a2.yOffset), e3.addPoint(o2.maxX + t3 + a2.xOffset, o2.maxY + r3 + a2.yOffset), t3 += a2.xAdvance, r3 += a2.yAdvance;
      }
      return e3;
    } }]) && qh(t2.prototype, r2), e2;
  }(), Vh = function(e2, t2, r2, n2) {
    void 0 === e2 && (e2 = 0), void 0 === t2 && (t2 = 0), void 0 === r2 && (r2 = 0), void 0 === n2 && (n2 = 0), this.xAdvance = e2, this.yAdvance = t2, this.xOffset = r2, this.yOffset = n2;
  }, _h = { allTypographicFeatures: { code: 0, exclusive: false, allTypeFeatures: 0 }, ligatures: { code: 1, exclusive: false, requiredLigatures: 0, commonLigatures: 2, rareLigatures: 4, rebusPictures: 8, diphthongLigatures: 10, squaredLigatures: 12, abbrevSquaredLigatures: 14, symbolLigatures: 16, contextualLigatures: 18, historicalLigatures: 20 }, cursiveConnection: { code: 2, exclusive: true, unconnected: 0, partiallyConnected: 1, cursive: 2 }, letterCase: { code: 3, exclusive: true }, verticalSubstitution: { code: 4, exclusive: false, substituteVerticalForms: 0 }, linguisticRearrangement: { code: 5, exclusive: false, linguisticRearrangement: 0 }, numberSpacing: { code: 6, exclusive: true, monospacedNumbers: 0, proportionalNumbers: 1, thirdWidthNumbers: 2, quarterWidthNumbers: 3 }, smartSwash: { code: 8, exclusive: false, wordInitialSwashes: 0, wordFinalSwashes: 2, nonFinalSwashes: 8 }, diacritics: { code: 9, exclusive: true, showDiacritics: 0, hideDiacritics: 1, decomposeDiacritics: 2 }, verticalPosition: { code: 10, exclusive: true, normalPosition: 0, superiors: 1, inferiors: 2, ordinals: 3, scientificInferiors: 4 }, fractions: { code: 11, exclusive: true, noFractions: 0, verticalFractions: 1, diagonalFractions: 2 }, overlappingCharacters: { code: 13, exclusive: false, preventOverlap: 0 }, typographicExtras: { code: 14, exclusive: false, slashedZero: 4 }, mathematicalExtras: { code: 15, exclusive: false, mathematicalGreek: 10 }, ornamentSets: { code: 16, exclusive: true, noOrnaments: 0, dingbats: 1, piCharacters: 2, fleurons: 3, decorativeBorders: 4, internationalSymbols: 5, mathSymbols: 6 }, characterAlternatives: { code: 17, exclusive: true, noAlternates: 0 }, designComplexity: { code: 18, exclusive: true, designLevel1: 0, designLevel2: 1, designLevel3: 2, designLevel4: 3, designLevel5: 4 }, styleOptions: { code: 19, exclusive: true, noStyleOptions: 0, displayText: 1, engravedText: 2, illuminatedCaps: 3, titlingCaps: 4, tallCaps: 5 }, characterShape: { code: 20, exclusive: true, traditionalCharacters: 0, simplifiedCharacters: 1, JIS1978Characters: 2, JIS1983Characters: 3, JIS1990Characters: 4, traditionalAltOne: 5, traditionalAltTwo: 6, traditionalAltThree: 7, traditionalAltFour: 8, traditionalAltFive: 9, expertCharacters: 10, JIS2004Characters: 11, hojoCharacters: 12, NLCCharacters: 13, traditionalNamesCharacters: 14 }, numberCase: { code: 21, exclusive: true, lowerCaseNumbers: 0, upperCaseNumbers: 1 }, textSpacing: { code: 22, exclusive: true, proportionalText: 0, monospacedText: 1, halfWidthText: 2, thirdWidthText: 3, quarterWidthText: 4, altProportionalText: 5, altHalfWidthText: 6 }, transliteration: { code: 23, exclusive: true, noTransliteration: 0 }, annotation: { code: 24, exclusive: true, noAnnotation: 0, boxAnnotation: 1, roundedBoxAnnotation: 2, circleAnnotation: 3, invertedCircleAnnotation: 4, parenthesisAnnotation: 5, periodAnnotation: 6, romanNumeralAnnotation: 7, diamondAnnotation: 8, invertedBoxAnnotation: 9, invertedRoundedBoxAnnotation: 10 }, kanaSpacing: { code: 25, exclusive: true, fullWidthKana: 0, proportionalKana: 1 }, ideographicSpacing: { code: 26, exclusive: true, fullWidthIdeographs: 0, proportionalIdeographs: 1, halfWidthIdeographs: 2 }, unicodeDecomposition: { code: 27, exclusive: false, canonicalComposition: 0, compatibilityComposition: 2, transcodingComposition: 4 }, rubyKana: { code: 28, exclusive: false, rubyKana: 2 }, CJKSymbolAlternatives: { code: 29, exclusive: true, noCJKSymbolAlternatives: 0, CJKSymbolAltOne: 1, CJKSymbolAltTwo: 2, CJKSymbolAltThree: 3, CJKSymbolAltFour: 4, CJKSymbolAltFive: 5 }, ideographicAlternatives: { code: 30, exclusive: true, noIdeographicAlternatives: 0, ideographicAltOne: 1, ideographicAltTwo: 2, ideographicAltThree: 3, ideographicAltFour: 4, ideographicAltFive: 5 }, CJKVerticalRomanPlacement: { code: 31, exclusive: true, CJKVerticalRomanCentered: 0, CJKVerticalRomanHBaseline: 1 }, italicCJKRoman: { code: 32, exclusive: false, CJKItalicRoman: 2 }, caseSensitiveLayout: { code: 33, exclusive: false, caseSensitiveLayout: 0, caseSensitiveSpacing: 2 }, alternateKana: { code: 34, exclusive: false, alternateHorizKana: 0, alternateVertKana: 2 }, stylisticAlternatives: { code: 35, exclusive: false, noStylisticAlternates: 0, stylisticAltOne: 2, stylisticAltTwo: 4, stylisticAltThree: 6, stylisticAltFour: 8, stylisticAltFive: 10, stylisticAltSix: 12, stylisticAltSeven: 14, stylisticAltEight: 16, stylisticAltNine: 18, stylisticAltTen: 20, stylisticAltEleven: 22, stylisticAltTwelve: 24, stylisticAltThirteen: 26, stylisticAltFourteen: 28, stylisticAltFifteen: 30, stylisticAltSixteen: 32, stylisticAltSeventeen: 34, stylisticAltEighteen: 36, stylisticAltNineteen: 38, stylisticAltTwenty: 40 }, contextualAlternates: { code: 36, exclusive: false, contextualAlternates: 0, swashAlternates: 2, contextualSwashAlternates: 4 }, lowerCase: { code: 37, exclusive: true, defaultLowerCase: 0, lowerCaseSmallCaps: 1, lowerCasePetiteCaps: 2 }, upperCase: { code: 38, exclusive: true, defaultUpperCase: 0, upperCaseSmallCaps: 1, upperCasePetiteCaps: 2 }, languageTag: { code: 39, exclusive: true }, CJKRomanSpacing: { code: 103, exclusive: true, halfWidthCJKRoman: 0, proportionalCJKRoman: 1, defaultCJKRoman: 2, fullWidthCJKRoman: 3 } }, Wh = function(e2, t2) {
    return [_h[e2].code, _h[e2][t2]];
  }, Hh = { rlig: Wh("ligatures", "requiredLigatures"), clig: Wh("ligatures", "contextualLigatures"), dlig: Wh("ligatures", "rareLigatures"), hlig: Wh("ligatures", "historicalLigatures"), liga: Wh("ligatures", "commonLigatures"), hist: Wh("ligatures", "historicalLigatures"), smcp: Wh("lowerCase", "lowerCaseSmallCaps"), pcap: Wh("lowerCase", "lowerCasePetiteCaps"), frac: Wh("fractions", "diagonalFractions"), dnom: Wh("fractions", "diagonalFractions"), numr: Wh("fractions", "diagonalFractions"), afrc: Wh("fractions", "verticalFractions"), case: Wh("caseSensitiveLayout", "caseSensitiveLayout"), ccmp: Wh("unicodeDecomposition", "canonicalComposition"), cpct: Wh("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"), valt: Wh("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"), swsh: Wh("contextualAlternates", "swashAlternates"), cswh: Wh("contextualAlternates", "contextualSwashAlternates"), curs: Wh("cursiveConnection", "cursive"), c2pc: Wh("upperCase", "upperCasePetiteCaps"), c2sc: Wh("upperCase", "upperCaseSmallCaps"), init: Wh("smartSwash", "wordInitialSwashes"), fin2: Wh("smartSwash", "wordFinalSwashes"), medi: Wh("smartSwash", "nonFinalSwashes"), med2: Wh("smartSwash", "nonFinalSwashes"), fin3: Wh("smartSwash", "wordFinalSwashes"), fina: Wh("smartSwash", "wordFinalSwashes"), pkna: Wh("kanaSpacing", "proportionalKana"), half: Wh("textSpacing", "halfWidthText"), halt: Wh("textSpacing", "altHalfWidthText"), hkna: Wh("alternateKana", "alternateHorizKana"), vkna: Wh("alternateKana", "alternateVertKana"), ital: Wh("italicCJKRoman", "CJKItalicRoman"), lnum: Wh("numberCase", "upperCaseNumbers"), onum: Wh("numberCase", "lowerCaseNumbers"), mgrk: Wh("mathematicalExtras", "mathematicalGreek"), calt: Wh("contextualAlternates", "contextualAlternates"), vrt2: Wh("verticalSubstitution", "substituteVerticalForms"), vert: Wh("verticalSubstitution", "substituteVerticalForms"), tnum: Wh("numberSpacing", "monospacedNumbers"), pnum: Wh("numberSpacing", "proportionalNumbers"), sups: Wh("verticalPosition", "superiors"), subs: Wh("verticalPosition", "inferiors"), ordn: Wh("verticalPosition", "ordinals"), pwid: Wh("textSpacing", "proportionalText"), hwid: Wh("textSpacing", "halfWidthText"), qwid: Wh("textSpacing", "quarterWidthText"), twid: Wh("textSpacing", "thirdWidthText"), fwid: Wh("textSpacing", "proportionalText"), palt: Wh("textSpacing", "altProportionalText"), trad: Wh("characterShape", "traditionalCharacters"), smpl: Wh("characterShape", "simplifiedCharacters"), jp78: Wh("characterShape", "JIS1978Characters"), jp83: Wh("characterShape", "JIS1983Characters"), jp90: Wh("characterShape", "JIS1990Characters"), jp04: Wh("characterShape", "JIS2004Characters"), expt: Wh("characterShape", "expertCharacters"), hojo: Wh("characterShape", "hojoCharacters"), nlck: Wh("characterShape", "NLCCharacters"), tnam: Wh("characterShape", "traditionalNamesCharacters"), ruby: Wh("rubyKana", "rubyKana"), titl: Wh("styleOptions", "titlingCaps"), zero: Wh("typographicExtras", "slashedZero"), ss01: Wh("stylisticAlternatives", "stylisticAltOne"), ss02: Wh("stylisticAlternatives", "stylisticAltTwo"), ss03: Wh("stylisticAlternatives", "stylisticAltThree"), ss04: Wh("stylisticAlternatives", "stylisticAltFour"), ss05: Wh("stylisticAlternatives", "stylisticAltFive"), ss06: Wh("stylisticAlternatives", "stylisticAltSix"), ss07: Wh("stylisticAlternatives", "stylisticAltSeven"), ss08: Wh("stylisticAlternatives", "stylisticAltEight"), ss09: Wh("stylisticAlternatives", "stylisticAltNine"), ss10: Wh("stylisticAlternatives", "stylisticAltTen"), ss11: Wh("stylisticAlternatives", "stylisticAltEleven"), ss12: Wh("stylisticAlternatives", "stylisticAltTwelve"), ss13: Wh("stylisticAlternatives", "stylisticAltThirteen"), ss14: Wh("stylisticAlternatives", "stylisticAltFourteen"), ss15: Wh("stylisticAlternatives", "stylisticAltFifteen"), ss16: Wh("stylisticAlternatives", "stylisticAltSixteen"), ss17: Wh("stylisticAlternatives", "stylisticAltSeventeen"), ss18: Wh("stylisticAlternatives", "stylisticAltEighteen"), ss19: Wh("stylisticAlternatives", "stylisticAltNineteen"), ss20: Wh("stylisticAlternatives", "stylisticAltTwenty") }, Yh = 1; Yh <= 99; Yh++)
    Hh["cv" + ("00" + Yh).slice(-2)] = [_h.characterAlternatives.code, Yh];
  var Xh, Zh = {};
  for (var Kh in Hh) {
    var Jh = Hh[Kh];
    null == Zh[Jh[0]] && (Zh[Jh[0]] = {}), Zh[Jh[0]][Jh[1]] = Kh;
  }
  function Qh(e2) {
    var t2 = e2[0], r2 = e2[1];
    if (isNaN(t2))
      var n2 = _h[t2] && _h[t2].code;
    else
      n2 = t2;
    if (isNaN(r2))
      var i2 = _h[t2] && _h[t2][r2];
    else
      i2 = r2;
    return [n2, i2];
  }
  function $h(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return ed(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return ed(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function ed(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var td = (function(e2, t2, r2, n2, i2) {
    var a2 = {};
    Object.keys(n2).forEach(function(e3) {
      a2[e3] = n2[e3];
    }), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = r2.slice().reverse().reduce(function(r3, n3) {
      return n3(e2, t2, r3) || r3;
    }, a2), i2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(i2) : void 0, a2.initializer = void 0), void 0 === a2.initializer && (Object.defineProperty(e2, t2, a2), a2 = null);
  }((Xh = function() {
    function e2(e3) {
      this.table = e3;
    }
    var t2 = e2.prototype;
    return t2.lookup = function(e3) {
      switch (this.table.version) {
        case 0:
          return this.table.values.getItem(e3);
        case 2:
        case 4:
          for (var t3 = 0, r2 = this.table.binarySearchHeader.nUnits - 1; t3 <= r2; ) {
            var n2 = t3 + r2 >> 1;
            if (65535 === (o2 = this.table.segments[n2]).firstGlyph)
              return null;
            if (e3 < o2.firstGlyph)
              r2 = n2 - 1;
            else {
              if (!(e3 > o2.lastGlyph))
                return 2 === this.table.version ? o2.value : o2.values[e3 - o2.firstGlyph];
              t3 = n2 + 1;
            }
          }
          return null;
        case 6:
          for (var i2 = 0, a2 = this.table.binarySearchHeader.nUnits - 1; i2 <= a2; ) {
            var o2;
            n2 = i2 + a2 >> 1;
            if (65535 === (o2 = this.table.segments[n2]).glyph)
              return null;
            if (e3 < o2.glyph)
              a2 = n2 - 1;
            else {
              if (!(e3 > o2.glyph))
                return o2.value;
              i2 = n2 + 1;
            }
          }
          return null;
        case 8:
          return this.table.values[e3 - this.table.firstGlyph];
        default:
          throw new Error("Unknown lookup table format: " + this.table.version);
      }
    }, t2.glyphsForValue = function(e3) {
      var t3 = [];
      switch (this.table.version) {
        case 2:
        case 4:
          for (var r2, n2 = $h(this.table.segments); !(r2 = n2()).done; ) {
            var i2 = r2.value;
            if (2 === this.table.version && i2.value === e3)
              t3.push.apply(t3, jl(i2.firstGlyph, i2.lastGlyph + 1));
            else
              for (var a2 = 0; a2 < i2.values.length; a2++)
                i2.values[a2] === e3 && t3.push(i2.firstGlyph + a2);
          }
          break;
        case 6:
          for (var o2, s2 = $h(this.table.segments); !(o2 = s2()).done; ) {
            var u2 = o2.value;
            u2.value === e3 && t3.push(u2.glyph);
          }
          break;
        case 8:
          for (var l2 = 0; l2 < this.table.values.length; l2++)
            this.table.values[l2] === e3 && t3.push(this.table.firstGlyph + l2);
          break;
        default:
          throw new Error("Unknown lookup table format: " + this.table.version);
      }
      return t3;
    }, e2;
  }()).prototype, "glyphsForValue", [An], Object.getOwnPropertyDescriptor(Xh.prototype, "glyphsForValue"), Xh.prototype), Xh);
  function rd(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return nd(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return nd(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function nd(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var id, ad = function() {
    function e2(e3) {
      this.stateTable = e3, this.lookupTable = new td(e3.classTable);
    }
    var t2 = e2.prototype;
    return t2.process = function(e3, t3, r2) {
      for (var n2 = 0, i2 = t3 ? e3.length - 1 : 0, a2 = t3 ? -1 : 1; 1 === a2 && i2 <= e3.length || -1 === a2 && i2 >= -1; ) {
        var o2 = null, s2 = 1, u2 = true;
        i2 === e3.length || -1 === i2 ? s2 = 0 : 65535 === (o2 = e3[i2]).id ? s2 = 2 : null == (s2 = this.lookupTable.lookup(o2.id)) && (s2 = 1);
        var l2 = this.stateTable.stateArray.getItem(n2)[s2], c2 = this.stateTable.entryTable.getItem(l2);
        0 !== s2 && 2 !== s2 && (r2(o2, c2, i2), u2 = !(16384 & c2.flags)), n2 = c2.newState, u2 && (i2 += a2);
      }
      return e3;
    }, t2.traverse = function(e3, t3, r2) {
      if (void 0 === t3 && (t3 = 0), void 0 === r2 && (r2 = /* @__PURE__ */ new Set()), !r2.has(t3)) {
        r2.add(t3);
        for (var n2 = this.stateTable, i2 = n2.nClasses, a2 = n2.stateArray, o2 = n2.entryTable, s2 = a2.getItem(t3), u2 = 4; u2 < i2; u2++)
          for (var l2, c2 = s2[u2], f2 = o2.getItem(c2), h2 = rd(this.lookupTable.glyphsForValue(u2)); !(l2 = h2()).done; ) {
            var d2 = l2.value;
            e3.enter && e3.enter(d2, f2), 0 !== f2.newState && this.traverse(e3, f2.newState, r2), e3.exit && e3.exit(d2, f2);
          }
      }
    }, e2;
  }();
  function od(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return sd(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return sd(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function sd(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var ud = (function(e2, t2, r2, n2, i2) {
    var a2 = {};
    Object.keys(n2).forEach(function(e3) {
      a2[e3] = n2[e3];
    }), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = r2.slice().reverse().reduce(function(r3, n3) {
      return n3(e2, t2, r3) || r3;
    }, a2), i2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(i2) : void 0, a2.initializer = void 0), void 0 === a2.initializer && (Object.defineProperty(e2, t2, a2), a2 = null);
  }((id = function() {
    function e2(e3) {
      this.processIndicRearragement = this.processIndicRearragement.bind(this), this.processContextualSubstitution = this.processContextualSubstitution.bind(this), this.processLigature = this.processLigature.bind(this), this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this), this.processGlyphInsertion = this.processGlyphInsertion.bind(this), this.font = e3, this.morx = e3.morx, this.inputCache = null;
    }
    var t2 = e2.prototype;
    return t2.process = function(e3, t3) {
      void 0 === t3 && (t3 = {});
      for (var r2, n2 = od(this.morx.chains); !(r2 = n2()).done; ) {
        for (var i2, a2 = r2.value, o2 = a2.defaultFlags, s2 = od(a2.features); !(i2 = s2()).done; ) {
          var u2, l2 = i2.value;
          (u2 = t3[l2.featureType]) && u2[l2.featureSetting] && (o2 &= l2.disableFlags, o2 |= l2.enableFlags);
        }
        for (var c2, f2 = od(a2.subtables); !(c2 = f2()).done; ) {
          var h2 = c2.value;
          h2.subFeatureFlags & o2 && this.processSubtable(h2, e3);
        }
      }
      for (var d2 = e3.length - 1; d2 >= 0; )
        65535 === e3[d2].id && e3.splice(d2, 1), d2--;
      return e3;
    }, t2.processSubtable = function(e3, t3) {
      if (this.subtable = e3, this.glyphs = t3, 4 !== this.subtable.type) {
        this.ligatureStack = [], this.markedGlyph = null, this.firstGlyph = null, this.lastGlyph = null, this.markedIndex = null;
        var r2 = this.getStateMachine(e3), n2 = this.getProcessor(), i2 = !!(4194304 & this.subtable.coverage);
        return r2.process(this.glyphs, i2, n2);
      }
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
    }, t2.getStateMachine = function(e3) {
      return new ad(e3.table.stateTable);
    }, t2.getProcessor = function() {
      switch (this.subtable.type) {
        case 0:
          return this.processIndicRearragement;
        case 1:
          return this.processContextualSubstitution;
        case 2:
          return this.processLigature;
        case 4:
          return this.processNoncontextualSubstitutions;
        case 5:
          return this.processGlyphInsertion;
        default:
          throw new Error("Invalid morx subtable type: " + this.subtable.type);
      }
    }, t2.processIndicRearragement = function(e3, t3, r2) {
      32768 & t3.flags && (this.firstGlyph = r2), 8192 & t3.flags && (this.lastGlyph = r2), function(e4, t4, r3, n2) {
        switch (t4) {
          case 0:
            return e4;
          case 1:
            return ld(e4, [r3, 1], [n2, 0]);
          case 2:
            return ld(e4, [r3, 0], [n2, 1]);
          case 3:
            return ld(e4, [r3, 1], [n2, 1]);
          case 4:
            return ld(e4, [r3, 2], [n2, 0]);
          case 5:
            return ld(e4, [r3, 2], [n2, 0], true, false);
          case 6:
            return ld(e4, [r3, 0], [n2, 2]);
          case 7:
            return ld(e4, [r3, 0], [n2, 2], false, true);
          case 8:
            return ld(e4, [r3, 1], [n2, 2]);
          case 9:
            return ld(e4, [r3, 1], [n2, 2], false, true);
          case 10:
            return ld(e4, [r3, 2], [n2, 1]);
          case 11:
            return ld(e4, [r3, 2], [n2, 1], true, false);
          case 12:
            return ld(e4, [r3, 2], [n2, 2]);
          case 13:
            return ld(e4, [r3, 2], [n2, 2], true, false);
          case 14:
            return ld(e4, [r3, 2], [n2, 2], false, true);
          case 15:
            return ld(e4, [r3, 2], [n2, 2], true, true);
          default:
            throw new Error("Unknown verb: " + t4);
        }
      }(this.glyphs, 15 & t3.flags, this.firstGlyph, this.lastGlyph);
    }, t2.processContextualSubstitution = function(e3, t3, r2) {
      var n2 = this.subtable.table.substitutionTable.items;
      if (65535 !== t3.markIndex) {
        var i2 = n2.getItem(t3.markIndex), a2 = new td(i2);
        e3 = this.glyphs[this.markedGlyph], (o2 = a2.lookup(e3.id)) && (this.glyphs[this.markedGlyph] = this.font.getGlyph(o2, e3.codePoints));
      }
      if (65535 !== t3.currentIndex) {
        var o2, s2 = n2.getItem(t3.currentIndex), u2 = new td(s2);
        e3 = this.glyphs[r2], (o2 = u2.lookup(e3.id)) && (this.glyphs[r2] = this.font.getGlyph(o2, e3.codePoints));
      }
      32768 & t3.flags && (this.markedGlyph = r2);
    }, t2.processLigature = function(e3, t3, r2) {
      if (32768 & t3.flags && this.ligatureStack.push(r2), 8192 & t3.flags) {
        for (var n2, i2 = this.subtable.table.ligatureActions, a2 = this.subtable.table.components, o2 = this.subtable.table.ligatureList, s2 = t3.action, u2 = false, l2 = 0, c2 = [], f2 = []; !u2; ) {
          var h2, d2 = this.ligatureStack.pop();
          (h2 = c2).unshift.apply(h2, this.glyphs[d2].codePoints);
          var p2 = i2.getItem(s2++);
          u2 = !!(2147483648 & p2);
          var y2 = !!(1073741824 & p2), g2 = (1073741823 & p2) << 2 >> 2;
          if (g2 += this.glyphs[d2].id, l2 += a2.getItem(g2), u2 || y2) {
            var v2 = o2.getItem(l2);
            this.glyphs[d2] = this.font.getGlyph(v2, c2), f2.push(d2), l2 = 0, c2 = [];
          } else
            this.glyphs[d2] = this.font.getGlyph(65535);
        }
        (n2 = this.ligatureStack).push.apply(n2, f2);
      }
    }, t2.processNoncontextualSubstitutions = function(e3, t3, r2) {
      var n2 = new td(e3.table.lookupTable);
      for (r2 = 0; r2 < t3.length; r2++) {
        var i2 = t3[r2];
        if (65535 !== i2.id) {
          var a2 = n2.lookup(i2.id);
          a2 && (t3[r2] = this.font.getGlyph(a2, i2.codePoints));
        }
      }
    }, t2._insertGlyphs = function(e3, t3, r2, n2) {
      for (var i2, a2 = []; r2--; ) {
        var o2 = this.subtable.table.insertionActions.getItem(t3++);
        a2.push(this.font.getGlyph(o2));
      }
      n2 || e3++, (i2 = this.glyphs).splice.apply(i2, [e3, 0].concat(a2));
    }, t2.processGlyphInsertion = function(e3, t3, r2) {
      if (32768 & t3.flags && (this.markedIndex = r2), 65535 !== t3.markedInsertIndex) {
        var n2 = (31 & t3.flags) >>> 5, i2 = !!(1024 & t3.flags);
        this._insertGlyphs(this.markedIndex, t3.markedInsertIndex, n2, i2);
      }
      if (65535 !== t3.currentInsertIndex) {
        var a2 = (992 & t3.flags) >>> 5, o2 = !!(2048 & t3.flags);
        this._insertGlyphs(r2, t3.currentInsertIndex, a2, o2);
      }
    }, t2.getSupportedFeatures = function() {
      for (var e3, t3 = [], r2 = od(this.morx.chains); !(e3 = r2()).done; )
        for (var n2, i2 = od(e3.value.features); !(n2 = i2()).done; ) {
          var a2 = n2.value;
          t3.push([a2.featureType, a2.featureSetting]);
        }
      return t3;
    }, t2.generateInputs = function(e3) {
      return this.inputCache || this.generateInputCache(), this.inputCache[e3] || [];
    }, t2.generateInputCache = function() {
      this.inputCache = {};
      for (var e3, t3 = od(this.morx.chains); !(e3 = t3()).done; )
        for (var r2, n2 = e3.value, i2 = n2.defaultFlags, a2 = od(n2.subtables); !(r2 = a2()).done; ) {
          var o2 = r2.value;
          o2.subFeatureFlags & i2 && this.generateInputsForSubtable(o2);
        }
    }, t2.generateInputsForSubtable = function(e3) {
      var t3 = this;
      if (2 === e3.type) {
        if (!!(4194304 & e3.coverage))
          throw new Error("Reverse subtable, not supported.");
        this.subtable = e3, this.ligatureStack = [];
        var r2 = this.getStateMachine(e3), n2 = this.getProcessor(), i2 = [], a2 = [];
        this.glyphs = [], r2.traverse({ enter: function(e4, r3) {
          var o2 = t3.glyphs;
          a2.push({ glyphs: o2.slice(), ligatureStack: t3.ligatureStack.slice() });
          var s2 = t3.font.getGlyph(e4);
          i2.push(s2), o2.push(i2[i2.length - 1]), n2(o2[o2.length - 1], r3, o2.length - 1);
          for (var u2 = 0, l2 = 0, c2 = 0; c2 < o2.length && u2 <= 1; c2++)
            65535 !== o2[c2].id && (u2++, l2 = o2[c2].id);
          if (1 === u2) {
            var f2 = i2.map(function(e5) {
              return e5.id;
            }), h2 = t3.inputCache[l2];
            h2 ? h2.push(f2) : t3.inputCache[l2] = [f2];
          }
        }, exit: function() {
          var e4 = a2.pop();
          t3.glyphs = e4.glyphs, t3.ligatureStack = e4.ligatureStack, i2.pop();
        } });
      }
    }, e2;
  }()).prototype, "getStateMachine", [An], Object.getOwnPropertyDescriptor(id.prototype, "getStateMachine"), id.prototype), id);
  function ld(e2, t2, r2, n2, i2) {
    void 0 === n2 && (n2 = false), void 0 === i2 && (i2 = false);
    var a2 = e2.splice(r2[0] - (r2[1] - 1), r2[1]);
    i2 && a2.reverse();
    var o2 = e2.splice.apply(e2, [t2[0], t2[1]].concat(a2));
    return n2 && o2.reverse(), e2.splice.apply(e2, [r2[0] - (t2[1] - 1), 0].concat(o2)), e2;
  }
  function cd(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return fd(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return fd(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function fd(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var hd = function() {
    function e2(e3) {
      this.font = e3, this.morxProcessor = new ud(e3), this.fallbackPosition = false;
    }
    var t2 = e2.prototype;
    return t2.substitute = function(e3) {
      "rtl" === e3.direction && e3.glyphs.reverse(), this.morxProcessor.process(e3.glyphs, function(e4) {
        var t3 = {};
        for (var r2 in e4) {
          var n2;
          (n2 = Hh[r2]) && (null == t3[n2[0]] && (t3[n2[0]] = {}), t3[n2[0]][n2[1]] = e4[r2]);
        }
        return t3;
      }(e3.features));
    }, t2.getAvailableFeatures = function(e3, t3) {
      return function(e4) {
        var t4 = {};
        if (Array.isArray(e4))
          for (var r2 = 0; r2 < e4.length; r2++) {
            var n2, i2 = Qh(e4[r2]);
            (n2 = Zh[i2[0]] && Zh[i2[0]][i2[1]]) && (t4[n2] = true);
          }
        else if ("object" == typeof e4)
          for (var a2 in e4) {
            var o2 = e4[a2];
            for (var s2 in o2) {
              var u2 = void 0, l2 = Qh([a2, s2]);
              o2[s2] && (u2 = Zh[l2[0]] && Zh[l2[0]][l2[1]]) && (t4[u2] = true);
            }
          }
        return Object.keys(t4);
      }(this.morxProcessor.getSupportedFeatures());
    }, t2.stringsForGlyph = function(e3) {
      for (var t3, r2 = this.morxProcessor.generateInputs(e3), n2 = /* @__PURE__ */ new Set(), i2 = cd(r2); !(t3 = i2()).done; ) {
        var a2 = t3.value;
        this._addStrings(a2, 0, n2, "");
      }
      return n2;
    }, t2._addStrings = function(e3, t3, r2, n2) {
      for (var i2, a2 = cd(this.font._cmapProcessor.codePointsForGlyph(e3[t3])); !(i2 = a2()).done; ) {
        var o2 = i2.value, s2 = n2 + String.fromCodePoint(o2);
        t3 < e3.length - 1 ? this._addStrings(e3, t3 + 1, r2, s2) : r2.add(s2);
      }
    }, e2;
  }();
  function dd(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return pd(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return pd(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function pd(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var yd = function() {
    function e2(e3, t3, r2) {
      this.font = e3, this.script = t3, this.direction = r2, this.stages = [], this.globalFeatures = {}, this.allFeatures = {};
    }
    var t2 = e2.prototype;
    return t2._addFeatures = function(e3, t3) {
      for (var r2, n2 = this.stages.length - 1, i2 = this.stages[n2], a2 = dd(e3); !(r2 = a2()).done; ) {
        var o2 = r2.value;
        null == this.allFeatures[o2] && (i2.push(o2), this.allFeatures[o2] = n2, t3 && (this.globalFeatures[o2] = true));
      }
    }, t2.add = function(e3, t3) {
      if (void 0 === t3 && (t3 = true), 0 === this.stages.length && this.stages.push([]), "string" == typeof e3 && (e3 = [e3]), Array.isArray(e3))
        this._addFeatures(e3, t3);
      else {
        if ("object" != typeof e3)
          throw new Error("Unsupported argument to ShapingPlan#add");
        this._addFeatures(e3.global || [], true), this._addFeatures(e3.local || [], false);
      }
    }, t2.addStage = function(e3, t3) {
      "function" == typeof e3 ? this.stages.push(e3, []) : (this.stages.push([]), this.add(e3, t3));
    }, t2.setFeatureOverrides = function(e3) {
      if (Array.isArray(e3))
        this.add(e3);
      else if ("object" == typeof e3) {
        for (var t3 in e3)
          if (e3[t3])
            this.add(t3);
          else if (null != this.allFeatures[t3]) {
            var r2 = this.stages[this.allFeatures[t3]];
            r2.splice(r2.indexOf(t3), 1), delete this.allFeatures[t3], delete this.globalFeatures[t3];
          }
      }
    }, t2.assignGlobalFeatures = function(e3) {
      for (var t3, r2 = dd(e3); !(t3 = r2()).done; ) {
        var n2 = t3.value;
        for (var i2 in this.globalFeatures)
          n2.features[i2] = true;
      }
    }, t2.process = function(e3, t3, r2) {
      for (var n2, i2 = dd(this.stages); !(n2 = i2()).done; ) {
        var a2 = n2.value;
        "function" == typeof a2 ? r2 || a2(this.font, t3, this) : a2.length > 0 && e3.applyFeatures(a2, t3, r2);
      }
    }, e2;
  }();
  var gd = ["rvrn"], vd = ["ccmp", "locl", "rlig", "mark", "mkmk"], bd = ["frac", "numr", "dnom"], md = ["calt", "clig", "liga", "rclt", "curs", "kern"], wd = { ltr: ["ltra", "ltrm"], rtl: ["rtla", "rtlm"] }, Sd = function() {
    function e2() {
    }
    return e2.plan = function(e3, t2, r2) {
      this.planPreprocessing(e3), this.planFeatures(e3), this.planPostprocessing(e3, r2), e3.assignGlobalFeatures(t2), this.assignFeatures(e3, t2);
    }, e2.planPreprocessing = function(e3) {
      e3.add({ global: [].concat(gd, wd[e3.direction]), local: bd });
    }, e2.planFeatures = function(e3) {
    }, e2.planPostprocessing = function(e3, t2) {
      e3.add([].concat(vd, md)), e3.setFeatureOverrides(t2);
    }, e2.assignFeatures = function(e3, t2) {
      for (var r2 = 0; r2 < t2.length; r2++) {
        var n2 = t2[r2];
        if (8260 === n2.codePoints[0]) {
          for (var i2 = r2, a2 = r2 + 1; i2 > 0 && Ah(t2[i2 - 1].codePoints[0]); )
            t2[i2 - 1].features.numr = true, t2[i2 - 1].features.frac = true, i2--;
          for (; a2 < t2.length && Ah(t2[a2].codePoints[0]); )
            t2[a2].features.dnom = true, t2[a2].features.frac = true, a2++;
          n2.features.frac = true, r2 = a2 - 1;
        }
      }
    }, e2;
  }();
  !function(e2, t2, r2) {
    t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2;
  }(Sd, "zeroMarkWidths", "AFTER_GPOS");
  var xd = new fc(rh.inflate(ih("eJwBDgLx/QAB8AAAAAAAAAA4AAH9AQL+7ZotTMQwFMe77b44QIHA4JBIBAJ5lxASDAmGhHMoBIqgUOBQJAhOIpFIDIogSUgIEolEEgzJ/S/Xkpem3XXXboPbe8kv7a3r63vt69u6XDcWYhvsgn3Qlb//S3kMTsEZuACXoA9uwC24A/fgATyRfs/gTf4e8g4+ZP1Tll+knZlOfsC1pJ4IMQ8WkvLtKool+Los/V2pkN8MwzAMwzAMwzAMw1SP4fefVf7+wTAMwzAMwzC5cjUzYjEnXsFcW4gOOAeP4Ls9alufFWJTCNFrCdFvjepF8NLKbz7XcIbZMJxjOri2leF8s4N79zzPQz30P7DoOMT1o4qct9T/C06m1N9OHP3CwlJliSzQdlM9lNSk3kSjZih1TH2yQvv9JaE2UR/1uXLxLwSTzG0RJFrdxQ9TXKl2QUqbhNgHdDwXoT7Taz7SBHWD/oYkbf1dYyIhOvV+DU/7lWSNz1BxPW5uTO3jxnWVsvedb+zZ+o/L9Vlij95rerbZ7IoMelTe1XNFaJkkhqltphjT9ZrmT5ey34zVGijRbQxlX9n7xPTu1ZQUuY9993Oaf3nqDqnLNUf4SKg1iye005ZLIq1U9UiO5fJOGKfoN42nxnK1NUTOpfbYfNFzqZ5Tfe2wzWOIuLOtQdEov4qWtLhzJes6hI5RXwmZv0zPCps0A45rkwGaMQXv"))), Ad = ["isol", "fina", "fin2", "fin3", "medi", "med2", "init"], kd = 0, Cd = 6, Pd = "isol", Id = "fina", Od = [[[null, null, 0], [null, Pd, 2], [null, Pd, 1], [null, Pd, 2], [null, Pd, 1], [null, Pd, 6]], [[null, null, 0], [null, Pd, 2], [null, Pd, 1], [null, Pd, 2], [null, "fin2", 5], [null, Pd, 6]], [[null, null, 0], [null, Pd, 2], ["init", Id, 1], ["init", Id, 3], ["init", Id, 4], ["init", Id, 6]], [[null, null, 0], [null, Pd, 2], ["medi", Id, 1], ["medi", Id, 3], ["medi", Id, 4], ["medi", Id, 6]], [[null, null, 0], [null, Pd, 2], ["med2", Pd, 1], ["med2", Pd, 2], ["med2", "fin2", 5], ["med2", Pd, 6]], [[null, null, 0], [null, Pd, 2], [Pd, Pd, 1], [Pd, Pd, 2], [Pd, "fin2", 5], [Pd, Pd, 6]], [[null, null, 0], [null, Pd, 2], [null, Pd, 1], [null, Pd, 2], [null, "fin3", 5], [null, Pd, 6]]], Ed = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    return r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.planFeatures = function(e3) {
      e3.add(["ccmp", "locl"]);
      for (var t3 = 0; t3 < Ad.length; t3++) {
        var r3 = Ad[t3];
        e3.addStage(r3, false);
      }
      e3.addStage("mset");
    }, n2.assignFeatures = function(t3, r3) {
      e2.assignFeatures.call(this, t3, r3);
      for (var n3 = -1, i2 = 0, a2 = [], o2 = 0; o2 < r3.length; o2++) {
        var s2, u2, l2 = Bd((d2 = r3[o2]).codePoints[0]);
        if (l2 !== Cd) {
          var c2 = Od[i2][l2];
          u2 = c2[0], s2 = c2[1], i2 = c2[2], null !== u2 && -1 !== n3 && (a2[n3] = u2), a2[o2] = s2, n3 = o2;
        } else
          a2[o2] = null;
      }
      for (var f2 = 0; f2 < r3.length; f2++) {
        var h2, d2 = r3[f2];
        (h2 = a2[f2]) && (d2.features[h2] = true);
      }
    }, n2;
  }(Sd);
  function Bd(e2) {
    var t2 = xd.get(e2);
    if (t2)
      return t2 - 1;
    var r2 = wh(e2);
    return "Mn" === r2 || "Me" === r2 || "Cf" === r2 ? Cd : kd;
  }
  function Td(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  var Ld = function() {
    function e2(e3, t3) {
      this.glyphs = e3, this.reset(t3);
    }
    var t2, r2, i2 = e2.prototype;
    return i2.reset = function(e3, t3) {
      void 0 === e3 && (e3 = {}), void 0 === t3 && (t3 = 0), this.options = e3, this.flags = e3.flags || {}, this.markAttachmentType = e3.markAttachmentType || 0, this.index = t3;
    }, i2.shouldIgnore = function(e3) {
      return this.flags.ignoreMarks && e3.isMark || this.flags.ignoreBaseGlyphs && e3.isBase || this.flags.ignoreLigatures && e3.isLigature || this.markAttachmentType && e3.isMark && e3.markAttachmentType !== this.markAttachmentType;
    }, i2.move = function(e3) {
      for (this.index += e3; 0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index]); )
        this.index += e3;
      return 0 > this.index || this.index >= this.glyphs.length ? null : this.glyphs[this.index];
    }, i2.next = function() {
      return this.move(1);
    }, i2.prev = function() {
      return this.move(-1);
    }, i2.peek = function(e3) {
      void 0 === e3 && (e3 = 1);
      var t3 = this.index, r3 = this.increment(e3);
      return this.index = t3, r3;
    }, i2.peekIndex = function(e3) {
      void 0 === e3 && (e3 = 1);
      var t3 = this.index;
      this.increment(e3);
      var r3 = this.index;
      return this.index = t3, r3;
    }, i2.increment = function(e3) {
      void 0 === e3 && (e3 = 1);
      var t3 = e3 < 0 ? -1 : 1;
      for (e3 = Math.abs(e3); e3--; )
        this.move(t3);
      return this.glyphs[this.index];
    }, t2 = e2, (r2 = [{ key: "cur", get: function() {
      return this.glyphs[this.index] || null;
    } }]) && Td(t2.prototype, r2), e2;
  }();
  function zd(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Ud(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Ud(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Ud(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Dd = ["DFLT", "dflt", "latn"], jd = function() {
    function e2(e3, t3) {
      this.font = e3, this.table = t3, this.script = null, this.scriptTag = null, this.language = null, this.languageTag = null, this.features = {}, this.lookups = {}, this.variationsIndex = e3._variationProcessor ? this.findVariationsIndex(e3._variationProcessor.normalizedCoords) : -1, this.selectScript(), this.glyphs = [], this.positions = [], this.ligatureID = 1, this.currentFeature = null;
    }
    var t2 = e2.prototype;
    return t2.findScript = function(e3) {
      if (null == this.table.scriptList)
        return null;
      Array.isArray(e3) || (e3 = [e3]);
      for (var t3, r2 = zd(e3); !(t3 = r2()).done; )
        for (var n2, i2 = t3.value, a2 = zd(this.table.scriptList); !(n2 = a2()).done; ) {
          var o2 = n2.value;
          if (o2.tag === i2)
            return o2;
        }
      return null;
    }, t2.selectScript = function(e3, t3, r2) {
      var n2, i2 = false;
      if (!this.script || e3 !== this.scriptTag) {
        if ((n2 = this.findScript(e3)) || (n2 = this.findScript(Dd)), !n2)
          return this.scriptTag;
        this.scriptTag = n2.tag, this.script = n2.script, this.language = null, this.languageTag = null, i2 = true;
      }
      if (r2 && r2 === this.direction || (this.direction = r2 || Fh(e3)), t3 && t3.length < 4 && (t3 += " ".repeat(4 - t3.length)), !t3 || t3 !== this.languageTag) {
        this.language = null;
        for (var a2, o2 = zd(this.script.langSysRecords); !(a2 = o2()).done; ) {
          var s2 = a2.value;
          if (s2.tag === t3) {
            this.language = s2.langSys, this.languageTag = s2.tag;
            break;
          }
        }
        this.language || (this.language = this.script.defaultLangSys, this.languageTag = null), i2 = true;
      }
      if (i2 && (this.features = {}, this.language))
        for (var u2, l2 = zd(this.language.featureIndexes); !(u2 = l2()).done; ) {
          var c2 = u2.value, f2 = this.table.featureList[c2], h2 = this.substituteFeatureForVariations(c2);
          this.features[f2.tag] = h2 || f2.feature;
        }
      return this.scriptTag;
    }, t2.lookupsForFeatures = function(e3, t3) {
      void 0 === e3 && (e3 = []);
      for (var r2, n2 = [], i2 = zd(e3); !(r2 = i2()).done; ) {
        var a2 = r2.value, o2 = this.features[a2];
        if (o2)
          for (var s2, u2 = zd(o2.lookupListIndexes); !(s2 = u2()).done; ) {
            var l2 = s2.value;
            t3 && -1 !== t3.indexOf(l2) || n2.push({ feature: a2, index: l2, lookup: this.table.lookupList.get(l2) });
          }
      }
      return n2.sort(function(e4, t4) {
        return e4.index - t4.index;
      }), n2;
    }, t2.substituteFeatureForVariations = function(e3) {
      if (-1 === this.variationsIndex)
        return null;
      for (var t3, r2 = zd(this.table.featureVariations.featureVariationRecords[this.variationsIndex].featureTableSubstitution.substitutions); !(t3 = r2()).done; ) {
        var n2 = t3.value;
        if (n2.featureIndex === e3)
          return n2.alternateFeatureTable;
      }
      return null;
    }, t2.findVariationsIndex = function(e3) {
      var t3 = this.table.featureVariations;
      if (!t3)
        return -1;
      for (var r2 = t3.featureVariationRecords, n2 = 0; n2 < r2.length; n2++) {
        var i2 = r2[n2].conditionSet.conditionTable;
        if (this.variationConditionsMatch(i2, e3))
          return n2;
      }
      return -1;
    }, t2.variationConditionsMatch = function(e3, t3) {
      return e3.every(function(e4) {
        var r2 = e4.axisIndex < t3.length ? t3[e4.axisIndex] : 0;
        return e4.filterRangeMinValue <= r2 && r2 <= e4.filterRangeMaxValue;
      });
    }, t2.applyFeatures = function(e3, t3, r2) {
      var n2 = this.lookupsForFeatures(e3);
      this.applyLookups(n2, t3, r2);
    }, t2.applyLookups = function(e3, t3, r2) {
      this.glyphs = t3, this.positions = r2, this.glyphIterator = new Ld(t3);
      for (var n2, i2 = zd(e3); !(n2 = i2()).done; ) {
        var a2 = n2.value, o2 = a2.feature, s2 = a2.lookup;
        for (this.currentFeature = o2, this.glyphIterator.reset(s2.flags); this.glyphIterator.index < t3.length; )
          if (o2 in this.glyphIterator.cur.features) {
            for (var u2, l2 = zd(s2.subTables); !(u2 = l2()).done; ) {
              var c2 = u2.value;
              if (this.applyLookup(s2.lookupType, c2))
                break;
            }
            this.glyphIterator.next();
          } else
            this.glyphIterator.next();
      }
    }, t2.applyLookup = function(e3, t3) {
      throw new Error("applyLookup must be implemented by subclasses");
    }, t2.applyLookupList = function(e3) {
      for (var t3, r2 = this.glyphIterator.options, n2 = this.glyphIterator.index, i2 = zd(e3); !(t3 = i2()).done; ) {
        var a2 = t3.value;
        this.glyphIterator.reset(r2, n2), this.glyphIterator.increment(a2.sequenceIndex);
        var o2 = this.table.lookupList.get(a2.lookupListIndex);
        this.glyphIterator.reset(o2.flags, this.glyphIterator.index);
        for (var s2, u2 = zd(o2.subTables); !(s2 = u2()).done; ) {
          var l2 = s2.value;
          if (this.applyLookup(o2.lookupType, l2))
            break;
        }
      }
      return this.glyphIterator.reset(r2, n2), true;
    }, t2.coverageIndex = function(e3, t3) {
      switch (null == t3 && (t3 = this.glyphIterator.cur.id), e3.version) {
        case 1:
          return e3.glyphs.indexOf(t3);
        case 2:
          for (var r2, n2 = zd(e3.rangeRecords); !(r2 = n2()).done; ) {
            var i2 = r2.value;
            if (i2.start <= t3 && t3 <= i2.end)
              return i2.startCoverageIndex + t3 - i2.start;
          }
      }
      return -1;
    }, t2.match = function(e3, t3, r2, n2) {
      for (var i2 = this.glyphIterator.index, a2 = this.glyphIterator.increment(e3), o2 = 0; o2 < t3.length && a2 && r2(t3[o2], a2); )
        n2 && n2.push(this.glyphIterator.index), o2++, a2 = this.glyphIterator.next();
      return this.glyphIterator.index = i2, !(o2 < t3.length) && (n2 || true);
    }, t2.sequenceMatches = function(e3, t3) {
      return this.match(e3, t3, function(e4, t4) {
        return e4 === t4.id;
      });
    }, t2.sequenceMatchIndices = function(e3, t3) {
      var r2 = this;
      return this.match(e3, t3, function(e4, t4) {
        return r2.currentFeature in t4.features && e4 === t4.id;
      }, []);
    }, t2.coverageSequenceMatches = function(e3, t3) {
      var r2 = this;
      return this.match(e3, t3, function(e4, t4) {
        return r2.coverageIndex(e4, t4.id) >= 0;
      });
    }, t2.getClassID = function(e3, t3) {
      switch (t3.version) {
        case 1:
          var r2 = e3 - t3.startGlyph;
          if (r2 >= 0 && r2 < t3.classValueArray.length)
            return t3.classValueArray[r2];
          break;
        case 2:
          for (var n2, i2 = zd(t3.classRangeRecord); !(n2 = i2()).done; ) {
            var a2 = n2.value;
            if (a2.start <= e3 && e3 <= a2.end)
              return a2.class;
          }
      }
      return 0;
    }, t2.classSequenceMatches = function(e3, t3, r2) {
      var n2 = this;
      return this.match(e3, t3, function(e4, t4) {
        return e4 === n2.getClassID(t4.id, r2);
      });
    }, t2.applyContext = function(e3) {
      switch (e3.version) {
        case 1:
          var t3 = this.coverageIndex(e3.coverage);
          if (-1 === t3)
            return false;
          for (var r2, n2 = e3.ruleSets[t3], i2 = zd(n2); !(r2 = i2()).done; ) {
            var a2 = r2.value;
            if (this.sequenceMatches(1, a2.input))
              return this.applyLookupList(a2.lookupRecords);
          }
          break;
        case 2:
          if (-1 === this.coverageIndex(e3.coverage))
            return false;
          if (-1 === (t3 = this.getClassID(this.glyphIterator.cur.id, e3.classDef)))
            return false;
          for (var o2, s2 = zd(n2 = e3.classSet[t3]); !(o2 = s2()).done; ) {
            var u2 = o2.value;
            if (this.classSequenceMatches(1, u2.classes, e3.classDef))
              return this.applyLookupList(u2.lookupRecords);
          }
          break;
        case 3:
          if (this.coverageSequenceMatches(0, e3.coverages))
            return this.applyLookupList(e3.lookupRecords);
      }
      return false;
    }, t2.applyChainingContext = function(e3) {
      switch (e3.version) {
        case 1:
          var t3 = this.coverageIndex(e3.coverage);
          if (-1 === t3)
            return false;
          for (var r2, n2 = zd(e3.chainRuleSets[t3]); !(r2 = n2()).done; ) {
            var i2 = r2.value;
            if (this.sequenceMatches(-i2.backtrack.length, i2.backtrack) && this.sequenceMatches(1, i2.input) && this.sequenceMatches(1 + i2.input.length, i2.lookahead))
              return this.applyLookupList(i2.lookupRecords);
          }
          break;
        case 2:
          if (-1 === this.coverageIndex(e3.coverage))
            return false;
          t3 = this.getClassID(this.glyphIterator.cur.id, e3.inputClassDef);
          var a2 = e3.chainClassSet[t3];
          if (!a2)
            return false;
          for (var o2, s2 = zd(a2); !(o2 = s2()).done; ) {
            var u2 = o2.value;
            if (this.classSequenceMatches(-u2.backtrack.length, u2.backtrack, e3.backtrackClassDef) && this.classSequenceMatches(1, u2.input, e3.inputClassDef) && this.classSequenceMatches(1 + u2.input.length, u2.lookahead, e3.lookaheadClassDef))
              return this.applyLookupList(u2.lookupRecords);
          }
          break;
        case 3:
          if (this.coverageSequenceMatches(-e3.backtrackGlyphCount, e3.backtrackCoverage) && this.coverageSequenceMatches(0, e3.inputCoverage) && this.coverageSequenceMatches(e3.inputGlyphCount, e3.lookaheadCoverage))
            return this.applyLookupList(e3.lookupRecords);
      }
      return false;
    }, e2;
  }();
  function Md(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  var Fd = function() {
    function e2(e3, t3, r3, n2) {
      if (void 0 === r3 && (r3 = []), this._font = e3, this.codePoints = r3, this.id = t3, this.features = {}, Array.isArray(n2))
        for (var i2 = 0; i2 < n2.length; i2++) {
          var a2 = n2[i2];
          this.features[a2] = true;
        }
      else
        "object" == typeof n2 && Object.assign(this.features, n2);
      this.ligatureID = null, this.ligatureComponent = null, this.isLigated = false, this.cursiveAttachment = null, this.markAttachment = null, this.shaperInfo = null, this.substituted = false, this.isMultiplied = false;
    }
    var t2, r2;
    return e2.prototype.copy = function() {
      return new e2(this._font, this.id, this.codePoints, this.features);
    }, t2 = e2, (r2 = [{ key: "id", get: function() {
      return this._id;
    }, set: function(e3) {
      this._id = e3, this.substituted = true;
      var t3 = this._font.GDEF;
      if (t3 && t3.glyphClassDef) {
        var r3 = jd.prototype.getClassID(e3, t3.glyphClassDef);
        this.isBase = 1 === r3, this.isLigature = 2 === r3, this.isMark = 3 === r3, this.markAttachmentType = t3.markAttachClassDef ? jd.prototype.getClassID(e3, t3.markAttachClassDef) : 0;
      } else
        this.isMark = this.codePoints.length > 0 && this.codePoints.every(kh), this.isBase = !this.isMark, this.isLigature = this.codePoints.length > 1, this.markAttachmentType = 0;
    } }]) && Md(t2.prototype, r2), e2;
  }();
  var Rd = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    return r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.planFeatures = function(e3) {
      e3.add(["ljmo", "vjmo", "tjmo"], false);
    }, n2.assignFeatures = function(e3, t3) {
      for (var r3 = 0, n3 = 0; n3 < t3.length; ) {
        var i2, a2 = t3[n3].codePoints[0], o2 = Nd(a2), s2 = Wd[r3][o2];
        switch (i2 = s2[0], r3 = s2[1], i2) {
          case qd:
            e3.font.hasGlyphForCodePoint(a2) || (n3 = Yd(t3, n3, e3.font));
            break;
          case Gd:
            n3 = Xd(t3, n3, e3.font);
            break;
          case Vd:
            Zd(t3, n3, e3.font);
            break;
          case _d:
            n3 = Kd(t3, n3, e3.font);
        }
        n3++;
      }
    }, n2;
  }(Sd);
  !function(e2, t2, r2) {
    t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2;
  }(Rd, "zeroMarkWidths", "NONE");
  function Nd(e2) {
    return function(e3) {
      return 4352 <= e3 && e3 <= 4447 || 43360 <= e3 && e3 <= 43388;
    }(e2) ? 1 : function(e3) {
      return 4448 <= e3 && e3 <= 4519 || 55216 <= e3 && e3 <= 55238;
    }(e2) ? 2 : function(e3) {
      return 4520 <= e3 && e3 <= 4607 || 55243 <= e3 && e3 <= 55291;
    }(e2) ? 3 : function(e3) {
      return e3 - 44032 < 11173 && (e3 - 44032) % 28 == 0;
    }(e2) ? 4 : function(e3) {
      return 44032 <= e3 && e3 <= 55204;
    }(e2) ? 5 : function(e3) {
      return 12334 <= e3 && e3 <= 12335;
    }(e2) ? 6 : 0;
  }
  var qd = 1, Gd = 2, Vd = 4, _d = 5, Wd = [[[0, 0], [0, 1], [0, 0], [0, 0], [qd, 2], [qd, 3], [_d, 0]], [[0, 0], [0, 1], [Gd, 2], [0, 0], [qd, 2], [qd, 3], [_d, 0]], [[0, 0], [0, 1], [0, 0], [Gd, 3], [qd, 2], [qd, 3], [Vd, 0]], [[0, 0], [0, 1], [0, 0], [0, 0], [qd, 2], [qd, 3], [Vd, 0]]];
  function Hd(e2, t2, r2) {
    return new Fd(e2, e2.glyphForCodePoint(t2).id, [t2], r2);
  }
  function Yd(e2, t2, r2) {
    var n2 = e2[t2], i2 = n2.codePoints[0] - 44032, a2 = 4519 + i2 % 28, o2 = 4352 + (i2 = i2 / 28 | 0) / 21 | 0, s2 = 4449 + i2 % 21;
    if (!r2.hasGlyphForCodePoint(o2) || !r2.hasGlyphForCodePoint(s2) || 4519 !== a2 && !r2.hasGlyphForCodePoint(a2))
      return t2;
    var u2 = Hd(r2, o2, n2.features);
    u2.features.ljmo = true;
    var l2 = Hd(r2, s2, n2.features);
    l2.features.vjmo = true;
    var c2 = [u2, l2];
    if (a2 > 4519) {
      var f2 = Hd(r2, a2, n2.features);
      f2.features.tjmo = true, c2.push(f2);
    }
    return e2.splice.apply(e2, [t2, 1].concat(c2)), t2 + c2.length - 1;
  }
  function Xd(e2, t2, r2) {
    var n2, i2, a2, o2, s2 = e2[t2], u2 = Nd(e2[t2].codePoints[0]), l2 = e2[t2 - 1].codePoints[0], c2 = Nd(l2);
    if (4 === c2 && 3 === u2)
      n2 = l2, o2 = s2;
    else {
      2 === u2 ? (i2 = e2[t2 - 1], a2 = s2) : (i2 = e2[t2 - 2], a2 = e2[t2 - 1], o2 = s2);
      var f2 = i2.codePoints[0], h2 = a2.codePoints[0];
      (function(e3) {
        return 4352 <= e3 && e3 <= 4370;
      })(f2) && function(e3) {
        return 4449 <= e3 && e3 <= 4469;
      }(h2) && (n2 = 44032 + 28 * (21 * (f2 - 4352) + (h2 - 4449)));
    }
    var d2 = o2 && o2.codePoints[0] || 4519;
    if (null != n2 && (4519 === d2 || function(e3) {
      return 1 <= e3 && e3 <= 4546;
    }(d2))) {
      var p2 = n2 + (d2 - 4519);
      if (r2.hasGlyphForCodePoint(p2)) {
        var y2 = 2 === c2 ? 3 : 2;
        return e2.splice(t2 - y2 + 1, y2, Hd(r2, p2, s2.features)), t2 - y2 + 1;
      }
    }
    return i2 && (i2.features.ljmo = true), a2 && (a2.features.vjmo = true), o2 && (o2.features.tjmo = true), 4 === c2 ? (Yd(e2, t2 - 1, r2), t2 + 1) : t2;
  }
  function Zd(e2, t2, r2) {
    var n2 = e2[t2], i2 = e2[t2].codePoints[0];
    if (0 !== r2.glyphForCodePoint(i2).advanceWidth) {
      var a2 = function(e3) {
        switch (Nd(e3)) {
          case 4:
          case 5:
            return 1;
          case 2:
            return 2;
          case 3:
            return 3;
        }
      }(e2[t2 - 1].codePoints[0]);
      return e2.splice(t2, 1), e2.splice(t2 - a2, 0, n2);
    }
  }
  function Kd(e2, t2, r2) {
    var n2 = e2[t2], i2 = e2[t2].codePoints[0];
    if (r2.hasGlyphForCodePoint(9676)) {
      var a2 = Hd(r2, 9676, n2.features), o2 = 0 === r2.glyphForCodePoint(i2).advanceWidth ? t2 : t2 + 1;
      e2.splice(o2, 0, a2), t2++;
    }
    return t2;
  }
  function Jd(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Qd(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Qd(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Qd(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var $d = function() {
    function e2(e3) {
      this.stateTable = e3.stateTable, this.accepting = e3.accepting, this.tags = e3.tags;
    }
    var t2 = e2.prototype;
    return t2.match = function(e3) {
      var t3, r2 = this;
      return (t3 = {})[Symbol.iterator] = regeneratorRuntime.mark(function t4() {
        var n2, i2, a2, o2, s2, u2;
        return regeneratorRuntime.wrap(function(t5) {
          for (; ; )
            switch (t5.prev = t5.next) {
              case 0:
                n2 = 1, i2 = null, a2 = null, o2 = null, s2 = 0;
              case 5:
                if (!(s2 < e3.length)) {
                  t5.next = 21;
                  break;
                }
                if (u2 = e3[s2], o2 = n2, 0 !== (n2 = r2.stateTable[n2][u2])) {
                  t5.next = 15;
                  break;
                }
                if (!(null != i2 && null != a2 && a2 >= i2)) {
                  t5.next = 13;
                  break;
                }
                return t5.next = 13, [i2, a2, r2.tags[o2]];
              case 13:
                n2 = r2.stateTable[1][u2], i2 = null;
              case 15:
                0 !== n2 && null == i2 && (i2 = s2), r2.accepting[n2] && (a2 = s2), 0 === n2 && (n2 = 1);
              case 18:
                s2++, t5.next = 5;
                break;
              case 21:
                if (!(null != i2 && null != a2 && a2 >= i2)) {
                  t5.next = 24;
                  break;
                }
                return t5.next = 24, [i2, a2, r2.tags[n2]];
              case 24:
              case "end":
                return t5.stop();
            }
        }, t4);
      }), t3;
    }, t2.apply = function(e3, t3) {
      for (var r2, n2 = Jd(this.match(e3)); !(r2 = n2()).done; )
        for (var i2, a2 = r2.value, o2 = a2[0], s2 = a2[1], u2 = Jd(a2[2]); !(i2 = u2()).done; ) {
          var l2 = i2.value;
          "function" == typeof t3[l2] && t3[l2](o2, s2, e3.slice(o2, s2 + 1));
        }
    }, e2;
  }(), ep = 1, tp = 8, rp = 16, np = 32, ip = 64, ap = 128, op = 8192, sp = 32768, up = 65536, lp = 1 << 17, cp = { Start: 1, Ra_To_Become_Reph: 2, Pre_M: 4, Pre_C: 8, Base_C: 16, After_Main: 32, Above_C: 64, Before_Sub: 128, Below_C: 256, After_Sub: 512, Before_Post: 1024, Post_C: 2048, After_Post: 4096, Final_C: 8192, SMVD: 16384, End: 32768 }, fp = 2 | up | lp | 4 | 2048 | 4096, hp = ip | np, dp = rp | 16384, pp = { Default: { hasOldSpec: false, virama: 0, basePos: "Last", rephPos: cp.Before_Post, rephMode: "Implicit", blwfMode: "Pre_And_Post" }, Devanagari: { hasOldSpec: true, virama: 2381, basePos: "Last", rephPos: cp.Before_Post, rephMode: "Implicit", blwfMode: "Pre_And_Post" }, Bengali: { hasOldSpec: true, virama: 2509, basePos: "Last", rephPos: cp.After_Sub, rephMode: "Implicit", blwfMode: "Pre_And_Post" }, Gurmukhi: { hasOldSpec: true, virama: 2637, basePos: "Last", rephPos: cp.Before_Sub, rephMode: "Implicit", blwfMode: "Pre_And_Post" }, Gujarati: { hasOldSpec: true, virama: 2765, basePos: "Last", rephPos: cp.Before_Post, rephMode: "Implicit", blwfMode: "Pre_And_Post" }, Oriya: { hasOldSpec: true, virama: 2893, basePos: "Last", rephPos: cp.After_Main, rephMode: "Implicit", blwfMode: "Pre_And_Post" }, Tamil: { hasOldSpec: true, virama: 3021, basePos: "Last", rephPos: cp.After_Post, rephMode: "Implicit", blwfMode: "Pre_And_Post" }, Telugu: { hasOldSpec: true, virama: 3149, basePos: "Last", rephPos: cp.After_Post, rephMode: "Explicit", blwfMode: "Post_Only" }, Kannada: { hasOldSpec: true, virama: 3277, basePos: "Last", rephPos: cp.After_Post, rephMode: "Implicit", blwfMode: "Post_Only" }, Malayalam: { hasOldSpec: true, virama: 3405, basePos: "Last", rephPos: cp.After_Main, rephMode: "Log_Repha", blwfMode: "Pre_And_Post" }, Khmer: { hasOldSpec: false, virama: 6098, basePos: "First", rephPos: cp.Ra_To_Become_Reph, rephMode: "Vis_Repha", blwfMode: "Pre_And_Post" } }, yp = { 6078: [6081, 6078], 6079: [6081, 6079], 6080: [6081, 6080], 6084: [6081, 6084], 6085: [6081, 6085] }, gp = "eJzNmVtv2zYUx7+LnvnA+6Vva4a0K5BsWLcWmBEEsqMG3mw5kJUOQ9HvvsOLLUp2owsVwGBCmj8d/nl0DkkzyLdsldfF465aF/vszSL7NUPZL7c/Q/0Rft+9hcr+Xt9AdfXuA9Sfbn5afnXtb/vatqHre1c3bzf/um5V2Mb33jt7//kqjD907Ty/2/n+tBMF0Rs//NqbXnt47UeUz5uNtQ86Hw8zhjF/fb794Bpbu8r6/slOc2tdsZUbeoeyh2K12z7t9ut6vSvh/b9lVGAFcYCGIcoNByP4rI9IEGOR1g5prRA1mDpkyBFppT2ikRUDxDCxA6HhiGEsPTIeiQZR3FgxYhHh3CLCKWJEWHlGpUNUMsSoFg4p4pDCEaIRkh7xBsmARIyOozl2o5nRCCrsEfPIRIgfrThxAwWXFgkObyUY9khHKFiZGDWmAjdcuABI5jyUkiD4bBPDlHSeKA2eKGmzwIxwVkZATIzgHqkISY+sJxySAUhqj0yDnGngEntuIkQa1DI1zUQOSePyAQ1G0kjhEfOIRkh6xCOkPBIRMh7pBhnGHTNMATRUBSoC1UeqMHcpti1BULt42Z6Mqfa2mjNHNbdUcxoojyk7UNmytZ4pgo0NsW0lgtrrQs8EqgL9jrJ9DUfQH/lyU8CzBUazlTu0oAj2C+JQBBBwBWlkEMGIEEQoIgzBHoOdRyQ8JgpB+u0TgyhGlCBKgxZlvvE1txW85yzOUnn0dqKAPXHa/VNBaqBi8APbB0ICSxTOFthdsNUVYnbRI+4tIY3wAM4ZDoGDyImgwOVRjBlP1EwhaPLV9A75ii0I7756O0v9irijeBLLsYKHJeXcowN8DCup/7XN4NceKHlm5WO/8HHfuo+mFi+EwEvPHoN0TaK7D8eX3rWUvjp7zqdXTRPAMTEdeKTO4zLXLXHbHSzOzciAkMM5NygiZ3T7yoRDq1eS/PjhNLmRqza2SNz904twFXnxlE5I9Vxupqp1v+/TvZtZru9lo7tIbMS6XnQuIANETzS7ZbxkfGdyE8gBrkZ3pd4AsGadzSd79o6HR1zxAlB9AfH6rxKRdF3+8mIYVAYsshkW7lw386S0MTEyvmekBW05D93hzgs2xXs+yv1z4n1lyjnUq9n9kkzXG7/eYqO5z56kLP34G7xzFZz1D5iUa+ZZ8bRycpNJEuP9Kevs3fm/LlIOh7MzJMTjGOE7lOWrVfFUr8vH7M3iS77ZF6iunidX6QqXVkGI6vzR/oNgAeHPltXun6K8X22e93VRZRaty4fiqYCqrFt8/992udu0UZ2XD3n10IJnJC8BXYof01H5vC2qfNNnNiZ/A1N6gfDrusq3+T10t+syr4tL8u014PQlAmxZVPd/79YlNMkBO5ni7vv/LbyJLg==";
  function vp(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return bp(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return bp(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function bp(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var mp = JSON.parse(String.fromCharCode.apply(String, rh.inflate(ih("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")))), wp = JSON.parse(String.fromCharCode.apply(String, rh.inflate(ih(gp)))), Sp = rh.inflate(ih("eJwBdw+I8AARAAAAAAAAAADYYAFmD5nw7Z17jFxVHcfv7s7OzO7M7nQLRAhiUSDEUG1AIrYUFpBgColYTaRVUUQJiEFQg5A2CAhqLSAPQUws/CHlL4r+wUNjwbQSESwQUCFgFLCoNQSsUQKiIH7P3HPmnjlz3o97Z2V+ySf3cc4953d+v/O+d2eX1LLsYLAMHAFOBqeAT4DPgneD90Y4ng7OBl8C6xyeWw8uAxvANeC74GawGWwBd4J7NM9fAC4GPwe/AveDR8AT4GmwBPwF/A28DObBf0F9Mg+bxXFP8FZwIFgKDgMrwHHgRPAhsAacBs4CXwBfAV8F3wBXguvBJrAZbAF3gq3gPvAgeAw8Bf4IdoHd4BXwBpisZ9kM2AvsBw4ES8HhYCU4Fqyq57qvxnENOI1en4XjeeBCcBG4HFwBvkPDv4/jLeA2cAfYWs/LfR892vIgjf8Yjr8ET9Hrx+nxOvAMzh/intnlmIcNz3Bp7sb5K+AN0GhkWQe8BSwBB4Nl4IhGf3xynKf3HgYfwPnJ4BTwqUZurzNxPJfGuYDeuxjHb4KrG3l9mqfciOtNYDO4DdwBttJn7qPHHTj+hqb3VIPaCsc/N/RlfdEQztv4JcTdQe/dDV7Dda2ZZe1mEXcPnO9Lr08CBzQH0ztEci+Uw5p523N5ZkUCPVJzNHQ+XqL38+BaSfwTaVzWFlfjei34NIWPeyStb5/j7q/Q6ELq9he5uN+mxw1CvAubef/L67qOPve1plxvhi5sxIgRfjw8BDqMGDFixIgRI0aMWHgcOQQ6iDxH17rfcljfr1TcX6555lqkfz3YBDaDLeBOcA/YDh4Aj4InwbNgVzPfW9qN4z/Bf8DEVJa1wBzYB7x9Kt/PeSeOh4Ll4FhwBi3LZi7/Vbi/eqp6e48YMWLEmwmyb7kWfe/7asU+fVVUbYsRI0bE4QRuzkrec86D09DPnAXOE+Z6FzrO/U6ix3max1HgkqnifeoGnF8tpHnDVPFeh4e8l7kJYbcOwfzztUU5K+dgI/CTRWY2IN4Dirgv4P7+i7NsDbgGPLq4P/z3CG/ukWV7gzXgkuks2wayVpYdAy4hR3KPHnfSI8872ln2vbGc03H+g/ZgnJ24Nz5TXB+H80vBdjA2i3UBuHS2SCcW22mar+K4vJOfH9/pj7Ouk+v0086g3iNGjBgxohz+XXEfHHv8cWHFourzn6+9ubkc3I554F1Tg+tR8p3Pvbi/jZsn3o/zR6by+egOSXrs+7sn6PqanD89lX9TR9LbSdN6XpLfEprmPxD2Mvc82zd9fcpv/Uy+mSLfTBwl0XcSbaAJFk0Xc+O9p/Ow/XE8GCyb7s/viOliHj6P8xPAB6eL/Fi8j9J7n5zOv/s6A8fPgy9PD+q/frq4XkbTvow+v3Ha7Md5qrvMPsR+D0nCiF2uQ9o3gpvBLeA28CPwY3Av+AV4CPwW/A7sBLvAbvAKeAPUWkWabZzvCfYFB4BDwKFgOTi2NajDvdBhFe6vpmFrcTwVnCGJy+Kfg7DzW8X1RTj/OrgK/AzXN+B4Ew2/FcfbFWkRSPy7WoM2I5wqqW/dPBF/O3gQPAYeB39o5Xv/f8LxhVb+/O662WcvIe6rYAzrhTpogbl2Eb4PzvcDB4F3gfe0i7KZOLKtDiP6vb9d/npPrId82EkafY62KK8PZZdfxkc0fiqLWGUh3/JWlT9pb6QP/DhnTzJOfYarV2fi/Jx28b1sKjuua8rvn091Wc/peHRE+y9EdO9pY7DMs06WiakMbGy/DPVmo2O/PQzvOVzKfw3Kd0M7XZ/van/2ve2VivD13Nxvk6Qv57/DJ3Mu2byAhd9Nj+TvmjYjrS3U13fg+EOw1cH3L1r8fc0xCf6OYht0fGAIxjRbHoWuTxrmSs+2+8cV2zq1zHLuXiUqP/613R/+9xJ8+i9av1/n8iLvMGRrTQZpI5MzWTYD9gL7gYNm8rClM3bl5/+uibTXjeDwmbztP8e1I3Z+FZ2Dr0Sc42fyPvbEGXn7V9k3NUT3D8/03+P7ItIPreTKvpH2Y2S9+DHObpdzz5xO0zsbxytqg2mfi/vnW9h8mKjKP6lZ2/z/Lh/P65pxcUdJOgwrv644/0cU+yhlEloG3fizELhIGAdc7JNqrbyQ/L+QIXX3bbWxLp0sW3CQ/WX+3IaqdR5W3uxStf2j1U36exYLQtchhokp3BSvw4Wb4vnqWbWtFlo5bHw2TMj0XUj668qkkip18dW5Kv2HvU5UaZOy646tVK33QvV/jLSqsD+vt2v+KSRVGRdKWWab/dTGIzAWkUV28aYaOc0JlGNxfj7eKO670KwVz3ZtNE2hNuLjGnWjNpni0iO4rtO9bd3q92+mS4vCRHXt6sPusxr/snBeZGkQYf5tU/+2Jf5jMk7jMGnT+MS/Yn4yaTcG7w2USfBvL56lf1n9dmmv5MjnZevfgbKU7F8xrnhOhPiX2Z75lyHzT1vhX15I29WJqjzaZyz92+tXxwo/1+bcxgDX9st8qrwuyb+27VeE1W3WppiPZf4NHUuZTcS65No/a/MY48YQUJ8oINJYIP2zq38nLfrnSYv2K5NJRZ8Qu3/uZEW7DZnHsX67m7dF/6xry6qxkp2L92TxxHvK+5bzL1H4tizrv9nYPC60bULdsn3L/K+SFO9FZCLOp23m1F39DP6O2Z5d/UnaM/l9aBG+TfH3xeu6oT3zz+nqFG8X/hkX/+rEZ72knZsPgX9VcZmw/trGv/w1O7fxr9j3yqSnawT/djo5PiL6l9epLP9qsWy/BGZ3Nh6rIGLqj7s2VfiN0W7o2w5vk9D5lglTv+Y6n7adc8vsEgOrNCVrads+XtaGVfsjLIwd2V6JbL9FJa79Nb9/4iqxfeELW7fbIgp5nm+n443+fSpy5NcWhG77bxZxYqxrxDqpsnEK25vyDLF3dz9vLoeJzN7MF0REe9ezol/JHOytqqsp9qd5mhRlP2q7j+VQr/j62qE2FPMlJpmw8HGKOqbrJzOPOsXaIGuHZDwm9aSu0n3Onm75HeKngLUHHfzet2wd5VN3ZVJ1H9/Fcr6gqiuycZTUne5cnaw5Zvv7qh4kb5d9Da6f5/c6ZGUY6Cd1dXYsj9OayGFx2LPsPg+fljEvG+YGbSnLl9Ck+Xf1sLQfe1Z8r2Oq4zLpCOehyNKxST8LfD40/9Tl80m3DHhJnYdveKryiuKzbu4+J9yzWYPEyl8Gn79NuVPl7yox7E/EO/+yxmibfZQIewLM97r9FxF+rdHbg6Fjf/d8Jofdl6VB5gim/RgC2xvq2T9wHzW0Dyir/46Rf2z9CV37ltUGJO3YZY3Mr5OZsPvd9x6aNYNuj0NmT+s1ZkybeOz9uY53A/bz8BkvqvUEv1ekWmPI/CvC5r1K/R32AqR+Tli/ZWWPkr+qXrBwiR27a3/ZOnrWb39BtS9I2uHAHtVE/7N83Qnt/0Of59+9sDHPe/xNUIdE25n8Id5v1fTp+9rTZ6whdbCZFXtRMlzHQWu/pRzLJOOMzBekrfXtnYzZ25vMm6R5KvoG23pjGh9FGZg/KGyhq5O6/p7ft2xO6PN2Gaf76jinb+j8yTTepkybCP+dV0e4tmaxgOQesxcJ488Zqj42hn1t7WTa89XpY6tvZjjqngnxf4q0bfOzzcNLl0lQL65jjDU+evTKbbGGldLInP8G2Nd3vIT62/StsklCdI+hvy7tFOKqU60dt4zKepuYVPmE2lgnofWiLJv66lB1eGxb+NpIJ2XXx9T1I9Q+w1R/XfJIUTdcxUZf/v01v/6sS9bh/N/ppNx/kr0bUtkw1PdJ19k6TOv9cc2aWbaGHSu+t3apc9H+rjXhXoXLPh/52xj++zKV9Op/6H6cz/rVZk1L0bVbl/3I0uuzhOZEQa8cifsP3T6O6/vXDtdetHt4KrtEtrluz4zfy+p7P1HzH9dC2ovO36yftyp3QH3PMk39TN0+LOqpuP8oe/9hkpBvFDMP/w70S4G2GUhDsa9Cwlr0XY34fVxs36jeDYr32Xe67JhadPM5m7LKyiRLk31TGaKXaW7sEq4Tb9/zdrPtDwxtyjQekTKxbyR7+gfOR1zmwKFrHd85t4vurmWMrb/ufqaIW6aOvraWSRX5hpa3DH+HPG9T3tjlCLGlya4pwk32sbWTrfjWJ1N4SH0JTdtGf9fnbeyWqi7GyM8nDVmZq5TYNg3NvyydU/k+lq62EppeCru4pO8iMdqKSQ+db1PVH1UZq6i/Lv6JWY9D8gi1eYq8XHSqIv+qym/Kk6x7J4VvY8mR/50qXlg88Xfe+vbkNNepYFLn9qQHyj4bthaX2S9mG/bJyzZf3zSHqV2lLI+LzVwl1Ge+acfKIzT/FD7wLWtoOn2/hdXJGbp3rIb9bxl1w3skUazf2wT0tSbpfpfu81vOke1r+t1l8g6bf0ca2kY7wvkwtzutf0qo/6a2oPMd+9skIr5/l8LnayNl9hNinbSRKL+dntC/rr+BTt6f677LILC/BeHf8/T85VkveJvH6kt9+tRYvuqmlWB8IvWM+Ih9n6GyI/uOXKc/01Gmq6/+Ps/r2lrVbcgF9ndSxvFvQt3/hdZp39+v5OMN2D6y7/lwVVwibN3K/p+DCibi7/3zfRoTXV1T+aSTDfbxYt66b9/6/GMIN0mKeuszTrDvEBnMT6Z5kUv9Zr5iY47t7+2m7CNsbKUK77NXTW4zo/8D+4dUZWcihsvKHHONPFC/BJ+L+sXwvyt8+dl8yXetk/L7mRhrMaP+juOp7ZjaqhW/46bNv4R1eKzyh9LL0+KbLVO7drWfbv2XamyS9TMD+jvOhcreI2GiKxs/ZoxLfJRS+D7VROr6LRtj+n6XX/xmUbHu7N23+AbUpfwyGyjHLcfvmfvKOius/RTzsCrEZl4mjZewvujWEaY5W6htY+9n+ParLmOG63f2pm+GVXPE0PrEh/fOS6xHvIj1iZ3z6yUW1m2/ncJ+MeqPq/2ktku8N6lrf/y52M9p7RNLx9bg3Mimrcdax/hIjDxDdUmRv4s+vvaNNUaG+ju0PsS2dYx6GyutVPqVlb6NhKblqs8w+j6Gvqb4ZYtMJ/Gav+9jM5tnfdKOVTdcfWSrs204L6lsFCIp/BUqZdQl17xUcVNIqM1T2CQ0bRd7haYZ+lwMiVFHQ+0o0yfL+p/X1W1Tm5ClqdNNZXPVUZanTn+b9GTPm8pnW36dTXxtG6tu2OSTMn8XiZFOqP4pyh/DtmX4InW+of4N1Se0HFW1i9D8beq5az6muCn0NuWts5ePxPBnTP+Hyv8AKXRL6A==")), xp = wp.decompositions, Ap = new fc(Sp), kp = new $d(mp), Cp = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    return r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.planFeatures = function(e3) {
      e3.addStage(Ep), e3.addStage(["locl", "ccmp"]), e3.addStage(Dp), e3.addStage("nukt"), e3.addStage("akhn"), e3.addStage("rphf", false), e3.addStage("rkrf"), e3.addStage("pref", false), e3.addStage("blwf", false), e3.addStage("abvf", false), e3.addStage("half", false), e3.addStage("pstf", false), e3.addStage("vatu"), e3.addStage("cjct"), e3.addStage("cfar", false), e3.addStage(jp), e3.addStage({ local: ["init"], global: ["pres", "abvs", "blws", "psts", "haln", "dist", "abvm", "blwm", "calt", "clig"] }), e3.unicodeScript = function(e4) {
        return Th[e4];
      }(e3.script), e3.indicConfig = pp[e3.unicodeScript] || pp.Default, e3.isOldSpec = e3.indicConfig.hasOldSpec && "2" !== e3.script[e3.script.length - 1];
    }, n2.assignFeatures = function(e3, t3) {
      for (var r3 = function(r4) {
        var n4 = t3[r4].codePoints[0], i2 = yp[n4] || xp[n4];
        if (i2) {
          var a2 = i2.map(function(n5) {
            var i3 = e3.font.glyphForCodePoint(n5);
            return new Fd(e3.font, i3.id, [n5], t3[r4].features);
          });
          t3.splice.apply(t3, [r4, 1].concat(a2));
        }
      }, n3 = t3.length - 1; n3 >= 0; n3--)
        r3(n3);
    }, n2;
  }(Sd);
  function Pp(e2) {
    return Ap.get(e2.codePoints[0]) >> 8;
  }
  function Ip(e2) {
    return 1 << (255 & Ap.get(e2.codePoints[0]));
  }
  !function(e2, t2, r2) {
    t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2;
  }(Cp, "zeroMarkWidths", "NONE");
  var Op = function(e2, t2, r2, n2) {
    this.category = e2, this.position = t2, this.syllableType = r2, this.syllable = n2;
  };
  function Ep(e2, t2) {
    for (var r2, n2 = 0, i2 = 0, a2 = vp(kp.match(t2.map(Pp))); !(r2 = a2()).done; ) {
      var o2 = r2.value, s2 = o2[0], u2 = o2[1], l2 = o2[2];
      if (s2 > i2) {
        ++n2;
        for (var c2 = i2; c2 < s2; c2++)
          t2[c2].shaperInfo = new Op(ep, cp.End, "non_indic_cluster", n2);
      }
      ++n2;
      for (var f2 = s2; f2 <= u2; f2++)
        t2[f2].shaperInfo = new Op(1 << Pp(t2[f2]), Ip(t2[f2]), l2[0], n2);
      i2 = u2 + 1;
    }
    if (i2 < t2.length) {
      ++n2;
      for (var h2 = i2; h2 < t2.length; h2++)
        t2[h2].shaperInfo = new Op(ep, cp.End, "non_indic_cluster", n2);
    }
  }
  function Bp(e2) {
    return e2.shaperInfo.category & fp;
  }
  function Tp(e2) {
    return e2.shaperInfo.category & hp;
  }
  function Lp(e2) {
    return e2.shaperInfo.category & dp;
  }
  function zp(e2, t2) {
    for (var r2, n2 = vp(e2); !(r2 = n2()).done; ) {
      var i2;
      r2.value.features = ((i2 = {})[t2] = true, i2);
    }
    return e2[0]._font._layoutEngine.engine.GSUBProcessor.applyFeatures([t2], e2), 1 === e2.length;
  }
  function Up(e2, t2, r2) {
    var n2 = [r2, t2, r2];
    return zp(n2.slice(0, 2), "blwf") || zp(n2.slice(1, 3), "blwf") ? cp.Below_C : zp(n2.slice(0, 2), "pstf") || zp(n2.slice(1, 3), "pstf") || zp(n2.slice(0, 2), "pref") || zp(n2.slice(1, 3), "pref") ? cp.Post_C : cp.Base_C;
  }
  function Dp(e2, t2, r2) {
    var n2 = r2.indicConfig, i2 = e2._layoutEngine.engine.GSUBProcessor.features, a2 = e2.glyphForCodePoint(9676).id, o2 = e2.glyphForCodePoint(n2.virama).id;
    if (o2)
      for (var s2 = new Fd(e2, o2, [n2.virama]), u2 = 0; u2 < t2.length; u2++)
        t2[u2].shaperInfo.position === cp.Base_C && (t2[u2].shaperInfo.position = Up(0, t2[u2].copy(), s2));
    for (var l2 = 0, c2 = Mp(t2, 0); l2 < t2.length; c2 = Mp(t2, l2 = c2)) {
      var f2 = t2[l2].shaperInfo, h2 = (f2.category, f2.syllableType);
      if ("symbol_cluster" !== h2 && "non_indic_cluster" !== h2) {
        if ("broken_cluster" === h2 && a2) {
          var d2 = new Fd(e2, a2, [9676]);
          d2.shaperInfo = new Op(1 << Pp(d2), Ip(d2), t2[l2].shaperInfo.syllableType, t2[l2].shaperInfo.syllable);
          for (var p2 = l2; p2 < c2 && t2[p2].shaperInfo.category === sp; )
            p2++;
          t2.splice(p2++, 0, d2), c2++;
        }
        var y2 = c2, g2 = l2, v2 = false;
        if (n2.rephPos !== cp.Ra_To_Become_Reph && i2.rphf && l2 + 3 <= c2 && ("Implicit" === n2.rephMode && !Tp(t2[l2 + 2]) || "Explicit" === n2.rephMode && t2[l2 + 2].shaperInfo.category === ip)) {
          var b2 = [t2[l2].copy(), t2[l2 + 1].copy(), t2[l2 + 2].copy()];
          if (zp(b2.slice(0, 2), "rphf") || "Explicit" === n2.rephMode && zp(b2, "rphf")) {
            for (g2 += 2; g2 < c2 && Tp(t2[g2]); )
              g2++;
            y2 = l2, v2 = true;
          }
        } else if ("Log_Repha" === n2.rephMode && t2[l2].shaperInfo.category === sp) {
          for (g2++; g2 < c2 && Tp(t2[g2]); )
            g2++;
          y2 = l2, v2 = true;
        }
        switch (n2.basePos) {
          case "Last":
            var m2 = c2, w2 = false;
            do {
              var S2 = t2[--m2].shaperInfo;
              if (Bp(t2[m2])) {
                if (S2.position !== cp.Below_C && (S2.position !== cp.Post_C || w2)) {
                  y2 = m2;
                  break;
                }
                S2.position === cp.Below_C && (w2 = true), y2 = m2;
              } else if (l2 < m2 && S2.category === ip && t2[m2 - 1].shaperInfo.category === rp)
                break;
            } while (m2 > g2);
            break;
          case "First":
            for (var x2 = (y2 = l2) + 1; x2 < c2; x2++)
              Bp(t2[x2]) && (t2[x2].shaperInfo.position = cp.Below_C);
        }
        v2 && y2 === l2 && g2 - y2 <= 2 && (v2 = false);
        for (var A2 = l2; A2 < y2; A2++) {
          var k2 = t2[A2].shaperInfo;
          k2.position = Math.min(cp.Pre_C, k2.position);
        }
        y2 < c2 && (t2[y2].shaperInfo.position = cp.Base_C);
        for (var C2 = y2 + 1; C2 < c2; C2++)
          if (t2[C2].shaperInfo.category === ap) {
            for (var P2 = C2 + 1; P2 < c2; P2++)
              if (Bp(t2[P2])) {
                t2[P2].shaperInfo.position = cp.Final_C;
                break;
              }
            break;
          }
        if (v2 && (t2[l2].shaperInfo.position = cp.Ra_To_Become_Reph), r2.isOldSpec) {
          for (var I2 = "Malayalam" !== r2.unicodeScript, O2 = y2 + 1; O2 < c2; O2++)
            if (t2[O2].shaperInfo.category === rp) {
              var E2 = void 0;
              for (E2 = c2 - 1; E2 > O2 && !(Bp(t2[E2]) || I2 && t2[E2].shaperInfo.category === rp); E2--)
                ;
              if (t2[E2].shaperInfo.category !== rp && E2 > O2) {
                var B2 = t2[O2];
                t2.splice.apply(t2, [O2, 0].concat(t2.splice(O2 + 1, E2 - O2))), t2[E2] = B2;
              }
              break;
            }
        }
        for (var T2 = cp.Start, L2 = l2; L2 < c2; L2++) {
          var z2 = t2[L2].shaperInfo;
          if (z2.category & (hp | tp | op | lp | dp & z2.category)) {
            if (z2.position = T2, z2.category === rp && z2.position === cp.Pre_M) {
              for (var U2 = L2; U2 > l2; U2--)
                if (t2[U2 - 1].shaperInfo.position !== cp.Pre_M) {
                  z2.position = t2[U2 - 1].shaperInfo.position;
                  break;
                }
            }
          } else
            z2.position !== cp.SMVD && (T2 = z2.position);
        }
        for (var D2 = y2, j2 = y2 + 1; j2 < c2; j2++)
          if (Bp(t2[j2])) {
            for (var M2 = D2 + 1; M2 < j2; M2++)
              t2[M2].shaperInfo.position < cp.SMVD && (t2[M2].shaperInfo.position = t2[j2].shaperInfo.position);
            D2 = j2;
          } else
            t2[j2].shaperInfo.category === ap && (D2 = j2);
        var F2 = t2.slice(l2, c2);
        F2.sort(function(e3, t3) {
          return e3.shaperInfo.position - t3.shaperInfo.position;
        }), t2.splice.apply(t2, [l2, F2.length].concat(F2));
        for (var R2 = l2; R2 < c2; R2++)
          if (t2[R2].shaperInfo.position === cp.Base_C) {
            y2 = R2;
            break;
          }
        for (var N2 = l2; N2 < c2 && t2[N2].shaperInfo.position === cp.Ra_To_Become_Reph; N2++)
          t2[N2].features.rphf = true;
        for (var q2 = !r2.isOldSpec && "Pre_And_Post" === n2.blwfMode, G2 = l2; G2 < y2; G2++)
          t2[G2].features.half = true, q2 && (t2[G2].features.blwf = true);
        for (var V2 = y2 + 1; V2 < c2; V2++)
          t2[V2].features.abvf = true, t2[V2].features.pstf = true, t2[V2].features.blwf = true;
        if (r2.isOldSpec && "Devanagari" === r2.unicodeScript)
          for (var _2 = l2; _2 + 1 < y2; _2++)
            t2[_2].shaperInfo.category !== up || t2[_2 + 1].shaperInfo.category !== rp || _2 + 1 !== y2 && t2[_2 + 2].shaperInfo.category !== ip || (t2[_2].features.blwf = true, t2[_2 + 1].features.blwf = true);
        if (i2.pref && y2 + 2 < c2)
          for (var W2 = y2 + 1; W2 + 2 - 1 < c2; W2++) {
            if (zp([t2[W2].copy(), t2[W2 + 1].copy()], "pref")) {
              for (var H2 = 0; H2 < 2; H2++)
                t2[W2++].features.pref = true;
              if (i2.cfar)
                for (; W2 < c2; W2++)
                  t2[W2].features.cfar = true;
              break;
            }
          }
        for (var Y2 = l2 + 1; Y2 < c2; Y2++)
          if (Tp(t2[Y2])) {
            var X2 = t2[Y2].shaperInfo.category === np, Z2 = Y2;
            do {
              Z2--, X2 && delete t2[Z2].features.half;
            } while (Z2 > l2 && !Bp(t2[Z2]));
          }
      }
    }
  }
  function jp(e2, t2, r2) {
    for (var n2 = r2.indicConfig, i2 = e2._layoutEngine.engine.GSUBProcessor.features, a2 = 0, o2 = Mp(t2, 0); a2 < t2.length; o2 = Mp(t2, a2 = o2)) {
      for (var s2 = !!i2.pref, u2 = a2; u2 < o2; u2++)
        if (t2[u2].shaperInfo.position >= cp.Base_C) {
          if (s2 && u2 + 1 < o2) {
            for (var l2 = u2 + 1; l2 < o2; l2++)
              if (t2[l2].features.pref) {
                if (!t2[l2].substituted || !t2[l2].isLigated || t2[l2].isMultiplied) {
                  for (u2 = l2; u2 < o2 && Lp(t2[u2]); )
                    u2++;
                  t2[u2].shaperInfo.position = cp.BASE_C, s2 = false;
                }
                break;
              }
          }
          if ("Malayalam" === r2.unicodeScript)
            for (var c2 = u2 + 1; c2 < o2; c2++) {
              for (; c2 < o2 && Tp(t2[c2]); )
                c2++;
              if (c2 === o2 || !Lp(t2[c2]))
                break;
              for (c2++; c2 < o2 && Tp(t2[c2]); )
                c2++;
              c2 < o2 && Bp(t2[c2]) && t2[c2].shaperInfo.position === cp.Below_C && (t2[u2 = c2].shaperInfo.position = cp.Base_C);
            }
          a2 < u2 && t2[u2].shaperInfo.position > cp.Base_C && u2--;
          break;
        }
      if (u2 === o2 && a2 < u2 && t2[u2 - 1].shaperInfo.category === ip && u2--, u2 < o2)
        for (; a2 < u2 && t2[u2].shaperInfo.category & (tp | dp); )
          u2--;
      if (a2 + 1 < o2 && a2 < u2) {
        var f2 = u2 === o2 ? u2 - 2 : u2 - 1;
        if ("Malayalam" !== r2.unicodeScript && "Tamil" !== r2.unicodeScript) {
          for (; f2 > a2 && !(t2[f2].shaperInfo.category & (ap | dp)); )
            f2--;
          Lp(t2[f2]) && t2[f2].shaperInfo.position !== cp.Pre_M ? f2 + 1 < o2 && Tp(t2[f2 + 1]) && f2++ : f2 = a2;
        }
        if (a2 < f2 && t2[f2].shaperInfo.position !== cp.Pre_M) {
          for (var h2 = f2; h2 > a2; h2--)
            if (t2[h2 - 1].shaperInfo.position === cp.Pre_M) {
              var d2 = h2 - 1;
              d2 < u2 && u2 <= f2 && u2--;
              var p2 = t2[d2];
              t2.splice.apply(t2, [d2, 0].concat(t2.splice(d2 + 1, f2 - d2))), t2[f2] = p2, f2--;
            }
        }
      }
      if (a2 + 1 < o2 && t2[a2].shaperInfo.position === cp.Ra_To_Become_Reph && t2[a2].shaperInfo.category === sp !== (t2[a2].isLigated && !t2[a2].isMultiplied)) {
        var y2 = void 0, g2 = n2.rephPos, v2 = false;
        if (g2 !== cp.After_Post) {
          for (y2 = a2 + 1; y2 < u2 && !Lp(t2[y2]); )
            y2++;
          if (y2 < u2 && Lp(t2[y2]) && (y2 + 1 < u2 && Tp(t2[y2 + 1]) && y2++, v2 = true), !v2 && g2 === cp.After_Main) {
            for (y2 = u2; y2 + 1 < o2 && t2[y2 + 1].shaperInfo.position <= cp.After_Main; )
              y2++;
            v2 = y2 < o2;
          }
          if (!v2 && g2 === cp.After_Sub) {
            for (y2 = u2; y2 + 1 < o2 && !(t2[y2 + 1].shaperInfo.position & (cp.Post_C | cp.After_Post | cp.SMVD)); )
              y2++;
            v2 = y2 < o2;
          }
        }
        if (!v2) {
          for (y2 = a2 + 1; y2 < u2 && !Lp(t2[y2]); )
            y2++;
          y2 < u2 && Lp(t2[y2]) && (y2 + 1 < u2 && Tp(t2[y2 + 1]) && y2++, v2 = true);
        }
        if (!v2) {
          for (y2 = o2 - 1; y2 > a2 && t2[y2].shaperInfo.position === cp.SMVD; )
            y2--;
          if (Lp(t2[y2]))
            for (var b2 = u2 + 1; b2 < y2; b2++)
              t2[b2].shaperInfo.category === ap && y2--;
        }
        var m2 = t2[a2];
        t2.splice.apply(t2, [a2, 0].concat(t2.splice(a2 + 1, y2 - a2))), t2[y2] = m2, a2 < u2 && u2 <= y2 && u2--;
      }
      if (s2 && u2 + 1 < o2) {
        for (var w2 = u2 + 1; w2 < o2; w2++)
          if (t2[w2].features.pref) {
            if (t2[w2].isLigated && !t2[w2].isMultiplied) {
              var S2 = u2;
              if ("Malayalam" !== r2.unicodeScript && "Tamil" !== r2.unicodeScript) {
                for (; S2 > a2 && !(t2[S2 - 1].shaperInfo.category & (ap | dp)); )
                  S2--;
                if (S2 > a2 && t2[S2 - 1].shaperInfo.category === ap) {
                  for (var x2 = w2, A2 = u2 + 1; A2 < x2; A2++)
                    if (t2[A2].shaperInfo.category === ap) {
                      S2--;
                      break;
                    }
                }
              }
              S2 > a2 && Lp(t2[S2 - 1]) && S2 < o2 && Tp(t2[S2]) && S2++;
              var k2 = w2, C2 = t2[k2];
              t2.splice.apply(t2, [S2 + 1, 0].concat(t2.splice(S2, k2 - S2))), t2[S2] = C2, S2 <= u2 && u2 < k2 && u2++;
            }
            break;
          }
      }
      t2[a2].shaperInfo.position !== cp.Pre_M || a2 && /Cf|Mn/.test(wh(t2[a2 - 1].codePoints[0])) || (t2[a2].features.init = true);
    }
  }
  function Mp(e2, t2) {
    if (t2 >= e2.length)
      return t2;
    for (var r2 = e2[t2].shaperInfo.syllable; ++t2 < e2.length && e2[t2].shaperInfo.syllable === r2; )
      ;
    return t2;
  }
  function Fp(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Rp(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Rp(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Rp(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Np = JSON.parse(String.fromCharCode.apply(String, rh.inflate(ih(gp)))), qp = rh.inflate(ih("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")), Gp = Np.categories, Vp = Np.decompositions, _p = new fc(qp), Wp = new $d(Np), Hp = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    return r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.planFeatures = function(e3) {
      e3.addStage(Zp), e3.addStage(["locl", "ccmp", "nukt", "akhn"]), e3.addStage(Kp), e3.addStage(["rphf"], false), e3.addStage(Jp), e3.addStage(Kp), e3.addStage(["pref"]), e3.addStage(Qp), e3.addStage(["rkrf", "abvf", "blwf", "half", "pstf", "vatu", "cjct"]), e3.addStage($p), e3.addStage(["abvs", "blws", "pres", "psts", "dist", "abvm", "blwm"]);
    }, n2.assignFeatures = function(e3, t3) {
      for (var r3 = function(r4) {
        var n4 = t3[r4].codePoints[0];
        if (Vp[n4]) {
          var i2 = Vp[n4].map(function(n5) {
            var i3 = e3.font.glyphForCodePoint(n5);
            return new Fd(e3.font, i3.id, [n5], t3[r4].features);
          });
          t3.splice.apply(t3, [r4, 1].concat(i2));
        }
      }, n3 = t3.length - 1; n3 >= 0; n3--)
        r3(n3);
    }, n2;
  }(Sd);
  function Yp(e2) {
    return _p.get(e2.codePoints[0]);
  }
  !function(e2, t2, r2) {
    t2 in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2;
  }(Hp, "zeroMarkWidths", "BEFORE_GPOS");
  var Xp = function(e2, t2, r2) {
    this.category = e2, this.syllableType = t2, this.syllable = r2;
  };
  function Zp(e2, t2) {
    for (var r2, n2 = 0, i2 = Fp(Wp.match(t2.map(Yp))); !(r2 = i2()).done; ) {
      var a2 = r2.value, o2 = a2[0], s2 = a2[1], u2 = a2[2];
      ++n2;
      for (var l2 = o2; l2 <= s2; l2++)
        t2[l2].shaperInfo = new Xp(Gp[Yp(t2[l2])], u2[0], n2);
      for (var c2 = "R" === t2[o2].shaperInfo.category ? 1 : Math.min(3, s2 - o2), f2 = o2; f2 < o2 + c2; f2++)
        t2[f2].features.rphf = true;
    }
  }
  function Kp(e2, t2) {
    for (var r2, n2 = Fp(t2); !(r2 = n2()).done; ) {
      r2.value.substituted = false;
    }
  }
  function Jp(e2, t2) {
    for (var r2, n2 = Fp(t2); !(r2 = n2()).done; ) {
      var i2 = r2.value;
      i2.substituted && i2.features.rphf && (i2.shaperInfo.category = "R");
    }
  }
  function Qp(e2, t2) {
    for (var r2, n2 = Fp(t2); !(r2 = n2()).done; ) {
      var i2 = r2.value;
      i2.substituted && (i2.shaperInfo.category = "VPre");
    }
  }
  function $p(e2, t2) {
    for (var r2 = e2.glyphForCodePoint(9676).id, n2 = 0, i2 = ey(t2, 0); n2 < t2.length; i2 = ey(t2, n2 = i2)) {
      var a2 = void 0, o2 = void 0, s2 = t2[n2].shaperInfo, u2 = s2.syllableType;
      if ("virama_terminated_cluster" === u2 || "standard_cluster" === u2 || "broken_cluster" === u2) {
        if ("broken_cluster" === u2 && r2) {
          var l2 = new Fd(e2, r2, [9676]);
          for (l2.shaperInfo = s2, a2 = n2; a2 < i2 && "R" === t2[a2].shaperInfo.category; a2++)
            ;
          t2.splice(++a2, 0, l2), i2++;
        }
        if ("R" === s2.category && i2 - n2 > 1) {
          for (a2 = n2 + 1; a2 < i2; a2++)
            if (ry(s2 = t2[a2].shaperInfo) || ty(t2[a2])) {
              ty(t2[a2]) && a2--, t2.splice.apply(t2, [n2, 0].concat(t2.splice(n2 + 1, a2 - n2), [t2[a2]]));
              break;
            }
        }
        for (a2 = n2, o2 = i2; a2 < i2; a2++)
          ry(s2 = t2[a2].shaperInfo) || ty(t2[a2]) ? o2 = ty(t2[a2]) ? a2 + 1 : a2 : ("VPre" === s2.category || "VMPre" === s2.category) && o2 < a2 && t2.splice.apply(t2, [o2, 1, t2[a2]].concat(t2.splice(o2, a2 - o2)));
      }
    }
  }
  function ey(e2, t2) {
    if (t2 >= e2.length)
      return t2;
    for (var r2 = e2[t2].shaperInfo.syllable; ++t2 < e2.length && e2[t2].shaperInfo.syllable === r2; )
      ;
    return t2;
  }
  function ty(e2) {
    return "H" === e2.shaperInfo.category && !e2.isLigated;
  }
  function ry(e2) {
    return "B" === e2.category || "GB" === e2.category;
  }
  function ny(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return iy(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return iy(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function iy(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var ay = { arab: Ed, mong: Ed, syrc: Ed, "nko ": Ed, phag: Ed, mand: Ed, mani: Ed, phlp: Ed, hang: Rd, bng2: Cp, beng: Cp, dev2: Cp, deva: Cp, gjr2: Cp, gujr: Cp, guru: Cp, gur2: Cp, knda: Cp, knd2: Cp, mlm2: Cp, mlym: Cp, ory2: Cp, orya: Cp, taml: Cp, tml2: Cp, telu: Cp, tel2: Cp, khmr: Cp, bali: Hp, batk: Hp, brah: Hp, bugi: Hp, buhd: Hp, cakm: Hp, cham: Hp, dupl: Hp, egyp: Hp, gran: Hp, hano: Hp, java: Hp, kthi: Hp, kali: Hp, khar: Hp, khoj: Hp, sind: Hp, lepc: Hp, limb: Hp, mahj: Hp, mtei: Hp, modi: Hp, hmng: Hp, rjng: Hp, saur: Hp, shrd: Hp, sidd: Hp, sinh: Hp, sund: Hp, sylo: Hp, tglg: Hp, tagb: Hp, tale: Hp, lana: Hp, tavt: Hp, takr: Hp, tibt: Hp, tfng: Hp, tirh: Hp, latn: Sd, DFLT: Sd };
  function oy(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return sy(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return sy(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function sy(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var uy = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    return r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.prototype.applyLookup = function(e3, t3) {
      var r3 = this;
      switch (e3) {
        case 1:
          var n3 = this.coverageIndex(t3.coverage);
          if (-1 === n3)
            return false;
          var i2 = this.glyphIterator.cur;
          switch (t3.version) {
            case 1:
              i2.id = i2.id + t3.deltaGlyphID & 65535;
              break;
            case 2:
              i2.id = t3.substitute.get(n3);
          }
          return true;
        case 2:
          var a2 = this.coverageIndex(t3.coverage);
          if (-1 !== a2) {
            var o2, s2 = t3.sequences.get(a2);
            this.glyphIterator.cur.id = s2[0], this.glyphIterator.cur.ligatureComponent = 0;
            var u2 = this.glyphIterator.cur.features, l2 = this.glyphIterator.cur, c2 = s2.slice(1).map(function(e4, t4) {
              var n4 = new Fd(r3.font, e4, void 0, u2);
              return n4.shaperInfo = l2.shaperInfo, n4.isLigated = l2.isLigated, n4.ligatureComponent = t4 + 1, n4.substituted = true, n4.isMultiplied = true, n4;
            });
            return (o2 = this.glyphs).splice.apply(o2, [this.glyphIterator.index + 1, 0].concat(c2)), true;
          }
          return false;
        case 3:
          var f2 = this.coverageIndex(t3.coverage);
          if (-1 !== f2) {
            return this.glyphIterator.cur.id = t3.alternateSet.get(f2)[0], true;
          }
          return false;
        case 4:
          var h2 = this.coverageIndex(t3.coverage);
          if (-1 === h2)
            return false;
          for (var d2, p2 = oy(t3.ligatureSets.get(h2)); !(d2 = p2()).done; ) {
            var y2 = d2.value, g2 = this.sequenceMatchIndices(1, y2.components);
            if (g2) {
              for (var v2, b2 = this.glyphIterator.cur, m2 = b2.codePoints.slice(), w2 = oy(g2); !(v2 = w2()).done; ) {
                var S2 = v2.value;
                m2.push.apply(m2, this.glyphs[S2].codePoints);
              }
              var x2 = new Fd(this.font, y2.glyph, m2, b2.features);
              x2.shaperInfo = b2.shaperInfo, x2.isLigated = true, x2.substituted = true;
              for (var A2 = b2.isMark, k2 = 0; k2 < g2.length && A2; k2++)
                A2 = this.glyphs[g2[k2]].isMark;
              x2.ligatureID = A2 ? null : this.ligatureID++;
              for (var C2, P2 = b2.ligatureID, I2 = b2.codePoints.length, O2 = I2, E2 = this.glyphIterator.index + 1, B2 = oy(g2); !(C2 = B2()).done; ) {
                var T2 = C2.value;
                if (A2)
                  E2 = T2;
                else
                  for (; E2 < T2; ) {
                    var L2 = O2 - I2 + Math.min(this.glyphs[E2].ligatureComponent || 1, I2);
                    this.glyphs[E2].ligatureID = x2.ligatureID, this.glyphs[E2].ligatureComponent = L2, E2++;
                  }
                P2 = this.glyphs[E2].ligatureID, O2 += I2 = this.glyphs[E2].codePoints.length, E2++;
              }
              if (P2 && !A2)
                for (var z2 = E2; z2 < this.glyphs.length && this.glyphs[z2].ligatureID === P2; z2++) {
                  L2 = O2 - I2 + Math.min(this.glyphs[z2].ligatureComponent || 1, I2);
                  this.glyphs[z2].ligatureComponent = L2;
                }
              for (var U2 = g2.length - 1; U2 >= 0; U2--)
                this.glyphs.splice(g2[U2], 1);
              return this.glyphs[this.glyphIterator.index] = x2, true;
            }
          }
          return false;
        case 5:
          return this.applyContext(t3);
        case 6:
          return this.applyChainingContext(t3);
        case 7:
          return this.applyLookup(t3.lookupType, t3.extension);
        default:
          throw new Error("GSUB lookupType " + e3 + " is not supported");
      }
    }, n2;
  }(jd);
  function ly(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return cy(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return cy(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function cy(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var fy = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2.applyPositionValue = function(e3, t3) {
      var r3 = this.positions[this.glyphIterator.peekIndex(e3)];
      null != t3.xAdvance && (r3.xAdvance += t3.xAdvance), null != t3.yAdvance && (r3.yAdvance += t3.yAdvance), null != t3.xPlacement && (r3.xOffset += t3.xPlacement), null != t3.yPlacement && (r3.yOffset += t3.yPlacement);
      var n3 = this.font._variationProcessor, i3 = this.font.GDEF && this.font.GDEF.itemVariationStore;
      n3 && i3 && (t3.xPlaDevice && (r3.xOffset += n3.getDelta(i3, t3.xPlaDevice.a, t3.xPlaDevice.b)), t3.yPlaDevice && (r3.yOffset += n3.getDelta(i3, t3.yPlaDevice.a, t3.yPlaDevice.b)), t3.xAdvDevice && (r3.xAdvance += n3.getDelta(i3, t3.xAdvDevice.a, t3.xAdvDevice.b)), t3.yAdvDevice && (r3.yAdvance += n3.getDelta(i3, t3.yAdvDevice.a, t3.yAdvDevice.b)));
    }, i2.applyLookup = function(e3, t3) {
      switch (e3) {
        case 1:
          var r3 = this.coverageIndex(t3.coverage);
          if (-1 === r3)
            return false;
          switch (t3.version) {
            case 1:
              this.applyPositionValue(0, t3.value);
              break;
            case 2:
              this.applyPositionValue(0, t3.values.get(r3));
          }
          return true;
        case 2:
          var n3 = this.glyphIterator.peek();
          if (!n3)
            return false;
          var i3 = this.coverageIndex(t3.coverage);
          if (-1 === i3)
            return false;
          switch (t3.version) {
            case 1:
              for (var a2, o2 = ly(t3.pairSets.get(i3)); !(a2 = o2()).done; ) {
                var s2 = a2.value;
                if (s2.secondGlyph === n3.id)
                  return this.applyPositionValue(0, s2.value1), this.applyPositionValue(1, s2.value2), true;
              }
              return false;
            case 2:
              var u2 = this.getClassID(this.glyphIterator.cur.id, t3.classDef1), l2 = this.getClassID(n3.id, t3.classDef2);
              if (-1 === u2 || -1 === l2)
                return false;
              var c2 = t3.classRecords.get(u2).get(l2);
              return this.applyPositionValue(0, c2.value1), this.applyPositionValue(1, c2.value2), true;
          }
        case 3:
          var f2 = this.glyphIterator.peekIndex(), h2 = this.glyphs[f2];
          if (!h2)
            return false;
          var d2 = t3.entryExitRecords[this.coverageIndex(t3.coverage)];
          if (!d2 || !d2.exitAnchor)
            return false;
          var p2 = t3.entryExitRecords[this.coverageIndex(t3.coverage, h2.id)];
          if (!p2 || !p2.entryAnchor)
            return false;
          var y2 = this.getAnchor(p2.entryAnchor), g2 = this.getAnchor(d2.exitAnchor), v2 = this.positions[this.glyphIterator.index], b2 = this.positions[f2];
          switch (this.direction) {
            case "ltr":
              v2.xAdvance = g2.x + v2.xOffset;
              var m2 = y2.x + b2.xOffset;
              b2.xAdvance -= m2, b2.xOffset -= m2;
              break;
            case "rtl":
              m2 = g2.x + v2.xOffset, v2.xAdvance -= m2, v2.xOffset -= m2, b2.xAdvance = y2.x + b2.xOffset;
          }
          return this.glyphIterator.flags.rightToLeft ? (this.glyphIterator.cur.cursiveAttachment = f2, v2.yOffset = y2.y - g2.y) : (h2.cursiveAttachment = this.glyphIterator.index, v2.yOffset = g2.y - y2.y), true;
        case 4:
          var w2 = this.coverageIndex(t3.markCoverage);
          if (-1 === w2)
            return false;
          for (var S2 = this.glyphIterator.index; --S2 >= 0 && (this.glyphs[S2].isMark || this.glyphs[S2].ligatureComponent > 0); )
            ;
          if (S2 < 0)
            return false;
          var x2 = this.coverageIndex(t3.baseCoverage, this.glyphs[S2].id);
          if (-1 === x2)
            return false;
          var A2 = t3.markArray[w2], k2 = t3.baseArray[x2][A2.class];
          return this.applyAnchor(A2, k2, S2), true;
        case 5:
          var C2 = this.coverageIndex(t3.markCoverage);
          if (-1 === C2)
            return false;
          for (var P2 = this.glyphIterator.index; --P2 >= 0 && this.glyphs[P2].isMark; )
            ;
          if (P2 < 0)
            return false;
          var I2 = this.coverageIndex(t3.ligatureCoverage, this.glyphs[P2].id);
          if (-1 === I2)
            return false;
          var O2 = t3.ligatureArray[I2], E2 = this.glyphIterator.cur, B2 = this.glyphs[P2], T2 = B2.ligatureID && B2.ligatureID === E2.ligatureID && E2.ligatureComponent > 0 ? Math.min(E2.ligatureComponent, B2.codePoints.length) - 1 : B2.codePoints.length - 1, L2 = t3.markArray[C2], z2 = O2[T2][L2.class];
          return this.applyAnchor(L2, z2, P2), true;
        case 6:
          var U2 = this.coverageIndex(t3.mark1Coverage);
          if (-1 === U2)
            return false;
          var D2 = this.glyphIterator.peekIndex(-1), j2 = this.glyphs[D2];
          if (!j2 || !j2.isMark)
            return false;
          var M2 = this.glyphIterator.cur, F2 = false;
          if (M2.ligatureID === j2.ligatureID ? M2.ligatureID ? M2.ligatureComponent === j2.ligatureComponent && (F2 = true) : F2 = true : (M2.ligatureID && !M2.ligatureComponent || j2.ligatureID && !j2.ligatureComponent) && (F2 = true), !F2)
            return false;
          var R2 = this.coverageIndex(t3.mark2Coverage, j2.id);
          if (-1 === R2)
            return false;
          var N2 = t3.mark1Array[U2], q2 = t3.mark2Array[R2][N2.class];
          return this.applyAnchor(N2, q2, D2), true;
        case 7:
          return this.applyContext(t3);
        case 8:
          return this.applyChainingContext(t3);
        case 9:
          return this.applyLookup(t3.lookupType, t3.extension);
        default:
          throw new Error("Unsupported GPOS table: " + e3);
      }
    }, i2.applyAnchor = function(e3, t3, r3) {
      var n3 = this.getAnchor(t3), i3 = this.getAnchor(e3.markAnchor), a2 = (this.positions[r3], this.positions[this.glyphIterator.index]);
      a2.xOffset = n3.x - i3.x, a2.yOffset = n3.y - i3.y, this.glyphIterator.cur.markAttachment = r3;
    }, i2.getAnchor = function(e3) {
      var t3 = e3.xCoordinate, r3 = e3.yCoordinate, n3 = this.font._variationProcessor, i3 = this.font.GDEF && this.font.GDEF.itemVariationStore;
      return n3 && i3 && (e3.xDeviceTable && (t3 += n3.getDelta(i3, e3.xDeviceTable.a, e3.xDeviceTable.b)), e3.yDeviceTable && (r3 += n3.getDelta(i3, e3.yDeviceTable.a, e3.yDeviceTable.b))), { x: t3, y: r3 };
    }, i2.applyFeatures = function(t3, r3, n3) {
      e2.prototype.applyFeatures.call(this, t3, r3, n3);
      for (var i3 = 0; i3 < this.glyphs.length; i3++)
        this.fixCursiveAttachment(i3);
      this.fixMarkAttachment();
    }, i2.fixCursiveAttachment = function(e3) {
      var t3 = this.glyphs[e3];
      if (null != t3.cursiveAttachment) {
        var r3 = t3.cursiveAttachment;
        t3.cursiveAttachment = null, this.fixCursiveAttachment(r3), this.positions[e3].yOffset += this.positions[r3].yOffset;
      }
    }, i2.fixMarkAttachment = function() {
      for (var e3 = 0; e3 < this.glyphs.length; e3++) {
        var t3 = this.glyphs[e3];
        if (null != t3.markAttachment) {
          var r3 = t3.markAttachment;
          if (this.positions[e3].xOffset += this.positions[r3].xOffset, this.positions[e3].yOffset += this.positions[r3].yOffset, "ltr" === this.direction)
            for (var n3 = r3; n3 < e3; n3++)
              this.positions[e3].xOffset -= this.positions[n3].xAdvance, this.positions[e3].yOffset -= this.positions[n3].yAdvance;
          else
            for (var i3 = r3 + 1; i3 < e3 + 1; i3++)
              this.positions[e3].xOffset += this.positions[i3].xAdvance, this.positions[e3].yOffset += this.positions[i3].yAdvance;
        }
      }
    }, n2;
  }(jd), hy = function() {
    function e2(e3) {
      this.font = e3, this.glyphInfos = null, this.plan = null, this.GSUBProcessor = null, this.GPOSProcessor = null, this.fallbackPosition = true, e3.GSUB && (this.GSUBProcessor = new uy(e3, e3.GSUB)), e3.GPOS && (this.GPOSProcessor = new fy(e3, e3.GPOS));
    }
    var t2 = e2.prototype;
    return t2.setup = function(e3) {
      var t3 = this;
      this.glyphInfos = e3.glyphs.map(function(e4) {
        return new Fd(t3.font, e4.id, [].concat(e4.codePoints));
      });
      var r2 = null;
      for (var n2 in this.GPOSProcessor && (r2 = this.GPOSProcessor.selectScript(e3.script, e3.language, e3.direction)), this.GSUBProcessor && (r2 = this.GSUBProcessor.selectScript(e3.script, e3.language, e3.direction)), this.shaper = function(e4) {
        Array.isArray(e4) || (e4 = [e4]);
        for (var t4, r3 = ny(e4); !(t4 = r3()).done; ) {
          var n3 = t4.value, i2 = ay[n3];
          if (i2)
            return i2;
        }
        return Sd;
      }(r2), this.plan = new yd(this.font, r2, e3.direction), this.shaper.plan(this.plan, this.glyphInfos, e3.features), this.plan.allFeatures)
        e3.features[n2] = true;
    }, t2.substitute = function(e3) {
      var t3 = this;
      this.GSUBProcessor && (this.plan.process(this.GSUBProcessor, this.glyphInfos), e3.glyphs = this.glyphInfos.map(function(e4) {
        return t3.font.getGlyph(e4.id, e4.codePoints);
      }));
    }, t2.position = function(e3) {
      return "BEFORE_GPOS" === this.shaper.zeroMarkWidths && this.zeroMarkAdvances(e3.positions), this.GPOSProcessor && this.plan.process(this.GPOSProcessor, this.glyphInfos, e3.positions), "AFTER_GPOS" === this.shaper.zeroMarkWidths && this.zeroMarkAdvances(e3.positions), "rtl" === e3.direction && (e3.glyphs.reverse(), e3.positions.reverse()), this.GPOSProcessor && this.GPOSProcessor.features;
    }, t2.zeroMarkAdvances = function(e3) {
      for (var t3 = 0; t3 < this.glyphInfos.length; t3++)
        this.glyphInfos[t3].isMark && (e3[t3].xAdvance = 0, e3[t3].yAdvance = 0);
    }, t2.cleanup = function() {
      this.glyphInfos = null, this.plan = null, this.shaper = null;
    }, t2.getAvailableFeatures = function(e3, t3) {
      var r2 = [];
      return this.GSUBProcessor && (this.GSUBProcessor.selectScript(e3, t3), r2.push.apply(r2, Object.keys(this.GSUBProcessor.features))), this.GPOSProcessor && (this.GPOSProcessor.selectScript(e3, t3), r2.push.apply(r2, Object.keys(this.GPOSProcessor.features))), r2;
    }, e2;
  }();
  function dy(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return py(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return py(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function py(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var yy = function() {
    function e2(e3) {
      this.font = e3, this.unicodeLayoutEngine = null, this.kernProcessor = null, this.font.morx ? this.engine = new hd(this.font) : (this.font.GSUB || this.font.GPOS) && (this.engine = new hy(this.font));
    }
    var t2 = e2.prototype;
    return t2.layout = function(e3, t3, r2, n2, i2) {
      if ("string" == typeof t3 && (i2 = n2, n2 = r2, r2 = t3, t3 = []), "string" == typeof e3) {
        null == r2 && (r2 = function(e4) {
          for (var t4 = e4.length, r3 = 0; r3 < t4; ) {
            var n3 = e4.charCodeAt(r3++);
            if (55296 <= n3 && n3 <= 56319 && r3 < t4) {
              var i3 = e4.charCodeAt(r3);
              56320 <= i3 && i3 <= 57343 && (r3++, n3 = ((1023 & n3) << 10) + (1023 & i3) + 65536);
            }
            var a3 = xh(n3);
            if ("Common" !== a3 && "Inherited" !== a3 && "Unknown" !== a3)
              return Bh[a3];
          }
          return Bh.Unknown;
        }(e3));
        var a2 = this.font.glyphsForString(e3);
      } else {
        if (null == r2) {
          for (var o2, s2 = [], u2 = dy(e3); !(o2 = u2()).done; ) {
            var l2 = o2.value;
            s2.push.apply(s2, l2.codePoints);
          }
          r2 = function(e4) {
            for (var t4 = 0; t4 < e4.length; t4++) {
              var r3 = e4[t4], n3 = xh(r3);
              if ("Common" !== n3 && "Inherited" !== n3 && "Unknown" !== n3)
                return Bh[n3];
            }
            return Bh.Unknown;
          }(s2);
        }
        a2 = e3;
      }
      var c2 = new Gh(a2, t3, r2, n2, i2);
      return 0 === a2.length ? (c2.positions = [], c2) : (this.engine && this.engine.setup && this.engine.setup(c2), this.substitute(c2), this.position(c2), this.hideDefaultIgnorables(c2.glyphs, c2.positions), this.engine && this.engine.cleanup && this.engine.cleanup(), c2);
    }, t2.substitute = function(e3) {
      this.engine && this.engine.substitute && this.engine.substitute(e3);
    }, t2.position = function(e3) {
      e3.positions = e3.glyphs.map(function(e4) {
        return new Vh(e4.advanceWidth);
      });
      var t3 = null;
      this.engine && this.engine.position && (t3 = this.engine.position(e3)), t3 || this.engine && !this.engine.fallbackPosition || (this.unicodeLayoutEngine || (this.unicodeLayoutEngine = new Ch(this.font)), this.unicodeLayoutEngine.positionGlyphs(e3.glyphs, e3.positions)), t3 && t3.kern || false === e3.features.kern || !this.font.kern || (this.kernProcessor || (this.kernProcessor = new Vl(this.font)), this.kernProcessor.process(e3.glyphs, e3.positions), e3.features.kern = true);
    }, t2.hideDefaultIgnorables = function(e3, t3) {
      for (var r2 = this.font.glyphForCodePoint(32), n2 = 0; n2 < e3.length; n2++)
        this.isDefaultIgnorable(e3[n2].codePoints[0]) && (e3[n2] = r2, t3[n2].xAdvance = 0, t3[n2].yAdvance = 0);
    }, t2.isDefaultIgnorable = function(e3) {
      var t3 = e3 >> 16;
      if (0 === t3)
        switch (e3 >> 8) {
          case 0:
            return 173 === e3;
          case 3:
            return 847 === e3;
          case 6:
            return 1564 === e3;
          case 23:
            return 6068 <= e3 && e3 <= 6069;
          case 24:
            return 6155 <= e3 && e3 <= 6158;
          case 32:
            return 8203 <= e3 && e3 <= 8207 || 8234 <= e3 && e3 <= 8238 || 8288 <= e3 && e3 <= 8303;
          case 254:
            return 65024 <= e3 && e3 <= 65039 || 65279 === e3;
          case 255:
            return 65520 <= e3 && e3 <= 65528;
          default:
            return false;
        }
      else
        switch (t3) {
          case 1:
            return 113824 <= e3 && e3 <= 113827 || 119155 <= e3 && e3 <= 119162;
          case 14:
            return 917504 <= e3 && e3 <= 921599;
          default:
            return false;
        }
    }, t2.getAvailableFeatures = function(e3, t3) {
      var r2 = [];
      return this.engine && r2.push.apply(r2, this.engine.getAvailableFeatures(e3, t3)), this.font.kern && -1 === r2.indexOf("kern") && r2.push("kern"), r2;
    }, t2.stringsForGlyph = function(e3) {
      for (var t3, r2 = /* @__PURE__ */ new Set(), n2 = dy(this.font._cmapProcessor.codePointsForGlyph(e3)); !(t3 = n2()).done; ) {
        var i2 = t3.value;
        r2.add(String.fromCodePoint(i2));
      }
      if (this.engine && this.engine.stringsForGlyph)
        for (var a2, o2 = dy(this.engine.stringsForGlyph(e3)); !(a2 = o2()).done; ) {
          var s2 = a2.value;
          r2.add(s2);
        }
      return Array.from(r2);
    }, e2;
  }();
  function gy(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return vy(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return vy(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function vy(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  function by(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  for (var my = { moveTo: "M", lineTo: "L", quadraticCurveTo: "Q", bezierCurveTo: "C", closePath: "Z" }, wy = function() {
    function e2() {
      this.commands = [], this._bbox = null, this._cbox = null;
    }
    var t2, r2, i2 = e2.prototype;
    return i2.toFunction = function() {
      var e3 = this;
      return function(t3) {
        return e3.commands.forEach(function(e4) {
          return t3[e4.command].apply(t3, e4.args);
        });
      };
    }, i2.toSVG = function() {
      return this.commands.map(function(e3) {
        var t3 = e3.args.map(function(e4) {
          return Math.round(100 * e4) / 100;
        });
        return "" + my[e3.command] + t3.join(" ");
      }).join("");
    }, i2.mapPoints = function(t3) {
      for (var r3, n2 = new e2(), i3 = gy(this.commands); !(r3 = i3()).done; ) {
        for (var a2 = r3.value, o2 = [], s2 = 0; s2 < a2.args.length; s2 += 2) {
          var u2 = t3(a2.args[s2], a2.args[s2 + 1]), l2 = u2[0], c2 = u2[1];
          o2.push(l2, c2);
        }
        n2[a2.command].apply(n2, o2);
      }
      return n2;
    }, i2.transform = function(e3, t3, r3, n2, i3, a2) {
      return this.mapPoints(function(o2, s2) {
        return [o2 = e3 * o2 + r3 * s2 + i3, s2 = t3 * o2 + n2 * s2 + a2];
      });
    }, i2.translate = function(e3, t3) {
      return this.transform(1, 0, 0, 1, e3, t3);
    }, i2.rotate = function(e3) {
      var t3 = Math.cos(e3), r3 = Math.sin(e3);
      return this.transform(t3, r3, -r3, t3, 0, 0);
    }, i2.scale = function(e3, t3) {
      return void 0 === t3 && (t3 = e3), this.transform(e3, 0, 0, t3, 0, 0);
    }, t2 = e2, (r2 = [{ key: "cbox", get: function() {
      if (!this._cbox) {
        for (var e3, t3 = new Ih(), r3 = gy(this.commands); !(e3 = r3()).done; )
          for (var n2 = e3.value, i3 = 0; i3 < n2.args.length; i3 += 2)
            t3.addPoint(n2.args[i3], n2.args[i3 + 1]);
        this._cbox = Object.freeze(t3);
      }
      return this._cbox;
    } }, { key: "bbox", get: function() {
      if (this._bbox)
        return this._bbox;
      for (var e3, t3 = new Ih(), r3 = 0, n2 = 0, i3 = function(e4) {
        return Math.pow(1 - e4, 3) * w2[k2] + 3 * Math.pow(1 - e4, 2) * e4 * S2[k2] + 3 * (1 - e4) * Math.pow(e4, 2) * x2[k2] + Math.pow(e4, 3) * A2[k2];
      }, a2 = gy(this.commands); !(e3 = a2()).done; ) {
        var o2 = e3.value;
        switch (o2.command) {
          case "moveTo":
          case "lineTo":
            var s2 = o2.args, u2 = s2[0], l2 = s2[1];
            t3.addPoint(u2, l2), r3 = u2, n2 = l2;
            break;
          case "quadraticCurveTo":
          case "bezierCurveTo":
            if ("quadraticCurveTo" === o2.command)
              var c2 = o2.args, f2 = c2[0], h2 = c2[1], d2 = r3 + 2 / 3 * (f2 - r3), p2 = n2 + 2 / 3 * (h2 - n2), y2 = (b2 = c2[2]) + 2 / 3 * (f2 - b2), g2 = (m2 = c2[3]) + 2 / 3 * (h2 - m2);
            else
              var v2 = o2.args, b2 = (d2 = v2[0], p2 = v2[1], y2 = v2[2], g2 = v2[3], v2[4]), m2 = v2[5];
            t3.addPoint(b2, m2);
            for (var w2 = [r3, n2], S2 = [d2, p2], x2 = [y2, g2], A2 = [b2, m2], k2 = 0; k2 <= 1; k2++) {
              var C2 = 6 * w2[k2] - 12 * S2[k2] + 6 * x2[k2], P2 = -3 * w2[k2] + 9 * S2[k2] - 9 * x2[k2] + 3 * A2[k2];
              if (o2 = 3 * S2[k2] - 3 * w2[k2], 0 !== P2) {
                var I2 = Math.pow(C2, 2) - 4 * o2 * P2;
                if (!(I2 < 0)) {
                  var O2 = (-C2 + Math.sqrt(I2)) / (2 * P2);
                  0 < O2 && O2 < 1 && (0 === k2 ? t3.addPoint(i3(O2), t3.maxY) : 1 === k2 && t3.addPoint(t3.maxX, i3(O2)));
                  var E2 = (-C2 - Math.sqrt(I2)) / (2 * P2);
                  0 < E2 && E2 < 1 && (0 === k2 ? t3.addPoint(i3(E2), t3.maxY) : 1 === k2 && t3.addPoint(t3.maxX, i3(E2)));
                }
              } else {
                if (0 === C2)
                  continue;
                var B2 = -o2 / C2;
                0 < B2 && B2 < 1 && (0 === k2 ? t3.addPoint(i3(B2), t3.maxY) : 1 === k2 && t3.addPoint(t3.maxX, i3(B2)));
              }
            }
            r3 = b2, n2 = m2;
        }
      }
      return this._bbox = Object.freeze(t3);
    } }]) && by(t2.prototype, r2), e2;
  }(), Sy = function() {
    var e2 = Ay[xy];
    wy.prototype[e2] = function() {
      this._bbox = this._cbox = null;
      for (var t2 = arguments.length, r2 = new Array(t2), n2 = 0; n2 < t2; n2++)
        r2[n2] = arguments[n2];
      return this.commands.push({ command: e2, args: r2 }), this;
    };
  }, xy = 0, Ay = ["moveTo", "lineTo", "quadraticCurveTo", "bezierCurveTo", "closePath"]; xy < Ay.length; xy++)
    Sy();
  var ky, Cy = [".notdef", ".null", "nonmarkingreturn", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quotesingle", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "grave", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "Adieresis", "Aring", "Ccedilla", "Eacute", "Ntilde", "Odieresis", "Udieresis", "aacute", "agrave", "acircumflex", "adieresis", "atilde", "aring", "ccedilla", "eacute", "egrave", "ecircumflex", "edieresis", "iacute", "igrave", "icircumflex", "idieresis", "ntilde", "oacute", "ograve", "ocircumflex", "odieresis", "otilde", "uacute", "ugrave", "ucircumflex", "udieresis", "dagger", "degree", "cent", "sterling", "section", "bullet", "paragraph", "germandbls", "registered", "copyright", "trademark", "acute", "dieresis", "notequal", "AE", "Oslash", "infinity", "plusminus", "lessequal", "greaterequal", "yen", "mu", "partialdiff", "summation", "product", "pi", "integral", "ordfeminine", "ordmasculine", "Omega", "ae", "oslash", "questiondown", "exclamdown", "logicalnot", "radical", "florin", "approxequal", "Delta", "guillemotleft", "guillemotright", "ellipsis", "nonbreakingspace", "Agrave", "Atilde", "Otilde", "OE", "oe", "endash", "emdash", "quotedblleft", "quotedblright", "quoteleft", "quoteright", "divide", "lozenge", "ydieresis", "Ydieresis", "fraction", "currency", "guilsinglleft", "guilsinglright", "fi", "fl", "daggerdbl", "periodcentered", "quotesinglbase", "quotedblbase", "perthousand", "Acircumflex", "Ecircumflex", "Aacute", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Oacute", "Ocircumflex", "apple", "Ograve", "Uacute", "Ucircumflex", "Ugrave", "dotlessi", "circumflex", "tilde", "macron", "breve", "dotaccent", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "Lslash", "lslash", "Scaron", "scaron", "Zcaron", "zcaron", "brokenbar", "Eth", "eth", "Yacute", "yacute", "Thorn", "thorn", "minus", "multiply", "onesuperior", "twosuperior", "threesuperior", "onehalf", "onequarter", "threequarters", "franc", "Gbreve", "gbreve", "Idotaccent", "Scedilla", "scedilla", "Cacute", "cacute", "Ccaron", "ccaron", "dcroat"];
  function Py(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  function Iy(e2, t2, r2, n2, i2) {
    var a2 = {};
    return Object.keys(n2).forEach(function(e3) {
      a2[e3] = n2[e3];
    }), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = r2.slice().reverse().reduce(function(r3, n3) {
      return n3(e2, t2, r3) || r3;
    }, a2), i2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(i2) : void 0, a2.initializer = void 0), void 0 === a2.initializer && (Object.defineProperty(e2, t2, a2), a2 = null), a2;
  }
  var Oy = (Iy((ky = function() {
    function e2(e3, t3, r3) {
      this.id = e3, this.codePoints = t3, this._font = r3, this.isMark = this.codePoints.length > 0 && this.codePoints.every(kh), this.isLigature = this.codePoints.length > 1;
    }
    var t2, r2, i2 = e2.prototype;
    return i2._getPath = function() {
      return new wy();
    }, i2._getCBox = function() {
      return this.path.cbox;
    }, i2._getBBox = function() {
      return this.path.bbox;
    }, i2._getTableMetrics = function(e3) {
      if (this.id < e3.metrics.length)
        return e3.metrics.get(this.id);
      var t3 = e3.metrics.get(e3.metrics.length - 1);
      return { advance: t3 ? t3.advance : 0, bearing: e3.bearings.get(this.id - e3.metrics.length) || 0 };
    }, i2._getMetrics = function(e3) {
      if (this._metrics)
        return this._metrics;
      var t3, r3 = this._getTableMetrics(this._font.hmtx), n2 = r3.advance, i3 = r3.bearing;
      if (this._font.vmtx)
        var a2 = this._getTableMetrics(this._font.vmtx), o2 = a2.advance, s2 = a2.bearing;
      else if (null == e3 && (e3 = this.cbox), (t3 = this._font["OS/2"]) && t3.version > 0)
        o2 = Math.abs(t3.typoAscender - t3.typoDescender), s2 = t3.typoAscender - e3.maxY;
      else {
        var u2 = this._font.hhea;
        o2 = Math.abs(u2.ascent - u2.descent), s2 = u2.ascent - e3.maxY;
      }
      return this._font._variationProcessor && this._font.HVAR && (n2 += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR)), this._metrics = { advanceWidth: n2, advanceHeight: o2, leftBearing: i3, topBearing: s2 };
    }, i2.getScaledPath = function(e3) {
      var t3 = 1 / this._font.unitsPerEm * e3;
      return this.path.scale(t3);
    }, i2._getName = function() {
      var e3 = this._font.post;
      if (!e3)
        return null;
      switch (e3.version) {
        case 1:
          return Cy[this.id];
        case 2:
          var t3 = e3.glyphNameIndex[this.id];
          return t3 < Cy.length ? Cy[t3] : e3.names[t3 - Cy.length];
        case 2.5:
          return Cy[this.id + e3.offsets[this.id]];
        case 4:
          return String.fromCharCode(e3.map[this.id]);
      }
    }, i2.render = function(e3, t3) {
      e3.save();
      var r3 = 1 / this._font.head.unitsPerEm * t3;
      e3.scale(r3, r3), this.path.toFunction()(e3), e3.fill(), e3.restore();
    }, t2 = e2, (r2 = [{ key: "cbox", get: function() {
      return this._getCBox();
    } }, { key: "bbox", get: function() {
      return this._getBBox();
    } }, { key: "path", get: function() {
      return this._getPath();
    } }, { key: "advanceWidth", get: function() {
      return this._getMetrics().advanceWidth;
    } }, { key: "advanceHeight", get: function() {
      return this._getMetrics().advanceHeight;
    } }, { key: "ligatureCaretPositions", get: function() {
    } }, { key: "name", get: function() {
      return this._getName();
    } }]) && Py(t2.prototype, r2), e2;
  }()).prototype, "cbox", [An], Object.getOwnPropertyDescriptor(ky.prototype, "cbox"), ky.prototype), Iy(ky.prototype, "bbox", [An], Object.getOwnPropertyDescriptor(ky.prototype, "bbox"), ky.prototype), Iy(ky.prototype, "path", [An], Object.getOwnPropertyDescriptor(ky.prototype, "path"), ky.prototype), Iy(ky.prototype, "advanceWidth", [An], Object.getOwnPropertyDescriptor(ky.prototype, "advanceWidth"), ky.prototype), Iy(ky.prototype, "advanceHeight", [An], Object.getOwnPropertyDescriptor(ky.prototype, "advanceHeight"), ky.prototype), Iy(ky.prototype, "name", [An], Object.getOwnPropertyDescriptor(ky.prototype, "name"), ky.prototype), ky);
  function Ey(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return By(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return By(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function By(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Ty = new wn.Struct({ numberOfContours: wn.int16, xMin: wn.int16, yMin: wn.int16, xMax: wn.int16, yMax: wn.int16 }), Ly = function() {
    function e2(e3, t2, r2, n2) {
      void 0 === r2 && (r2 = 0), void 0 === n2 && (n2 = 0), this.onCurve = e3, this.endContour = t2, this.x = r2, this.y = n2;
    }
    return e2.prototype.copy = function() {
      return new e2(this.onCurve, this.endContour, this.x, this.y);
    }, e2;
  }(), zy = function(e2, t2, r2) {
    this.glyphID = e2, this.dx = t2, this.dy = r2, this.pos = 0, this.scaleX = this.scaleY = 1, this.scale01 = this.scale10 = 0;
  }, Uy = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2._getCBox = function(e3) {
      if (this._font._variationProcessor && !e3)
        return this.path.cbox;
      var t3 = this._font._getTableStream("glyf");
      t3.pos += this._font.loca.offsets[this.id];
      var r3 = Ty.decode(t3), n3 = new Ih(r3.xMin, r3.yMin, r3.xMax, r3.yMax);
      return Object.freeze(n3);
    }, i2._parseGlyphCoord = function(e3, t3, r3, n3) {
      if (r3) {
        var i3 = e3.readUInt8();
        n3 || (i3 = -i3), i3 += t3;
      } else if (n3)
        i3 = t3;
      else
        i3 = t3 + e3.readInt16BE();
      return i3;
    }, i2._decode = function() {
      var e3 = this._font.loca.offsets[this.id];
      if (e3 === this._font.loca.offsets[this.id + 1])
        return null;
      var t3 = this._font._getTableStream("glyf");
      t3.pos += e3;
      var r3 = t3.pos, n3 = Ty.decode(t3);
      return n3.numberOfContours > 0 ? this._decodeSimple(n3, t3) : n3.numberOfContours < 0 && this._decodeComposite(n3, t3, r3), n3;
    }, i2._decodeSimple = function(e3, t3) {
      e3.points = [];
      var r3 = new wn.Array(wn.uint16, e3.numberOfContours).decode(t3);
      e3.instructions = new wn.Array(wn.uint8, wn.uint16).decode(t3);
      for (var n3 = [], i3 = r3[r3.length - 1] + 1; n3.length < i3; ) {
        var a2 = t3.readUInt8();
        if (n3.push(a2), 8 & a2)
          for (var o2 = t3.readUInt8(), s2 = 0; s2 < o2; s2++)
            n3.push(a2);
      }
      for (var u2 = 0; u2 < n3.length; u2++) {
        a2 = n3[u2];
        var l2 = new Ly(!!(1 & a2), r3.indexOf(u2) >= 0, 0, 0);
        e3.points.push(l2);
      }
      var c2 = 0;
      for (u2 = 0; u2 < n3.length; u2++) {
        a2 = n3[u2];
        e3.points[u2].x = c2 = this._parseGlyphCoord(t3, c2, 2 & a2, 16 & a2);
      }
      var f2 = 0;
      for (u2 = 0; u2 < n3.length; u2++) {
        a2 = n3[u2];
        e3.points[u2].y = f2 = this._parseGlyphCoord(t3, f2, 4 & a2, 32 & a2);
      }
      if (this._font._variationProcessor) {
        var h2 = e3.points.slice();
        h2.push.apply(h2, this._getPhantomPoints(e3)), this._font._variationProcessor.transformPoints(this.id, h2), e3.phantomPoints = h2.slice(-4);
      }
    }, i2._decodeComposite = function(e3, t3, r3) {
      void 0 === r3 && (r3 = 0), e3.components = [];
      for (var n3 = false, i3 = 32; 32 & i3; ) {
        i3 = t3.readUInt16BE();
        var a2 = t3.pos - r3, o2 = t3.readUInt16BE();
        if (n3 || (n3 = 0 != (256 & i3)), 1 & i3)
          var s2 = t3.readInt16BE(), u2 = t3.readInt16BE();
        else
          s2 = t3.readInt8(), u2 = t3.readInt8();
        (f2 = new zy(o2, s2, u2)).pos = a2, 8 & i3 ? f2.scaleX = f2.scaleY = (t3.readUInt8() << 24 | t3.readUInt8() << 16) / 1073741824 : 64 & i3 ? (f2.scaleX = (t3.readUInt8() << 24 | t3.readUInt8() << 16) / 1073741824, f2.scaleY = (t3.readUInt8() << 24 | t3.readUInt8() << 16) / 1073741824) : 128 & i3 && (f2.scaleX = (t3.readUInt8() << 24 | t3.readUInt8() << 16) / 1073741824, f2.scale01 = (t3.readUInt8() << 24 | t3.readUInt8() << 16) / 1073741824, f2.scale10 = (t3.readUInt8() << 24 | t3.readUInt8() << 16) / 1073741824, f2.scaleY = (t3.readUInt8() << 24 | t3.readUInt8() << 16) / 1073741824), e3.components.push(f2);
      }
      if (this._font._variationProcessor) {
        for (var l2 = [], c2 = 0; c2 < e3.components.length; c2++) {
          var f2 = e3.components[c2];
          l2.push(new Ly(true, true, f2.dx, f2.dy));
        }
        l2.push.apply(l2, this._getPhantomPoints(e3)), this._font._variationProcessor.transformPoints(this.id, l2), e3.phantomPoints = l2.splice(-4, 4);
        for (var h2 = 0; h2 < l2.length; h2++) {
          var d2 = l2[h2];
          e3.components[h2].dx = d2.x, e3.components[h2].dy = d2.y;
        }
      }
      return n3;
    }, i2._getPhantomPoints = function(e3) {
      var t3 = this._getCBox(true);
      null == this._metrics && (this._metrics = Oy.prototype._getMetrics.call(this, t3));
      var r3 = this._metrics, n3 = r3.advanceWidth, i3 = r3.advanceHeight, a2 = r3.leftBearing, o2 = r3.topBearing;
      return [new Ly(false, true, e3.xMin - a2, 0), new Ly(false, true, e3.xMin - a2 + n3, 0), new Ly(false, true, 0, e3.yMax + o2), new Ly(false, true, 0, e3.yMax + o2 + i3)];
    }, i2._getContours = function() {
      var e3 = this._decode();
      if (!e3)
        return [];
      var t3 = [];
      if (e3.numberOfContours < 0)
        for (var r3, n3 = Ey(e3.components); !(r3 = n3()).done; )
          for (var i3 = r3.value, a2 = this._font.getGlyph(i3.glyphID)._getContours(), o2 = 0; o2 < a2.length; o2++)
            for (var s2 = a2[o2], u2 = 0; u2 < s2.length; u2++) {
              var l2 = s2[u2], c2 = l2.x * i3.scaleX + l2.y * i3.scale01 + i3.dx, f2 = l2.y * i3.scaleY + l2.x * i3.scale10 + i3.dy;
              t3.push(new Ly(l2.onCurve, l2.endContour, c2, f2));
            }
      else
        t3 = e3.points || [];
      e3.phantomPoints && !this._font.directory.tables.HVAR && (this._metrics.advanceWidth = e3.phantomPoints[1].x - e3.phantomPoints[0].x, this._metrics.advanceHeight = e3.phantomPoints[3].y - e3.phantomPoints[2].y, this._metrics.leftBearing = e3.xMin - e3.phantomPoints[0].x, this._metrics.topBearing = e3.phantomPoints[2].y - e3.yMax);
      for (var h2 = [], d2 = [], p2 = 0; p2 < t3.length; p2++) {
        var y2 = t3[p2];
        d2.push(y2), y2.endContour && (h2.push(d2), d2 = []);
      }
      return h2;
    }, i2._getMetrics = function() {
      if (this._metrics)
        return this._metrics;
      var t3 = this._getCBox(true);
      return e2.prototype._getMetrics.call(this, t3), this._font._variationProcessor && !this._font.HVAR && this.path, this._metrics;
    }, i2._getPath = function() {
      for (var e3 = this._getContours(), t3 = new wy(), r3 = 0; r3 < e3.length; r3++) {
        var n3 = e3[r3], i3 = n3[0], a2 = n3[n3.length - 1], o2 = 0;
        if (i3.onCurve) {
          var s2 = null;
          o2 = 1;
        } else
          s2 = i3 = a2.onCurve ? a2 : new Ly(false, false, (i3.x + a2.x) / 2, (i3.y + a2.y) / 2);
        t3.moveTo(i3.x, i3.y);
        for (var u2 = o2; u2 < n3.length; u2++) {
          var l2 = n3[u2], c2 = 0 === u2 ? i3 : n3[u2 - 1];
          if (c2.onCurve && l2.onCurve)
            t3.lineTo(l2.x, l2.y);
          else if (c2.onCurve && !l2.onCurve)
            s2 = l2;
          else if (c2.onCurve || l2.onCurve) {
            if (c2.onCurve || !l2.onCurve)
              throw new Error("Unknown TTF path state");
            t3.quadraticCurveTo(s2.x, s2.y, l2.x, l2.y);
            s2 = null;
          } else {
            var f2 = (c2.x + l2.x) / 2, h2 = (c2.y + l2.y) / 2;
            t3.quadraticCurveTo(c2.x, c2.y, f2, h2);
            var s2 = l2;
          }
        }
        s2 && t3.quadraticCurveTo(s2.x, s2.y, i3.x, i3.y), t3.closePath();
      }
      return t3;
    }, n2;
  }(Oy);
  var Dy = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2._getName = function() {
      return this._font.CFF2 ? e2.prototype._getName.call(this) : this._font["CFF "].getGlyphName(this.id);
    }, i2.bias = function(e3) {
      return e3.length < 1240 ? 107 : e3.length < 33900 ? 1131 : 32768;
    }, i2._getPath = function() {
      var e3 = this._font.stream, t3 = (e3.pos, this._font.CFF2 || this._font["CFF "]), r3 = t3.topDict.CharStrings[this.id], n3 = r3.offset + r3.length;
      e3.pos = r3.offset;
      var i3, a2, o2 = new wy(), s2 = [], u2 = [], l2 = null, c2 = 0, f2 = 0, h2 = 0, d2 = false;
      this._usedGsubrs = i3 = {}, this._usedSubrs = a2 = {};
      var p2 = t3.globalSubrIndex || [], y2 = this.bias(p2), g2 = t3.privateDictForGlyph(this.id), v2 = g2.Subrs || [], b2 = this.bias(v2), m2 = t3.topDict.vstore && t3.topDict.vstore.itemVariationStore, w2 = g2.vsindex, S2 = this._font._variationProcessor;
      function x2() {
        null == l2 && (l2 = s2.shift() + g2.nominalWidthX);
      }
      function A2() {
        return s2.length % 2 != 0 && x2(), c2 += s2.length >> 1, s2.length = 0;
      }
      function k2(e4, t4) {
        d2 && o2.closePath(), o2.moveTo(e4, t4), d2 = true;
      }
      return function r4() {
        for (; e3.pos < n3; ) {
          var l3 = e3.readUInt8();
          if (l3 < 32)
            switch (l3) {
              case 1:
              case 3:
              case 18:
              case 23:
                A2();
                break;
              case 4:
                s2.length > 1 && x2(), h2 += s2.shift(), k2(f2, h2);
                break;
              case 5:
                for (; s2.length >= 2; )
                  f2 += s2.shift(), h2 += s2.shift(), o2.lineTo(f2, h2);
                break;
              case 6:
              case 7:
                for (var g3 = 6 === l3; s2.length >= 1; )
                  g3 ? f2 += s2.shift() : h2 += s2.shift(), o2.lineTo(f2, h2), g3 = !g3;
                break;
              case 8:
                for (; s2.length > 0; ) {
                  var C2 = f2 + s2.shift(), P2 = h2 + s2.shift(), I2 = C2 + s2.shift(), O2 = P2 + s2.shift();
                  f2 = I2 + s2.shift(), h2 = O2 + s2.shift(), o2.bezierCurveTo(C2, P2, I2, O2, f2, h2);
                }
                break;
              case 10:
                var E2 = s2.pop() + b2, B2 = v2[E2];
                if (B2) {
                  a2[E2] = true;
                  var T2 = e3.pos, L2 = n3;
                  e3.pos = B2.offset, n3 = B2.offset + B2.length, r4(), e3.pos = T2, n3 = L2;
                }
                break;
              case 11:
                if (t3.version >= 2)
                  break;
                return;
              case 14:
                if (t3.version >= 2)
                  break;
                s2.length > 0 && x2(), d2 && (o2.closePath(), d2 = false);
                break;
              case 15:
                if (t3.version < 2)
                  throw new Error("vsindex operator not supported in CFF v1");
                w2 = s2.pop();
                break;
              case 16:
                if (t3.version < 2)
                  throw new Error("blend operator not supported in CFF v1");
                if (!S2)
                  throw new Error("blend operator in non-variation font");
                for (var z2 = S2.getBlendVector(m2, w2), U2 = s2.pop(), D2 = U2 * z2.length, j2 = s2.length - D2, M2 = j2 - U2, F2 = 0; F2 < U2; F2++) {
                  for (var R2 = s2[M2 + F2], N2 = 0; N2 < z2.length; N2++)
                    R2 += z2[N2] * s2[j2++];
                  s2[M2 + F2] = R2;
                }
                for (; D2--; )
                  s2.pop();
                break;
              case 19:
              case 20:
                A2(), e3.pos += c2 + 7 >> 3;
                break;
              case 21:
                s2.length > 2 && x2(), f2 += s2.shift(), h2 += s2.shift(), k2(f2, h2);
                break;
              case 22:
                s2.length > 1 && x2(), k2(f2 += s2.shift(), h2);
                break;
              case 24:
                for (; s2.length >= 8; ) {
                  C2 = f2 + s2.shift(), P2 = h2 + s2.shift(), I2 = C2 + s2.shift(), O2 = P2 + s2.shift();
                  f2 = I2 + s2.shift(), h2 = O2 + s2.shift(), o2.bezierCurveTo(C2, P2, I2, O2, f2, h2);
                }
                f2 += s2.shift(), h2 += s2.shift(), o2.lineTo(f2, h2);
                break;
              case 25:
                for (; s2.length >= 8; )
                  f2 += s2.shift(), h2 += s2.shift(), o2.lineTo(f2, h2);
                C2 = f2 + s2.shift(), P2 = h2 + s2.shift(), I2 = C2 + s2.shift(), O2 = P2 + s2.shift();
                f2 = I2 + s2.shift(), h2 = O2 + s2.shift(), o2.bezierCurveTo(C2, P2, I2, O2, f2, h2);
                break;
              case 26:
                for (s2.length % 2 && (f2 += s2.shift()); s2.length >= 4; )
                  C2 = f2, P2 = h2 + s2.shift(), I2 = C2 + s2.shift(), O2 = P2 + s2.shift(), f2 = I2, h2 = O2 + s2.shift(), o2.bezierCurveTo(C2, P2, I2, O2, f2, h2);
                break;
              case 27:
                for (s2.length % 2 && (h2 += s2.shift()); s2.length >= 4; )
                  C2 = f2 + s2.shift(), P2 = h2, I2 = C2 + s2.shift(), O2 = P2 + s2.shift(), f2 = I2 + s2.shift(), h2 = O2, o2.bezierCurveTo(C2, P2, I2, O2, f2, h2);
                break;
              case 28:
                s2.push(e3.readInt16BE());
                break;
              case 29:
                if (E2 = s2.pop() + y2, B2 = p2[E2]) {
                  i3[E2] = true;
                  T2 = e3.pos, L2 = n3;
                  e3.pos = B2.offset, n3 = B2.offset + B2.length, r4(), e3.pos = T2, n3 = L2;
                }
                break;
              case 30:
              case 31:
                for (g3 = 31 === l3; s2.length >= 4; )
                  g3 ? (C2 = f2 + s2.shift(), P2 = h2, I2 = C2 + s2.shift(), O2 = P2 + s2.shift(), h2 = O2 + s2.shift(), f2 = I2 + (1 === s2.length ? s2.shift() : 0)) : (C2 = f2, P2 = h2 + s2.shift(), I2 = C2 + s2.shift(), O2 = P2 + s2.shift(), f2 = I2 + s2.shift(), h2 = O2 + (1 === s2.length ? s2.shift() : 0)), o2.bezierCurveTo(C2, P2, I2, O2, f2, h2), g3 = !g3;
                break;
              case 12:
                switch (l3 = e3.readUInt8()) {
                  case 3:
                    var q2 = s2.pop(), G2 = s2.pop();
                    s2.push(q2 && G2 ? 1 : 0);
                    break;
                  case 4:
                    q2 = s2.pop(), G2 = s2.pop(), s2.push(q2 || G2 ? 1 : 0);
                    break;
                  case 5:
                    q2 = s2.pop(), s2.push(q2 ? 0 : 1);
                    break;
                  case 9:
                    q2 = s2.pop(), s2.push(Math.abs(q2));
                    break;
                  case 10:
                    q2 = s2.pop(), G2 = s2.pop(), s2.push(q2 + G2);
                    break;
                  case 11:
                    q2 = s2.pop(), G2 = s2.pop(), s2.push(q2 - G2);
                    break;
                  case 12:
                    q2 = s2.pop(), G2 = s2.pop(), s2.push(q2 / G2);
                    break;
                  case 14:
                    q2 = s2.pop(), s2.push(-q2);
                    break;
                  case 15:
                    q2 = s2.pop(), G2 = s2.pop(), s2.push(q2 === G2 ? 1 : 0);
                    break;
                  case 18:
                    s2.pop();
                    break;
                  case 20:
                    var V2 = s2.pop(), _2 = s2.pop();
                    u2[_2] = V2;
                    break;
                  case 21:
                    _2 = s2.pop(), s2.push(u2[_2] || 0);
                    break;
                  case 22:
                    var W2 = s2.pop(), H2 = s2.pop(), Y2 = s2.pop(), X2 = s2.pop();
                    s2.push(Y2 <= X2 ? W2 : H2);
                    break;
                  case 23:
                    s2.push(Math.random());
                    break;
                  case 24:
                    q2 = s2.pop(), G2 = s2.pop(), s2.push(q2 * G2);
                    break;
                  case 26:
                    q2 = s2.pop(), s2.push(Math.sqrt(q2));
                    break;
                  case 27:
                    q2 = s2.pop(), s2.push(q2, q2);
                    break;
                  case 28:
                    q2 = s2.pop(), G2 = s2.pop(), s2.push(G2, q2);
                    break;
                  case 29:
                    (_2 = s2.pop()) < 0 ? _2 = 0 : _2 > s2.length - 1 && (_2 = s2.length - 1), s2.push(s2[_2]);
                    break;
                  case 30:
                    var Z2 = s2.pop(), K2 = s2.pop();
                    if (K2 >= 0)
                      for (; K2 > 0; ) {
                        for (var J2 = s2[Z2 - 1], Q2 = Z2 - 2; Q2 >= 0; Q2--)
                          s2[Q2 + 1] = s2[Q2];
                        s2[0] = J2, K2--;
                      }
                    else
                      for (; K2 < 0; ) {
                        J2 = s2[0];
                        for (var $2 = 0; $2 <= Z2; $2++)
                          s2[$2] = s2[$2 + 1];
                        s2[Z2 - 1] = J2, K2++;
                      }
                    break;
                  case 34:
                    C2 = f2 + s2.shift(), P2 = h2, I2 = C2 + s2.shift(), O2 = P2 + s2.shift();
                    var ee2 = I2 + s2.shift(), te2 = O2, re2 = ee2 + s2.shift(), ne2 = te2, ie2 = re2 + s2.shift(), ae2 = ne2, oe2 = ie2 + s2.shift(), se2 = ae2;
                    f2 = oe2, h2 = se2, o2.bezierCurveTo(C2, P2, I2, O2, ee2, te2), o2.bezierCurveTo(re2, ne2, ie2, ae2, oe2, se2);
                    break;
                  case 35:
                    for (var ue2 = [], le2 = 0; le2 <= 5; le2++)
                      f2 += s2.shift(), h2 += s2.shift(), ue2.push(f2, h2);
                    o2.bezierCurveTo.apply(o2, ue2.slice(0, 6)), o2.bezierCurveTo.apply(o2, ue2.slice(6)), s2.shift();
                    break;
                  case 36:
                    C2 = f2 + s2.shift(), P2 = h2 + s2.shift(), I2 = C2 + s2.shift(), ne2 = te2 = O2 = P2 + s2.shift(), ie2 = (re2 = (ee2 = I2 + s2.shift()) + s2.shift()) + s2.shift(), ae2 = ne2 + s2.shift(), oe2 = ie2 + s2.shift(), f2 = oe2, h2 = se2 = ae2, o2.bezierCurveTo(C2, P2, I2, O2, ee2, te2), o2.bezierCurveTo(re2, ne2, ie2, ae2, oe2, se2);
                    break;
                  case 37:
                    var ce2 = f2, fe2 = h2;
                    ue2 = [];
                    for (var he2 = 0; he2 <= 4; he2++)
                      f2 += s2.shift(), h2 += s2.shift(), ue2.push(f2, h2);
                    Math.abs(f2 - ce2) > Math.abs(h2 - fe2) ? (f2 += s2.shift(), h2 = fe2) : (f2 = ce2, h2 += s2.shift()), ue2.push(f2, h2), o2.bezierCurveTo.apply(o2, ue2.slice(0, 6)), o2.bezierCurveTo.apply(o2, ue2.slice(6));
                    break;
                  default:
                    throw new Error("Unknown op: 12 " + l3);
                }
                break;
              default:
                throw new Error("Unknown op: " + l3);
            }
          else if (l3 < 247)
            s2.push(l3 - 139);
          else if (l3 < 251) {
            var de2 = e3.readUInt8();
            s2.push(256 * (l3 - 247) + de2 + 108);
          } else if (l3 < 255) {
            de2 = e3.readUInt8();
            s2.push(256 * -(l3 - 251) - de2 - 108);
          } else
            s2.push(e3.readInt32BE() / 65536);
        }
      }(), d2 && o2.closePath(), o2;
    }, n2;
  }(Oy);
  var jy = new wn.Struct({ originX: wn.uint16, originY: wn.uint16, type: new wn.String(4), data: new wn.Buffer(function(e2) {
    return e2.parent.buflen - e2._currentOffset;
  }) }), My = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2.getImageForSize = function(e3) {
      for (var t3 = 0; t3 < this._font.sbix.imageTables.length; t3++) {
        var r3 = this._font.sbix.imageTables[t3];
        if (r3.ppem >= e3)
          break;
      }
      var n3 = r3.imageOffsets, i3 = n3[this.id], a2 = n3[this.id + 1];
      return i3 === a2 ? null : (this._font.stream.pos = i3, jy.decode(this._font.stream, { buflen: a2 - i3 }));
    }, i2.render = function(t3, r3) {
      var n3 = this.getImageForSize(r3);
      if (null != n3) {
        var i3 = r3 / this._font.unitsPerEm;
        t3.image(n3.data, { height: r3, x: n3.originX, y: (this.bbox.minY - n3.originY) * i3 });
      }
      this._font.sbix.flags.renderOutlines && e2.prototype.render.call(this, t3, r3);
    }, n2;
  }(Uy);
  function Fy(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Ry(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Ry(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Ry(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  function Ny(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  var qy = function(e2, t2) {
    this.glyph = e2, this.color = t2;
  }, Gy = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2, a2, s2 = n2.prototype;
    return s2._getBBox = function() {
      for (var e3 = new Ih(), t3 = 0; t3 < this.layers.length; t3++) {
        var r3 = this.layers[t3].glyph.bbox;
        e3.addPoint(r3.minX, r3.minY), e3.addPoint(r3.maxX, r3.maxY);
      }
      return e3;
    }, s2.render = function(e3, t3) {
      for (var r3, n3 = Fy(this.layers); !(r3 = n3()).done; ) {
        var i3 = r3.value, a3 = i3.glyph, o2 = i3.color;
        e3.fillColor([o2.red, o2.green, o2.blue], o2.alpha / 255 * 100), a3.render(e3, t3);
      }
    }, i2 = n2, (a2 = [{ key: "layers", get: function() {
      for (var e3 = this._font.CPAL, t3 = this._font.COLR, r3 = 0, n3 = t3.baseGlyphRecord.length - 1; r3 <= n3; ) {
        var i3 = r3 + n3 >> 1, a3 = t3.baseGlyphRecord[i3];
        if (this.id < a3.gid)
          n3 = i3 - 1;
        else {
          if (!(this.id > a3.gid)) {
            var o2 = a3;
            break;
          }
          r3 = i3 + 1;
        }
      }
      if (null == o2) {
        var s3 = this._font._getBaseGlyph(this.id);
        return [new qy(s3, c2 = { red: 0, green: 0, blue: 0, alpha: 255 })];
      }
      for (var u2 = [], l2 = o2.firstLayerIndex; l2 < o2.firstLayerIndex + o2.numLayers; l2++) {
        a3 = t3.layerRecords[l2];
        var c2 = e3.colorRecords[a3.paletteIndex];
        s3 = this._font._getBaseGlyph(a3.gid), u2.push(new qy(s3, c2));
      }
      return u2;
    } }]) && Ny(i2.prototype, a2), n2;
  }(Oy), Vy = function() {
    function e2(e3, t3) {
      this.font = e3, this.normalizedCoords = this.normalizeCoords(t3), this.blendVectors = /* @__PURE__ */ new Map();
    }
    var t2 = e2.prototype;
    return t2.normalizeCoords = function(e3) {
      for (var t3 = [], r2 = 0; r2 < this.font.fvar.axis.length; r2++) {
        var n2 = this.font.fvar.axis[r2];
        e3[r2] < n2.defaultValue ? t3.push((e3[r2] - n2.defaultValue + Number.EPSILON) / (n2.defaultValue - n2.minValue + Number.EPSILON)) : t3.push((e3[r2] - n2.defaultValue + Number.EPSILON) / (n2.maxValue - n2.defaultValue + Number.EPSILON));
      }
      if (this.font.avar)
        for (r2 = 0; r2 < this.font.avar.segment.length; r2++)
          for (var i2 = this.font.avar.segment[r2], a2 = 0; a2 < i2.correspondence.length; a2++) {
            var o2 = i2.correspondence[a2];
            if (a2 >= 1 && t3[r2] < o2.fromCoord) {
              var s2 = i2.correspondence[a2 - 1];
              t3[r2] = ((t3[r2] - s2.fromCoord) * (o2.toCoord - s2.toCoord) + Number.EPSILON) / (o2.fromCoord - s2.fromCoord + Number.EPSILON) + s2.toCoord;
              break;
            }
          }
      return t3;
    }, t2.transformPoints = function(e3, t3) {
      if (this.font.fvar && this.font.gvar) {
        var r2 = this.font.gvar;
        if (!(e3 >= r2.glyphCount)) {
          var n2 = r2.offsets[e3];
          if (n2 !== r2.offsets[e3 + 1]) {
            var i2 = this.font.stream;
            if (i2.pos = n2, !(i2.pos >= i2.length)) {
              var a2 = i2.readUInt16BE(), o2 = n2 + i2.readUInt16BE();
              if (32768 & a2) {
                var s2 = i2.pos;
                i2.pos = o2;
                var u2 = this.decodePoints();
                o2 = i2.pos, i2.pos = s2;
              }
              var l2 = t3.map(function(e4) {
                return e4.copy();
              });
              a2 &= 4095;
              for (var c2 = 0; c2 < a2; c2++) {
                var f2 = i2.readUInt16BE(), h2 = i2.readUInt16BE();
                if (32768 & h2)
                  for (var d2 = [], p2 = 0; p2 < r2.axisCount; p2++)
                    d2.push(i2.readInt16BE() / 16384);
                else {
                  if ((4095 & h2) >= r2.globalCoordCount)
                    throw new Error("Invalid gvar table");
                  d2 = r2.globalCoords[4095 & h2];
                }
                if (16384 & h2) {
                  for (var y2 = [], g2 = 0; g2 < r2.axisCount; g2++)
                    y2.push(i2.readInt16BE() / 16384);
                  for (var v2 = [], b2 = 0; b2 < r2.axisCount; b2++)
                    v2.push(i2.readInt16BE() / 16384);
                }
                var m2 = this.tupleFactor(h2, d2, y2, v2);
                if (0 !== m2) {
                  s2 = i2.pos;
                  if (i2.pos = o2, 8192 & h2)
                    var w2 = this.decodePoints();
                  else
                    w2 = u2;
                  var S2 = 0 === w2.length ? t3.length : w2.length, x2 = this.decodeDeltas(S2), A2 = this.decodeDeltas(S2);
                  if (0 === w2.length)
                    for (var k2 = 0; k2 < t3.length; k2++) {
                      var C2 = t3[k2];
                      C2.x += Math.round(x2[k2] * m2), C2.y += Math.round(A2[k2] * m2);
                    }
                  else {
                    for (var P2 = l2.map(function(e4) {
                      return e4.copy();
                    }), I2 = t3.map(function() {
                      return false;
                    }), O2 = 0; O2 < w2.length; O2++) {
                      var E2 = w2[O2];
                      if (E2 < t3.length) {
                        var B2 = P2[E2];
                        I2[E2] = true, B2.x += Math.round(x2[O2] * m2), B2.y += Math.round(A2[O2] * m2);
                      }
                    }
                    this.interpolateMissingDeltas(P2, l2, I2);
                    for (var T2 = 0; T2 < t3.length; T2++) {
                      var L2 = P2[T2].x - l2[T2].x, z2 = P2[T2].y - l2[T2].y;
                      t3[T2].x += L2, t3[T2].y += z2;
                    }
                  }
                  o2 += f2, i2.pos = s2;
                } else
                  o2 += f2;
              }
            }
          }
        }
      }
    }, t2.decodePoints = function() {
      var e3 = this.font.stream, t3 = e3.readUInt8();
      128 & t3 && (t3 = (127 & t3) << 8 | e3.readUInt8());
      for (var r2 = new Uint16Array(t3), n2 = 0, i2 = 0; n2 < t3; )
        for (var a2 = e3.readUInt8(), o2 = 1 + (127 & a2), s2 = 128 & a2 ? e3.readUInt16 : e3.readUInt8, u2 = 0; u2 < o2 && n2 < t3; u2++)
          i2 += s2.call(e3), r2[n2++] = i2;
      return r2;
    }, t2.decodeDeltas = function(e3) {
      for (var t3 = this.font.stream, r2 = 0, n2 = new Int16Array(e3); r2 < e3; ) {
        var i2 = t3.readUInt8(), a2 = 1 + (63 & i2);
        if (128 & i2)
          r2 += a2;
        else
          for (var o2 = 64 & i2 ? t3.readInt16BE : t3.readInt8, s2 = 0; s2 < a2 && r2 < e3; s2++)
            n2[r2++] = o2.call(t3);
      }
      return n2;
    }, t2.tupleFactor = function(e3, t3, r2, n2) {
      for (var i2 = this.normalizedCoords, a2 = this.font.gvar, o2 = 1, s2 = 0; s2 < a2.axisCount; s2++)
        if (0 !== t3[s2]) {
          if (0 === i2[s2])
            return 0;
          if (0 == (16384 & e3)) {
            if (i2[s2] < Math.min(0, t3[s2]) || i2[s2] > Math.max(0, t3[s2]))
              return 0;
            o2 = (o2 * i2[s2] + Number.EPSILON) / (t3[s2] + Number.EPSILON);
          } else {
            if (i2[s2] < r2[s2] || i2[s2] > n2[s2])
              return 0;
            o2 = i2[s2] < t3[s2] ? o2 * (i2[s2] - r2[s2] + Number.EPSILON) / (t3[s2] - r2[s2] + Number.EPSILON) : o2 * (n2[s2] - i2[s2] + Number.EPSILON) / (n2[s2] - t3[s2] + Number.EPSILON);
          }
        }
      return o2;
    }, t2.interpolateMissingDeltas = function(e3, t3, r2) {
      if (0 !== e3.length)
        for (var n2 = 0; n2 < e3.length; ) {
          for (var i2 = n2, a2 = n2, o2 = e3[a2]; !o2.endContour; )
            o2 = e3[++a2];
          for (; n2 <= a2 && !r2[n2]; )
            n2++;
          if (!(n2 > a2)) {
            var s2 = n2, u2 = n2;
            for (n2++; n2 <= a2; )
              r2[n2] && (this.deltaInterpolate(u2 + 1, n2 - 1, u2, n2, t3, e3), u2 = n2), n2++;
            u2 === s2 ? this.deltaShift(i2, a2, u2, t3, e3) : (this.deltaInterpolate(u2 + 1, a2, u2, s2, t3, e3), s2 > 0 && this.deltaInterpolate(i2, s2 - 1, u2, s2, t3, e3)), n2 = a2 + 1;
          }
        }
    }, t2.deltaInterpolate = function(e3, t3, r2, n2, i2, a2) {
      if (!(e3 > t3))
        for (var o2 = ["x", "y"], s2 = 0; s2 < o2.length; s2++) {
          var u2 = o2[s2];
          if (i2[r2][u2] > i2[n2][u2]) {
            var l2 = r2;
            r2 = n2, n2 = l2;
          }
          var c2 = i2[r2][u2], f2 = i2[n2][u2], h2 = a2[r2][u2], d2 = a2[n2][u2];
          if (c2 !== f2 || h2 === d2)
            for (var p2 = c2 === f2 ? 0 : (d2 - h2) / (f2 - c2), y2 = e3; y2 <= t3; y2++) {
              var g2 = i2[y2][u2];
              g2 <= c2 ? g2 += h2 - c2 : g2 >= f2 ? g2 += d2 - f2 : g2 = h2 + (g2 - c2) * p2, a2[y2][u2] = g2;
            }
        }
    }, t2.deltaShift = function(e3, t3, r2, n2, i2) {
      var a2 = i2[r2].x - n2[r2].x, o2 = i2[r2].y - n2[r2].y;
      if (0 !== a2 || 0 !== o2)
        for (var s2 = e3; s2 <= t3; s2++)
          s2 !== r2 && (i2[s2].x += a2, i2[s2].y += o2);
    }, t2.getAdvanceAdjustment = function(e3, t3) {
      var r2, n2;
      if (t3.advanceWidthMapping) {
        var i2 = e3;
        i2 >= t3.advanceWidthMapping.mapCount && (i2 = t3.advanceWidthMapping.mapCount - 1);
        t3.advanceWidthMapping.entryFormat;
        var a2 = t3.advanceWidthMapping.mapData[i2];
        r2 = a2.outerIndex, n2 = a2.innerIndex;
      } else
        r2 = 0, n2 = e3;
      return this.getDelta(t3.itemVariationStore, r2, n2);
    }, t2.getDelta = function(e3, t3, r2) {
      if (t3 >= e3.itemVariationData.length)
        return 0;
      var n2 = e3.itemVariationData[t3];
      if (r2 >= n2.deltaSets.length)
        return 0;
      for (var i2 = n2.deltaSets[r2], a2 = this.getBlendVector(e3, t3), o2 = 0, s2 = 0; s2 < n2.regionIndexCount; s2++)
        o2 += i2.deltas[s2] * a2[s2];
      return o2;
    }, t2.getBlendVector = function(e3, t3) {
      var r2 = e3.itemVariationData[t3];
      if (this.blendVectors.has(r2))
        return this.blendVectors.get(r2);
      for (var n2 = this.normalizedCoords, i2 = [], a2 = 0; a2 < r2.regionIndexCount; a2++) {
        for (var o2 = 1, s2 = r2.regionIndexes[a2], u2 = e3.variationRegionList.variationRegions[s2], l2 = 0; l2 < u2.length; l2++) {
          var c2 = u2[l2];
          o2 *= c2.startCoord > c2.peakCoord || c2.peakCoord > c2.endCoord || c2.startCoord < 0 && c2.endCoord > 0 && 0 !== c2.peakCoord || 0 === c2.peakCoord ? 1 : n2[l2] < c2.startCoord || n2[l2] > c2.endCoord ? 0 : n2[l2] === c2.peakCoord ? 1 : n2[l2] < c2.peakCoord ? (n2[l2] - c2.startCoord + Number.EPSILON) / (c2.peakCoord - c2.startCoord + Number.EPSILON) : (c2.endCoord - n2[l2] + Number.EPSILON) / (c2.endCoord - c2.peakCoord + Number.EPSILON);
        }
        i2[a2] = o2;
      }
      return this.blendVectors.set(r2, i2), i2;
    }, e2;
  }(), _y = t(function(e2) {
    var t2 = function() {
      function e3(t4, n2, i2, a2) {
        "object" == typeof n2 && (i2 = n2.depth, a2 = n2.prototype, n2.filter, n2 = n2.circular);
        var o2 = [], s2 = [], u2 = void 0 !== b;
        return void 0 === n2 && (n2 = true), void 0 === i2 && (i2 = 1 / 0), function t5(i3, l2) {
          if (null === i3)
            return null;
          if (0 == l2)
            return i3;
          var c2, f2;
          if ("object" != typeof i3)
            return i3;
          if (e3.__isArray(i3))
            c2 = [];
          else if (e3.__isRegExp(i3))
            c2 = new RegExp(i3.source, r2(i3)), i3.lastIndex && (c2.lastIndex = i3.lastIndex);
          else if (e3.__isDate(i3))
            c2 = new Date(i3.getTime());
          else {
            if (u2 && b.isBuffer(i3))
              return c2 = b.allocUnsafe ? b.allocUnsafe(i3.length) : new b(i3.length), i3.copy(c2), c2;
            void 0 === a2 ? (f2 = Object.getPrototypeOf(i3), c2 = Object.create(f2)) : (c2 = Object.create(a2), f2 = a2);
          }
          if (n2) {
            var h2 = o2.indexOf(i3);
            if (-1 != h2)
              return s2[h2];
            o2.push(i3), s2.push(c2);
          }
          for (var d2 in i3) {
            var p2;
            f2 && (p2 = Object.getOwnPropertyDescriptor(f2, d2)), p2 && null == p2.set || (c2[d2] = t5(i3[d2], l2 - 1));
          }
          return c2;
        }(t4, i2);
      }
      function t3(e4) {
        return Object.prototype.toString.call(e4);
      }
      function r2(e4) {
        var t4 = "";
        return e4.global && (t4 += "g"), e4.ignoreCase && (t4 += "i"), e4.multiline && (t4 += "m"), t4;
      }
      return e3.clonePrototype = function(e4) {
        if (null === e4)
          return null;
        var t4 = function() {
        };
        return t4.prototype = e4, new t4();
      }, e3.__objToStr = t3, e3.__isDate = function(e4) {
        return "object" == typeof e4 && "[object Date]" === t3(e4);
      }, e3.__isArray = function(e4) {
        return "object" == typeof e4 && "[object Array]" === t3(e4);
      }, e3.__isRegExp = function(e4) {
        return "object" == typeof e4 && "[object RegExp]" === t3(e4);
      }, e3.__getRegExpFlags = r2, e3;
    }();
    e2.exports && (e2.exports = t2);
  }), Wy = function() {
    function e2(e3) {
      this.font = e3, this.glyphs = [], this.mapping = {}, this.includeGlyph(0);
    }
    var t2 = e2.prototype;
    return t2.includeGlyph = function(e3) {
      return "object" == typeof e3 && (e3 = e3.id), null == this.mapping[e3] && (this.glyphs.push(e3), this.mapping[e3] = this.glyphs.length - 1), this.mapping[e3];
    }, t2.encodeStream = function() {
      var e3 = this, t3 = new wn.EncodeStream();
      return V(function() {
        return e3.encode(t3), t3.end();
      }), t3;
    }, e2;
  }(), Hy = function() {
    function e2() {
    }
    return e2.size = function(e3) {
      return e3 >= 0 && e3 <= 255 ? 1 : 2;
    }, e2.encode = function(e3, t2) {
      t2 >= 0 && t2 <= 255 ? e3.writeUInt8(t2) : e3.writeInt16BE(t2);
    }, e2;
  }(), Yy = new wn.Struct({ numberOfContours: wn.int16, xMin: wn.int16, yMin: wn.int16, xMax: wn.int16, yMax: wn.int16, endPtsOfContours: new wn.Array(wn.uint16, "numberOfContours"), instructions: new wn.Array(wn.uint8, wn.uint16), flags: new wn.Array(wn.uint8, 0), xPoints: new wn.Array(Hy, 0), yPoints: new wn.Array(Hy, 0) }), Xy = function() {
    function e2() {
    }
    var t2 = e2.prototype;
    return t2.encodeSimple = function(e3, t3) {
      void 0 === t3 && (t3 = []);
      for (var r2 = [], n2 = [], i2 = [], a2 = [], o2 = 0, s2 = 0, u2 = 0, l2 = 0, c2 = 0, f2 = 0; f2 < e3.commands.length; f2++) {
        for (var h2 = e3.commands[f2], d2 = 0; d2 < h2.args.length; d2 += 2) {
          var p2 = h2.args[d2], y2 = h2.args[d2 + 1], g2 = 0;
          if ("quadraticCurveTo" === h2.command && 2 === d2) {
            var v2 = e3.commands[f2 + 1];
            if (v2 && "quadraticCurveTo" === v2.command) {
              var b2 = (s2 + v2.args[0]) / 2, m2 = (u2 + v2.args[1]) / 2;
              if (p2 === b2 && y2 === m2)
                continue;
            }
          }
          "quadraticCurveTo" === h2.command && 0 === d2 || (g2 |= 1), g2 = this._encodePoint(p2, s2, n2, g2, 2, 16), (g2 = this._encodePoint(y2, u2, i2, g2, 4, 32)) === l2 && o2 < 255 ? (a2[a2.length - 1] |= 8, o2++) : (o2 > 0 && (a2.push(o2), o2 = 0), a2.push(g2), l2 = g2), s2 = p2, u2 = y2, c2++;
        }
        "closePath" === h2.command && r2.push(c2 - 1);
      }
      e3.commands.length > 1 && "closePath" !== e3.commands[e3.commands.length - 1].command && r2.push(c2 - 1);
      var w2 = e3.bbox, S2 = { numberOfContours: r2.length, xMin: w2.minX, yMin: w2.minY, xMax: w2.maxX, yMax: w2.maxY, endPtsOfContours: r2, instructions: t3, flags: a2, xPoints: n2, yPoints: i2 }, x2 = Yy.size(S2), A2 = 4 - x2 % 4, k2 = new wn.EncodeStream(x2 + A2);
      return Yy.encode(k2, S2), 0 !== A2 && k2.fill(0, A2), k2.buffer;
    }, t2._encodePoint = function(e3, t3, r2, n2, i2, a2) {
      var o2 = e3 - t3;
      return e3 === t3 ? n2 |= a2 : (-255 <= o2 && o2 <= 255 && (n2 |= i2, o2 < 0 ? o2 = -o2 : n2 |= a2), r2.push(o2)), n2;
    }, e2;
  }();
  function Zy(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return Ky(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return Ky(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function Ky(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var Jy = function(e2) {
    var t2, r2;
    function n2(t3) {
      var r3;
      return (r3 = e2.call(this, t3) || this).glyphEncoder = new Xy(), r3;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2._addGlyph = function(e3) {
      var t3 = this.font.getGlyph(e3), r3 = t3._decode(), n3 = this.font.loca.offsets[e3], i3 = this.font.loca.offsets[e3 + 1], a2 = this.font._getTableStream("glyf");
      a2.pos += n3;
      var o2 = a2.readBuffer(i3 - n3);
      if (r3 && r3.numberOfContours < 0) {
        o2 = new b(o2);
        for (var s2, u2 = Zy(r3.components); !(s2 = u2()).done; ) {
          var l2 = s2.value;
          e3 = this.includeGlyph(l2.glyphID), o2.writeUInt16BE(e3, l2.pos);
        }
      } else
        r3 && this.font._variationProcessor && (o2 = this.glyphEncoder.encodeSimple(t3.path, r3.instructions));
      return this.glyf.push(o2), this.loca.offsets.push(this.offset), this.hmtx.metrics.push({ advance: t3.advanceWidth, bearing: t3._getMetrics().leftBearing }), this.offset += o2.length, this.glyf.length - 1;
    }, i2.encode = function(e3) {
      this.glyf = [], this.offset = 0, this.loca = { offsets: [] }, this.hmtx = { metrics: [], bearings: [] };
      for (var t3 = 0; t3 < this.glyphs.length; )
        this._addGlyph(this.glyphs[t3++]);
      var r3 = _y(this.font.maxp);
      r3.numGlyphs = this.glyf.length, this.loca.offsets.push(this.offset), El.loca.preEncode.call(this.loca);
      var n3 = _y(this.font.head);
      n3.indexToLocFormat = this.loca.version;
      var i3 = _y(this.font.hhea);
      i3.numberOfMetrics = this.hmtx.metrics.length, Ul.encode(e3, { tables: { head: n3, hhea: i3, loca: this.loca, maxp: r3, "cvt ": this.font["cvt "], prep: this.font.prep, glyf: this.glyf, hmtx: this.hmtx, fpgm: this.font.fpgm } });
    }, n2;
  }(Wy);
  function Qy(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return $y(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return $y(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function $y(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var eg, tg = function(e2) {
    var t2, r2;
    function n2(t3) {
      var r3;
      if ((r3 = e2.call(this, t3) || this).cff = r3.font["CFF "], !r3.cff)
        throw new Error("Not a CFF Font");
      return r3;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2.subsetCharstrings = function() {
      this.charstrings = [];
      for (var e3, t3 = {}, r3 = Qy(this.glyphs); !(e3 = r3()).done; ) {
        var n3 = e3.value;
        this.charstrings.push(this.cff.getCharString(n3));
        var i3 = this.font.getGlyph(n3);
        i3.path;
        for (var a2 in i3._usedGsubrs)
          t3[a2] = true;
      }
      this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, t3);
    }, i2.subsetSubrs = function(e3, t3) {
      for (var r3 = [], n3 = 0; n3 < e3.length; n3++) {
        var i3 = e3[n3];
        t3[n3] ? (this.cff.stream.pos = i3.offset, r3.push(this.cff.stream.readBuffer(i3.length))) : r3.push(new b([11]));
      }
      return r3;
    }, i2.subsetFontdict = function(e3) {
      e3.FDArray = [], e3.FDSelect = { version: 0, fds: [] };
      for (var t3, r3 = {}, n3 = [], i3 = Qy(this.glyphs); !(t3 = i3()).done; ) {
        var a2 = t3.value, o2 = this.cff.fdForGlyph(a2);
        if (null != o2) {
          r3[o2] || (e3.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[o2])), n3.push({})), r3[o2] = true, e3.FDSelect.fds.push(e3.FDArray.length - 1);
          var s2 = this.font.getGlyph(a2);
          s2.path;
          for (var u2 in s2._usedSubrs)
            n3[n3.length - 1][u2] = true;
        }
      }
      for (var l2 = 0; l2 < e3.FDArray.length; l2++) {
        var c2 = e3.FDArray[l2];
        delete c2.FontName, c2.Private && c2.Private.Subrs && (c2.Private = Object.assign({}, c2.Private), c2.Private.Subrs = this.subsetSubrs(c2.Private.Subrs, n3[l2]));
      }
    }, i2.createCIDFontdict = function(e3) {
      for (var t3, r3 = {}, n3 = Qy(this.glyphs); !(t3 = n3()).done; ) {
        var i3 = t3.value, a2 = this.font.getGlyph(i3);
        a2.path;
        for (var o2 in a2._usedSubrs)
          r3[o2] = true;
      }
      var s2 = Object.assign({}, this.cff.topDict.Private);
      return this.cff.topDict.Private && this.cff.topDict.Private.Subrs && (s2.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, r3)), e3.FDArray = [{ Private: s2 }], e3.FDSelect = { version: 3, nRanges: 1, ranges: [{ first: 0, fd: 0 }], sentinel: this.charstrings.length };
    }, i2.addString = function(e3) {
      return e3 ? (this.strings || (this.strings = []), this.strings.push(e3), Ja.length + this.strings.length - 1) : null;
    }, i2.encode = function(e3) {
      this.subsetCharstrings();
      var t3 = { version: this.charstrings.length > 255 ? 2 : 1, ranges: [{ first: 1, nLeft: this.charstrings.length - 2 }] }, r3 = Object.assign({}, this.cff.topDict);
      r3.Private = null, r3.charset = t3, r3.Encoding = null, r3.CharStrings = this.charstrings;
      for (var n3 = 0, i3 = ["version", "Notice", "Copyright", "FullName", "FamilyName", "Weight", "PostScript", "BaseFontName", "FontName"]; n3 < i3.length; n3++) {
        var a2 = i3[n3];
        r3[a2] = this.addString(this.cff.string(r3[a2]));
      }
      r3.ROS = [this.addString("Adobe"), this.addString("Identity"), 0], r3.CIDCount = this.charstrings.length, this.cff.isCIDFont ? this.subsetFontdict(r3) : this.createCIDFontdict(r3);
      var o2 = { version: 1, hdrSize: this.cff.hdrSize, offSize: this.cff.length, header: this.cff.header, nameIndex: [this.cff.postscriptName], topDictIndex: [r3], stringIndex: this.strings, globalSubrIndex: this.gsubrs };
      ts.encode(e3, o2);
    }, n2;
  }(Wy);
  function rg(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return ng(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return ng(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function ng(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  function ig(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  function ag(e2, t2, r2, n2, i2) {
    var a2 = {};
    return Object.keys(n2).forEach(function(e3) {
      a2[e3] = n2[e3];
    }), a2.enumerable = !!a2.enumerable, a2.configurable = !!a2.configurable, ("value" in a2 || a2.initializer) && (a2.writable = true), a2 = r2.slice().reverse().reduce(function(r3, n3) {
      return n3(e2, t2, r3) || r3;
    }, a2), i2 && void 0 !== a2.initializer && (a2.value = a2.initializer ? a2.initializer.call(i2) : void 0, a2.initializer = void 0), void 0 === a2.initializer && (Object.defineProperty(e2, t2, a2), a2 = null), a2;
  }
  var og = (ag((eg = function() {
    function e2(e3, t3) {
      for (var r3 in void 0 === t3 && (t3 = null), this.stream = e3, this.variationCoords = t3, this._directoryPos = this.stream.pos, this._tables = {}, this._glyphs = {}, this._decodeDirectory(), this.directory.tables) {
        var n2 = this.directory.tables[r3];
        El[r3] && n2.length > 0 && Object.defineProperty(this, r3, { get: this._getTable.bind(this, n2) });
      }
    }
    e2.probe = function(e3) {
      var t3 = e3.toString("ascii", 0, 4);
      return "true" === t3 || "OTTO" === t3 || t3 === String.fromCharCode(0, 1, 0, 0);
    };
    var t2, r2, i2 = e2.prototype;
    return i2._getTable = function(e3) {
      if (!(e3.tag in this._tables))
        try {
          this._tables[e3.tag] = this._decodeTable(e3);
        } catch (t3) {
          xn.logErrors && (console.error("Error decoding table " + e3.tag), console.error(t3.stack));
        }
      return this._tables[e3.tag];
    }, i2._getTableStream = function(e3) {
      var t3 = this.directory.tables[e3];
      return t3 ? (this.stream.pos = t3.offset, this.stream) : null;
    }, i2._decodeDirectory = function() {
      return this.directory = Ul.decode(this.stream, { _startOffset: 0 });
    }, i2._decodeTable = function(e3) {
      var t3 = this.stream.pos, r3 = this._getTableStream(e3.tag), n2 = El[e3.tag].decode(r3, this, e3.length);
      return this.stream.pos = t3, n2;
    }, i2.getName = function(e3, t3) {
      void 0 === t3 && (t3 = "en");
      var r3 = this.name.records[e3];
      return r3 ? r3[t3] : null;
    }, i2.hasGlyphForCodePoint = function(e3) {
      return !!this._cmapProcessor.lookup(e3);
    }, i2.glyphForCodePoint = function(e3) {
      return this.getGlyph(this._cmapProcessor.lookup(e3), [e3]);
    }, i2.glyphsForString = function(e3) {
      for (var t3 = [], r3 = e3.length, n2 = 0, i3 = -1, a2 = -1; n2 <= r3; ) {
        var o2 = 0, s2 = 0;
        if (n2 < r3) {
          if (55296 <= (o2 = e3.charCodeAt(n2++)) && o2 <= 56319 && n2 < r3) {
            var u2 = e3.charCodeAt(n2);
            56320 <= u2 && u2 <= 57343 && (n2++, o2 = ((1023 & o2) << 10) + (1023 & u2) + 65536);
          }
          s2 = 65024 <= o2 && o2 <= 65039 || 917760 <= o2 && o2 <= 917999 ? 1 : 0;
        } else
          n2++;
        0 === a2 && 1 === s2 ? t3.push(this.getGlyph(this._cmapProcessor.lookup(i3, o2), [i3, o2])) : 0 === a2 && 0 === s2 && t3.push(this.glyphForCodePoint(i3)), i3 = o2, a2 = s2;
      }
      return t3;
    }, i2.layout = function(e3, t3, r3, n2, i3) {
      return this._layoutEngine.layout(e3, t3, r3, n2, i3);
    }, i2.stringsForGlyph = function(e3) {
      return this._layoutEngine.stringsForGlyph(e3);
    }, i2.getAvailableFeatures = function(e3, t3) {
      return this._layoutEngine.getAvailableFeatures(e3, t3);
    }, i2._getBaseGlyph = function(e3, t3) {
      return void 0 === t3 && (t3 = []), this._glyphs[e3] || (this.directory.tables.glyf ? this._glyphs[e3] = new Uy(e3, t3, this) : (this.directory.tables["CFF "] || this.directory.tables.CFF2) && (this._glyphs[e3] = new Dy(e3, t3, this))), this._glyphs[e3] || null;
    }, i2.getGlyph = function(e3, t3) {
      return void 0 === t3 && (t3 = []), this._glyphs[e3] || (this.directory.tables.sbix ? this._glyphs[e3] = new My(e3, t3, this) : this.directory.tables.COLR && this.directory.tables.CPAL ? this._glyphs[e3] = new Gy(e3, t3, this) : this._getBaseGlyph(e3, t3)), this._glyphs[e3] || null;
    }, i2.createSubset = function() {
      return this.directory.tables["CFF "] ? new tg(this) : new Jy(this);
    }, i2.getVariation = function(t3) {
      if (!this.directory.tables.fvar || !(this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2))
        throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
      if ("string" == typeof t3 && (t3 = this.namedVariations[t3]), "object" != typeof t3)
        throw new Error("Variation settings must be either a variation name or settings object.");
      var r3 = this.fvar.axis.map(function(e3, r4) {
        var n3 = e3.axisTag.trim();
        return n3 in t3 ? Math.max(e3.minValue, Math.min(e3.maxValue, t3[n3])) : e3.defaultValue;
      }), n2 = new wn.DecodeStream(this.stream.buffer);
      n2.pos = this._directoryPos;
      var i3 = new e2(n2, r3);
      return i3._tables = this._tables, i3;
    }, i2.getFont = function(e3) {
      return this.getVariation(e3);
    }, t2 = e2, (r2 = [{ key: "postscriptName", get: function() {
      var e3 = this.name.records.postscriptName;
      return e3 ? e3[Object.keys(e3)[0]] : null;
    } }, { key: "fullName", get: function() {
      return this.getName("fullName");
    } }, { key: "familyName", get: function() {
      return this.getName("fontFamily");
    } }, { key: "subfamilyName", get: function() {
      return this.getName("fontSubfamily");
    } }, { key: "copyright", get: function() {
      return this.getName("copyright");
    } }, { key: "version", get: function() {
      return this.getName("version");
    } }, { key: "ascent", get: function() {
      return this.hhea.ascent;
    } }, { key: "descent", get: function() {
      return this.hhea.descent;
    } }, { key: "lineGap", get: function() {
      return this.hhea.lineGap;
    } }, { key: "underlinePosition", get: function() {
      return this.post.underlinePosition;
    } }, { key: "underlineThickness", get: function() {
      return this.post.underlineThickness;
    } }, { key: "italicAngle", get: function() {
      return this.post.italicAngle;
    } }, { key: "capHeight", get: function() {
      var e3 = this["OS/2"];
      return e3 ? e3.capHeight : this.ascent;
    } }, { key: "xHeight", get: function() {
      var e3 = this["OS/2"];
      return e3 ? e3.xHeight : 0;
    } }, { key: "numGlyphs", get: function() {
      return this.maxp.numGlyphs;
    } }, { key: "unitsPerEm", get: function() {
      return this.head.unitsPerEm;
    } }, { key: "bbox", get: function() {
      return Object.freeze(new Ih(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
    } }, { key: "_cmapProcessor", get: function() {
      return new Nl(this.cmap);
    } }, { key: "characterSet", get: function() {
      return this._cmapProcessor.getCharacterSet();
    } }, { key: "_layoutEngine", get: function() {
      return new yy(this);
    } }, { key: "availableFeatures", get: function() {
      return this._layoutEngine.getAvailableFeatures();
    } }, { key: "variationAxes", get: function() {
      var e3 = {};
      if (!this.fvar)
        return e3;
      for (var t3, r3 = rg(this.fvar.axis); !(t3 = r3()).done; ) {
        var n2 = t3.value;
        e3[n2.axisTag.trim()] = { name: n2.name.en, min: n2.minValue, default: n2.defaultValue, max: n2.maxValue };
      }
      return e3;
    } }, { key: "namedVariations", get: function() {
      var e3 = {};
      if (!this.fvar)
        return e3;
      for (var t3, r3 = rg(this.fvar.instance); !(t3 = r3()).done; ) {
        for (var n2 = t3.value, i3 = {}, a2 = 0; a2 < this.fvar.axis.length; a2++)
          i3[this.fvar.axis[a2].axisTag.trim()] = n2.coord[a2];
        e3[n2.name.en] = i3;
      }
      return e3;
    } }, { key: "_variationProcessor", get: function() {
      if (!this.fvar)
        return null;
      var e3 = this.variationCoords;
      return e3 || this.CFF2 ? (e3 || (e3 = this.fvar.axis.map(function(e4) {
        return e4.defaultValue;
      })), new Vy(this, e3)) : null;
    } }]) && ig(t2.prototype, r2), e2;
  }()).prototype, "bbox", [An], Object.getOwnPropertyDescriptor(eg.prototype, "bbox"), eg.prototype), ag(eg.prototype, "_cmapProcessor", [An], Object.getOwnPropertyDescriptor(eg.prototype, "_cmapProcessor"), eg.prototype), ag(eg.prototype, "characterSet", [An], Object.getOwnPropertyDescriptor(eg.prototype, "characterSet"), eg.prototype), ag(eg.prototype, "_layoutEngine", [An], Object.getOwnPropertyDescriptor(eg.prototype, "_layoutEngine"), eg.prototype), ag(eg.prototype, "variationAxes", [An], Object.getOwnPropertyDescriptor(eg.prototype, "variationAxes"), eg.prototype), ag(eg.prototype, "namedVariations", [An], Object.getOwnPropertyDescriptor(eg.prototype, "namedVariations"), eg.prototype), ag(eg.prototype, "_variationProcessor", [An], Object.getOwnPropertyDescriptor(eg.prototype, "_variationProcessor"), eg.prototype), eg);
  function sg(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return ug(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return ug(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function ug(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  var lg = new wn.Struct({ tag: new wn.String(4), offset: new wn.Pointer(wn.uint32, "void", { type: "global" }), compLength: wn.uint32, length: wn.uint32, origChecksum: wn.uint32 }), cg = new wn.Struct({ tag: new wn.String(4), flavor: wn.uint32, length: wn.uint32, numTables: wn.uint16, reserved: new wn.Reserved(wn.uint16), totalSfntSize: wn.uint32, majorVersion: wn.uint16, minorVersion: wn.uint16, metaOffset: wn.uint32, metaLength: wn.uint32, metaOrigLength: wn.uint32, privOffset: wn.uint32, privLength: wn.uint32, tables: new wn.Array(lg, "numTables") });
  cg.process = function() {
    for (var e2, t2 = {}, r2 = sg(this.tables); !(e2 = r2()).done; ) {
      var n2 = e2.value;
      t2[n2.tag] = n2;
    }
    this.tables = t2;
  };
  function fg() {
    this.table = new Uint16Array(16), this.trans = new Uint16Array(288);
  }
  function hg(e2, t2) {
    this.source = e2, this.sourceIndex = 0, this.tag = 0, this.bitcount = 0, this.dest = t2, this.destLen = 0, this.ltree = new fg(), this.dtree = new fg();
  }
  var dg = new fg(), pg = new fg(), yg = new Uint8Array(30), gg = new Uint16Array(30), vg = new Uint8Array(30), bg = new Uint16Array(30), mg = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), wg = new fg(), Sg = new Uint8Array(320);
  function xg(e2, t2, r2, n2) {
    var i2, a2;
    for (i2 = 0; i2 < r2; ++i2)
      e2[i2] = 0;
    for (i2 = 0; i2 < 30 - r2; ++i2)
      e2[i2 + r2] = i2 / r2 | 0;
    for (a2 = n2, i2 = 0; i2 < 30; ++i2)
      t2[i2] = a2, a2 += 1 << e2[i2];
  }
  var Ag = new Uint16Array(16);
  function kg(e2, t2, r2, n2) {
    var i2, a2;
    for (i2 = 0; i2 < 16; ++i2)
      e2.table[i2] = 0;
    for (i2 = 0; i2 < n2; ++i2)
      e2.table[t2[r2 + i2]]++;
    for (e2.table[0] = 0, a2 = 0, i2 = 0; i2 < 16; ++i2)
      Ag[i2] = a2, a2 += e2.table[i2];
    for (i2 = 0; i2 < n2; ++i2)
      t2[r2 + i2] && (e2.trans[Ag[t2[r2 + i2]]++] = i2);
  }
  function Cg(e2) {
    e2.bitcount-- || (e2.tag = e2.source[e2.sourceIndex++], e2.bitcount = 7);
    var t2 = 1 & e2.tag;
    return e2.tag >>>= 1, t2;
  }
  function Pg(e2, t2, r2) {
    if (!t2)
      return r2;
    for (; e2.bitcount < 24; )
      e2.tag |= e2.source[e2.sourceIndex++] << e2.bitcount, e2.bitcount += 8;
    var n2 = e2.tag & 65535 >>> 16 - t2;
    return e2.tag >>>= t2, e2.bitcount -= t2, n2 + r2;
  }
  function Ig(e2, t2) {
    for (; e2.bitcount < 24; )
      e2.tag |= e2.source[e2.sourceIndex++] << e2.bitcount, e2.bitcount += 8;
    var r2 = 0, n2 = 0, i2 = 0, a2 = e2.tag;
    do {
      n2 = 2 * n2 + (1 & a2), a2 >>>= 1, ++i2, r2 += t2.table[i2], n2 -= t2.table[i2];
    } while (n2 >= 0);
    return e2.tag = a2, e2.bitcount -= i2, t2.trans[r2 + n2];
  }
  function Og(e2, t2, r2) {
    var n2, i2, a2, o2, s2, u2;
    for (n2 = Pg(e2, 5, 257), i2 = Pg(e2, 5, 1), a2 = Pg(e2, 4, 4), o2 = 0; o2 < 19; ++o2)
      Sg[o2] = 0;
    for (o2 = 0; o2 < a2; ++o2) {
      var l2 = Pg(e2, 3, 0);
      Sg[mg[o2]] = l2;
    }
    for (kg(wg, Sg, 0, 19), s2 = 0; s2 < n2 + i2; ) {
      var c2 = Ig(e2, wg);
      switch (c2) {
        case 16:
          var f2 = Sg[s2 - 1];
          for (u2 = Pg(e2, 2, 3); u2; --u2)
            Sg[s2++] = f2;
          break;
        case 17:
          for (u2 = Pg(e2, 3, 3); u2; --u2)
            Sg[s2++] = 0;
          break;
        case 18:
          for (u2 = Pg(e2, 7, 11); u2; --u2)
            Sg[s2++] = 0;
          break;
        default:
          Sg[s2++] = c2;
      }
    }
    kg(t2, Sg, 0, n2), kg(r2, Sg, n2, i2);
  }
  function Eg(e2, t2, r2) {
    for (; ; ) {
      var n2, i2, a2, o2, s2 = Ig(e2, t2);
      if (256 === s2)
        return 0;
      if (s2 < 256)
        e2.dest[e2.destLen++] = s2;
      else
        for (n2 = Pg(e2, yg[s2 -= 257], gg[s2]), i2 = Ig(e2, r2), o2 = a2 = e2.destLen - Pg(e2, vg[i2], bg[i2]); o2 < a2 + n2; ++o2)
          e2.dest[e2.destLen++] = e2.dest[o2];
    }
  }
  function Bg(e2) {
    for (var t2, r2; e2.bitcount > 8; )
      e2.sourceIndex--, e2.bitcount -= 8;
    if ((t2 = 256 * (t2 = e2.source[e2.sourceIndex + 1]) + e2.source[e2.sourceIndex]) !== (65535 & ~(256 * e2.source[e2.sourceIndex + 3] + e2.source[e2.sourceIndex + 2])))
      return -3;
    for (e2.sourceIndex += 4, r2 = t2; r2; --r2)
      e2.dest[e2.destLen++] = e2.source[e2.sourceIndex++];
    return e2.bitcount = 0, 0;
  }
  !function(e2, t2) {
    var r2;
    for (r2 = 0; r2 < 7; ++r2)
      e2.table[r2] = 0;
    for (e2.table[7] = 24, e2.table[8] = 152, e2.table[9] = 112, r2 = 0; r2 < 24; ++r2)
      e2.trans[r2] = 256 + r2;
    for (r2 = 0; r2 < 144; ++r2)
      e2.trans[24 + r2] = r2;
    for (r2 = 0; r2 < 8; ++r2)
      e2.trans[168 + r2] = 280 + r2;
    for (r2 = 0; r2 < 112; ++r2)
      e2.trans[176 + r2] = 144 + r2;
    for (r2 = 0; r2 < 5; ++r2)
      t2.table[r2] = 0;
    for (t2.table[5] = 32, r2 = 0; r2 < 32; ++r2)
      t2.trans[r2] = r2;
  }(dg, pg), xg(yg, gg, 4, 3), xg(vg, bg, 2, 1), yg[28] = 0, gg[28] = 258;
  var Tg = function(e2, t2) {
    var r2, n2, i2 = new hg(e2, t2);
    do {
      switch (r2 = Cg(i2), Pg(i2, 2, 0)) {
        case 0:
          n2 = Bg(i2);
          break;
        case 1:
          n2 = Eg(i2, dg, pg);
          break;
        case 2:
          Og(i2, i2.ltree, i2.dtree), n2 = Eg(i2, i2.ltree, i2.dtree);
          break;
        default:
          n2 = -3;
      }
      if (0 !== n2)
        throw new Error("Data error");
    } while (!r2);
    return i2.destLen < i2.dest.length ? "function" == typeof i2.dest.slice ? i2.dest.slice(0, i2.destLen) : i2.dest.subarray(0, i2.destLen) : i2.dest;
  };
  var Lg = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.probe = function(e3) {
      return "wOFF" === e3.toString("ascii", 0, 4);
    };
    var i2 = n2.prototype;
    return i2._decodeDirectory = function() {
      this.directory = cg.decode(this.stream, { _startOffset: 0 });
    }, i2._getTableStream = function(e3) {
      var t3 = this.directory.tables[e3];
      if (t3) {
        if (this.stream.pos = t3.offset, t3.compLength < t3.length) {
          this.stream.pos += 2;
          var r3 = new b(t3.length), n3 = Tg(this.stream.readBuffer(t3.compLength - 2), r3);
          return new wn.DecodeStream(n3);
        }
        return this.stream;
      }
      return null;
    }, n2;
  }(og);
  function zg(e2) {
    this.buffer = e2, this.pos = 0;
  }
  zg.prototype.read = function(e2, t2, r2) {
    this.pos + r2 > this.buffer.length && (r2 = this.buffer.length - this.pos);
    for (var n2 = 0; n2 < r2; n2++)
      e2[t2 + n2] = this.buffer[this.pos + n2];
    return this.pos += r2, r2;
  };
  var Ug = zg;
  function Dg(e2) {
    this.buffer = e2, this.pos = 0;
  }
  Dg.prototype.write = function(e2, t2) {
    if (this.pos + t2 > this.buffer.length)
      throw new Error("Output buffer is not large enough");
    return this.buffer.set(e2.subarray(0, t2), this.pos), this.pos += t2, t2;
  };
  var jg = { BrotliInput: Ug, BrotliOutput: Dg }, Mg = new Uint32Array([0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215]);
  function Fg(e2) {
    this.buf_ = new Uint8Array(8224), this.input_ = e2, this.reset();
  }
  Fg.READ_SIZE = 4096, Fg.IBUF_MASK = 8191, Fg.prototype.reset = function() {
    this.buf_ptr_ = 0, this.val_ = 0, this.pos_ = 0, this.bit_pos_ = 0, this.bit_end_pos_ = 0, this.eos_ = 0, this.readMoreInput();
    for (var e2 = 0; e2 < 4; e2++)
      this.val_ |= this.buf_[this.pos_] << 8 * e2, ++this.pos_;
    return this.bit_end_pos_ > 0;
  }, Fg.prototype.readMoreInput = function() {
    if (!(this.bit_end_pos_ > 256))
      if (this.eos_) {
        if (this.bit_pos_ > this.bit_end_pos_)
          throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
      } else {
        var e2 = this.buf_ptr_, t2 = this.input_.read(this.buf_, e2, 4096);
        if (t2 < 0)
          throw new Error("Unexpected end of input");
        if (t2 < 4096) {
          this.eos_ = 1;
          for (var r2 = 0; r2 < 32; r2++)
            this.buf_[e2 + t2 + r2] = 0;
        }
        if (0 === e2) {
          for (r2 = 0; r2 < 32; r2++)
            this.buf_[8192 + r2] = this.buf_[r2];
          this.buf_ptr_ = 4096;
        } else
          this.buf_ptr_ = 0;
        this.bit_end_pos_ += t2 << 3;
      }
  }, Fg.prototype.fillBitWindow = function() {
    for (; this.bit_pos_ >= 8; )
      this.val_ >>>= 8, this.val_ |= this.buf_[8191 & this.pos_] << 24, ++this.pos_, this.bit_pos_ = this.bit_pos_ - 8 >>> 0, this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
  }, Fg.prototype.readBits = function(e2) {
    32 - this.bit_pos_ < e2 && this.fillBitWindow();
    var t2 = this.val_ >>> this.bit_pos_ & Mg[e2];
    return this.bit_pos_ += e2, t2;
  };
  for (var Rg = Fg, Ng = function(e2) {
    var t2 = Zg(e2), r2 = t2[0], n2 = t2[1];
    return 3 * (r2 + n2) / 4 - n2;
  }, qg = function(e2) {
    for (var t2, r2 = Zg(e2), n2 = r2[0], i2 = r2[1], a2 = new Wg(function(e3, t3, r3) {
      return 3 * (t3 + r3) / 4 - r3;
    }(0, n2, i2)), o2 = 0, s2 = i2 > 0 ? n2 - 4 : n2, u2 = 0; u2 < s2; u2 += 4)
      t2 = _g[e2.charCodeAt(u2)] << 18 | _g[e2.charCodeAt(u2 + 1)] << 12 | _g[e2.charCodeAt(u2 + 2)] << 6 | _g[e2.charCodeAt(u2 + 3)], a2[o2++] = t2 >> 16 & 255, a2[o2++] = t2 >> 8 & 255, a2[o2++] = 255 & t2;
    2 === i2 && (t2 = _g[e2.charCodeAt(u2)] << 2 | _g[e2.charCodeAt(u2 + 1)] >> 4, a2[o2++] = 255 & t2);
    1 === i2 && (t2 = _g[e2.charCodeAt(u2)] << 10 | _g[e2.charCodeAt(u2 + 1)] << 4 | _g[e2.charCodeAt(u2 + 2)] >> 2, a2[o2++] = t2 >> 8 & 255, a2[o2++] = 255 & t2);
    return a2;
  }, Gg = function(e2) {
    for (var t2, r2 = e2.length, n2 = r2 % 3, i2 = [], a2 = 0, o2 = r2 - n2; a2 < o2; a2 += 16383)
      i2.push(Kg(e2, a2, a2 + 16383 > o2 ? o2 : a2 + 16383));
    1 === n2 ? (t2 = e2[r2 - 1], i2.push(Vg[t2 >> 2] + Vg[t2 << 4 & 63] + "==")) : 2 === n2 && (t2 = (e2[r2 - 2] << 8) + e2[r2 - 1], i2.push(Vg[t2 >> 10] + Vg[t2 >> 4 & 63] + Vg[t2 << 2 & 63] + "="));
    return i2.join("");
  }, Vg = [], _g = [], Wg = "undefined" != typeof Uint8Array ? Uint8Array : Array, Hg = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Yg = 0, Xg = Hg.length; Yg < Xg; ++Yg)
    Vg[Yg] = Hg[Yg], _g[Hg.charCodeAt(Yg)] = Yg;
  function Zg(e2) {
    var t2 = e2.length;
    if (t2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r2 = e2.indexOf("=");
    return -1 === r2 && (r2 = t2), [r2, r2 === t2 ? 0 : 4 - r2 % 4];
  }
  function Kg(e2, t2, r2) {
    for (var n2, i2, a2 = [], o2 = t2; o2 < r2; o2 += 3)
      n2 = (e2[o2] << 16 & 16711680) + (e2[o2 + 1] << 8 & 65280) + (255 & e2[o2 + 2]), a2.push(Vg[(i2 = n2) >> 18 & 63] + Vg[i2 >> 12 & 63] + Vg[i2 >> 6 & 63] + Vg[63 & i2]);
    return a2.join("");
  }
  _g["-".charCodeAt(0)] = 62, _g["_".charCodeAt(0)] = 63;
  var Jg = { byteLength: Ng, toByteArray: qg, fromByteArray: Gg }, Qg = function(e2) {
    return e2(Jg.toByteArray("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"));
  }, $g = t(function(e2, t2) {
    t2.init = function(e3) {
      t2.dictionary = Qg(e3);
    }, t2.offsetsByLength = new Uint32Array([0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536, 115968, 118528, 119872, 121280, 122016]), t2.sizeBitsByLength = new Uint8Array([0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7, 8, 7, 7, 6, 6, 5, 5]), t2.minDictionaryWordLength = 4, t2.maxDictionaryWordLength = 24;
  });
  $g.init, $g.dictionary, $g.offsetsByLength, $g.sizeBitsByLength, $g.minDictionaryWordLength, $g.maxDictionaryWordLength;
  function ev(e2, t2) {
    this.bits = e2, this.value = t2;
  }
  function tv(e2, t2) {
    for (var r2 = 1 << t2 - 1; e2 & r2; )
      r2 >>= 1;
    return (e2 & r2 - 1) + r2;
  }
  function rv(e2, t2, r2, n2, i2) {
    do {
      e2[t2 + (n2 -= r2)] = new ev(i2.bits, i2.value);
    } while (n2 > 0);
  }
  function nv(e2, t2, r2) {
    for (var n2 = 1 << t2 - r2; t2 < 15 && !((n2 -= e2[t2]) <= 0); )
      ++t2, n2 <<= 1;
    return t2 - r2;
  }
  var iv = { HuffmanCode: ev, BrotliBuildHuffmanTable: function(e2, t2, r2, n2, i2) {
    var a2, o2, s2, u2, l2, c2, f2, h2, d2, p2, y2 = t2, g2 = new Int32Array(16), v2 = new Int32Array(16);
    for (p2 = new Int32Array(i2), o2 = 0; o2 < i2; o2++)
      g2[n2[o2]]++;
    for (v2[1] = 0, a2 = 1; a2 < 15; a2++)
      v2[a2 + 1] = v2[a2] + g2[a2];
    for (o2 = 0; o2 < i2; o2++)
      0 !== n2[o2] && (p2[v2[n2[o2]]++] = o2);
    if (d2 = h2 = 1 << (f2 = r2), 1 === v2[15]) {
      for (s2 = 0; s2 < d2; ++s2)
        e2[t2 + s2] = new ev(0, 65535 & p2[0]);
      return d2;
    }
    for (s2 = 0, o2 = 0, a2 = 1, u2 = 2; a2 <= r2; ++a2, u2 <<= 1)
      for (; g2[a2] > 0; --g2[a2])
        rv(e2, t2 + s2, u2, h2, new ev(255 & a2, 65535 & p2[o2++])), s2 = tv(s2, a2);
    for (c2 = d2 - 1, l2 = -1, a2 = r2 + 1, u2 = 2; a2 <= 15; ++a2, u2 <<= 1)
      for (; g2[a2] > 0; --g2[a2])
        (s2 & c2) !== l2 && (t2 += h2, d2 += h2 = 1 << (f2 = nv(g2, a2, r2)), e2[y2 + (l2 = s2 & c2)] = new ev(f2 + r2 & 255, t2 - y2 - l2 & 65535)), rv(e2, t2 + (s2 >> r2), u2, h2, new ev(a2 - r2 & 255, 65535 & p2[o2++])), s2 = tv(s2, a2);
    return d2;
  } }, av = { lookup: new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 56, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), lookupOffsets: new Uint16Array([1024, 1536, 1280, 1536, 0, 256, 768, 512]) };
  function ov(e2, t2) {
    this.offset = e2, this.nbits = t2;
  }
  var sv = { kBlockLengthPrefixCode: [new ov(1, 2), new ov(5, 2), new ov(9, 2), new ov(13, 2), new ov(17, 3), new ov(25, 3), new ov(33, 3), new ov(41, 3), new ov(49, 4), new ov(65, 4), new ov(81, 4), new ov(97, 4), new ov(113, 5), new ov(145, 5), new ov(177, 5), new ov(209, 5), new ov(241, 6), new ov(305, 6), new ov(369, 7), new ov(497, 8), new ov(753, 9), new ov(1265, 10), new ov(2289, 11), new ov(4337, 12), new ov(8433, 13), new ov(16625, 24)], kInsertLengthPrefixCode: [new ov(0, 0), new ov(1, 0), new ov(2, 0), new ov(3, 0), new ov(4, 0), new ov(5, 0), new ov(6, 1), new ov(8, 1), new ov(10, 2), new ov(14, 2), new ov(18, 3), new ov(26, 3), new ov(34, 4), new ov(50, 4), new ov(66, 5), new ov(98, 5), new ov(130, 6), new ov(194, 7), new ov(322, 8), new ov(578, 9), new ov(1090, 10), new ov(2114, 12), new ov(6210, 14), new ov(22594, 24)], kCopyLengthPrefixCode: [new ov(2, 0), new ov(3, 0), new ov(4, 0), new ov(5, 0), new ov(6, 0), new ov(7, 0), new ov(8, 0), new ov(9, 0), new ov(10, 1), new ov(12, 1), new ov(14, 2), new ov(18, 2), new ov(22, 3), new ov(30, 3), new ov(38, 4), new ov(54, 4), new ov(70, 5), new ov(102, 5), new ov(134, 6), new ov(198, 7), new ov(326, 8), new ov(582, 9), new ov(1094, 10), new ov(2118, 24)], kInsertRangeLut: [0, 0, 8, 8, 0, 16, 8, 16, 16], kCopyRangeLut: [0, 8, 0, 8, 16, 0, 16, 8, 16] };
  function uv(e2, t2, r2) {
    this.prefix = new Uint8Array(e2.length), this.transform = t2, this.suffix = new Uint8Array(r2.length);
    for (var n2 = 0; n2 < e2.length; n2++)
      this.prefix[n2] = e2.charCodeAt(n2);
    for (n2 = 0; n2 < r2.length; n2++)
      this.suffix[n2] = r2.charCodeAt(n2);
  }
  var lv = [new uv("", 0, ""), new uv("", 0, " "), new uv(" ", 0, " "), new uv("", 12, ""), new uv("", 10, " "), new uv("", 0, " the "), new uv(" ", 0, ""), new uv("s ", 0, " "), new uv("", 0, " of "), new uv("", 10, ""), new uv("", 0, " and "), new uv("", 13, ""), new uv("", 1, ""), new uv(", ", 0, " "), new uv("", 0, ", "), new uv(" ", 10, " "), new uv("", 0, " in "), new uv("", 0, " to "), new uv("e ", 0, " "), new uv("", 0, '"'), new uv("", 0, "."), new uv("", 0, '">'), new uv("", 0, "\n"), new uv("", 3, ""), new uv("", 0, "]"), new uv("", 0, " for "), new uv("", 14, ""), new uv("", 2, ""), new uv("", 0, " a "), new uv("", 0, " that "), new uv(" ", 10, ""), new uv("", 0, ". "), new uv(".", 0, ""), new uv(" ", 0, ", "), new uv("", 15, ""), new uv("", 0, " with "), new uv("", 0, "'"), new uv("", 0, " from "), new uv("", 0, " by "), new uv("", 16, ""), new uv("", 17, ""), new uv(" the ", 0, ""), new uv("", 4, ""), new uv("", 0, ". The "), new uv("", 11, ""), new uv("", 0, " on "), new uv("", 0, " as "), new uv("", 0, " is "), new uv("", 7, ""), new uv("", 1, "ing "), new uv("", 0, "\n	"), new uv("", 0, ":"), new uv(" ", 0, ". "), new uv("", 0, "ed "), new uv("", 20, ""), new uv("", 18, ""), new uv("", 6, ""), new uv("", 0, "("), new uv("", 10, ", "), new uv("", 8, ""), new uv("", 0, " at "), new uv("", 0, "ly "), new uv(" the ", 0, " of "), new uv("", 5, ""), new uv("", 9, ""), new uv(" ", 10, ", "), new uv("", 10, '"'), new uv(".", 0, "("), new uv("", 11, " "), new uv("", 10, '">'), new uv("", 0, '="'), new uv(" ", 0, "."), new uv(".com/", 0, ""), new uv(" the ", 0, " of the "), new uv("", 10, "'"), new uv("", 0, ". This "), new uv("", 0, ","), new uv(".", 0, " "), new uv("", 10, "("), new uv("", 10, "."), new uv("", 0, " not "), new uv(" ", 0, '="'), new uv("", 0, "er "), new uv(" ", 11, " "), new uv("", 0, "al "), new uv(" ", 11, ""), new uv("", 0, "='"), new uv("", 11, '"'), new uv("", 10, ". "), new uv(" ", 0, "("), new uv("", 0, "ful "), new uv(" ", 10, ". "), new uv("", 0, "ive "), new uv("", 0, "less "), new uv("", 11, "'"), new uv("", 0, "est "), new uv(" ", 10, "."), new uv("", 11, '">'), new uv(" ", 0, "='"), new uv("", 10, ","), new uv("", 0, "ize "), new uv("", 11, "."), new uv("", 0, ""), new uv(" ", 0, ","), new uv("", 10, '="'), new uv("", 11, '="'), new uv("", 0, "ous "), new uv("", 11, ", "), new uv("", 10, "='"), new uv(" ", 10, ","), new uv(" ", 11, '="'), new uv(" ", 11, ", "), new uv("", 11, ","), new uv("", 11, "("), new uv("", 11, ". "), new uv(" ", 11, "."), new uv("", 11, "='"), new uv(" ", 11, ". "), new uv(" ", 10, '="'), new uv(" ", 11, "='"), new uv(" ", 10, "='")];
  function cv(e2, t2) {
    return e2[t2] < 192 ? (e2[t2] >= 97 && e2[t2] <= 122 && (e2[t2] ^= 32), 1) : e2[t2] < 224 ? (e2[t2 + 1] ^= 32, 2) : (e2[t2 + 2] ^= 5, 3);
  }
  var fv = lv.length, hv = function(e2, t2, r2, n2, i2) {
    var a2, o2 = lv[i2].prefix, s2 = lv[i2].suffix, u2 = lv[i2].transform, l2 = u2 < 12 ? 0 : u2 - 11, c2 = 0, f2 = t2;
    l2 > n2 && (l2 = n2);
    for (var h2 = 0; h2 < o2.length; )
      e2[t2++] = o2[h2++];
    for (r2 += l2, n2 -= l2, u2 <= 9 && (n2 -= u2), c2 = 0; c2 < n2; c2++)
      e2[t2++] = $g.dictionary[r2 + c2];
    if (a2 = t2 - n2, 10 === u2)
      cv(e2, a2);
    else if (11 === u2)
      for (; n2 > 0; ) {
        var d2 = cv(e2, a2);
        a2 += d2, n2 -= d2;
      }
    for (var p2 = 0; p2 < s2.length; )
      e2[t2++] = s2[p2++];
    return t2 - f2;
  }, dv = jg.BrotliInput, pv = jg.BrotliOutput, yv = iv.HuffmanCode, gv = iv.BrotliBuildHuffmanTable, vv = new Uint8Array([1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15]), bv = new Uint8Array([3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2]), mv = new Int8Array([0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3]), wv = new Uint16Array([256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758, 790, 822, 854, 886, 920, 952, 984, 1016, 1048, 1080]);
  function Sv(e2) {
    var t2;
    return 0 === e2.readBits(1) ? 16 : (t2 = e2.readBits(3)) > 0 ? 17 + t2 : (t2 = e2.readBits(3)) > 0 ? 8 + t2 : 17;
  }
  function xv(e2) {
    if (e2.readBits(1)) {
      var t2 = e2.readBits(3);
      return 0 === t2 ? 1 : e2.readBits(t2) + (1 << t2);
    }
    return 0;
  }
  function Av() {
    this.meta_block_length = 0, this.input_end = 0, this.is_uncompressed = 0, this.is_metadata = false;
  }
  function kv(e2) {
    var t2, r2, n2, i2 = new Av();
    if (i2.input_end = e2.readBits(1), i2.input_end && e2.readBits(1))
      return i2;
    if (7 === (t2 = e2.readBits(2) + 4)) {
      if (i2.is_metadata = true, 0 !== e2.readBits(1))
        throw new Error("Invalid reserved bit");
      if (0 === (r2 = e2.readBits(2)))
        return i2;
      for (n2 = 0; n2 < r2; n2++) {
        var a2 = e2.readBits(8);
        if (n2 + 1 === r2 && r2 > 1 && 0 === a2)
          throw new Error("Invalid size byte");
        i2.meta_block_length |= a2 << 8 * n2;
      }
    } else
      for (n2 = 0; n2 < t2; ++n2) {
        var o2 = e2.readBits(4);
        if (n2 + 1 === t2 && t2 > 4 && 0 === o2)
          throw new Error("Invalid size nibble");
        i2.meta_block_length |= o2 << 4 * n2;
      }
    return ++i2.meta_block_length, i2.input_end || i2.is_metadata || (i2.is_uncompressed = e2.readBits(1)), i2;
  }
  function Cv(e2, t2, r2) {
    var n2;
    return r2.fillBitWindow(), (n2 = e2[t2 += r2.val_ >>> r2.bit_pos_ & 255].bits - 8) > 0 && (r2.bit_pos_ += 8, t2 += e2[t2].value, t2 += r2.val_ >>> r2.bit_pos_ & (1 << n2) - 1), r2.bit_pos_ += e2[t2].bits, e2[t2].value;
  }
  function Pv(e2, t2, r2, n2) {
    var i2, a2, o2 = new Uint8Array(e2);
    if (n2.readMoreInput(), 1 === (a2 = n2.readBits(2))) {
      for (var s2 = e2 - 1, u2 = 0, l2 = new Int32Array(4), c2 = n2.readBits(2) + 1; s2; )
        s2 >>= 1, ++u2;
      for (f2 = 0; f2 < c2; ++f2)
        l2[f2] = n2.readBits(u2) % e2, o2[l2[f2]] = 2;
      switch (o2[l2[0]] = 1, c2) {
        case 1:
          break;
        case 3:
          if (l2[0] === l2[1] || l2[0] === l2[2] || l2[1] === l2[2])
            throw new Error("[ReadHuffmanCode] invalid symbols");
          break;
        case 2:
          if (l2[0] === l2[1])
            throw new Error("[ReadHuffmanCode] invalid symbols");
          o2[l2[1]] = 1;
          break;
        case 4:
          if (l2[0] === l2[1] || l2[0] === l2[2] || l2[0] === l2[3] || l2[1] === l2[2] || l2[1] === l2[3] || l2[2] === l2[3])
            throw new Error("[ReadHuffmanCode] invalid symbols");
          n2.readBits(1) ? (o2[l2[2]] = 3, o2[l2[3]] = 3) : o2[l2[0]] = 2;
      }
    } else {
      var f2, h2 = new Uint8Array(18), d2 = 32, p2 = 0, y2 = [new yv(2, 0), new yv(2, 4), new yv(2, 3), new yv(3, 2), new yv(2, 0), new yv(2, 4), new yv(2, 3), new yv(4, 1), new yv(2, 0), new yv(2, 4), new yv(2, 3), new yv(3, 2), new yv(2, 0), new yv(2, 4), new yv(2, 3), new yv(4, 5)];
      for (f2 = a2; f2 < 18 && d2 > 0; ++f2) {
        var g2, v2 = vv[f2], b2 = 0;
        n2.fillBitWindow(), b2 += n2.val_ >>> n2.bit_pos_ & 15, n2.bit_pos_ += y2[b2].bits, g2 = y2[b2].value, h2[v2] = g2, 0 !== g2 && (d2 -= 32 >> g2, ++p2);
      }
      if (1 !== p2 && 0 !== d2)
        throw new Error("[ReadHuffmanCode] invalid num_codes or space");
      !function(e3, t3, r3, n3) {
        for (var i3 = 0, a3 = 8, o3 = 0, s3 = 0, u3 = 32768, l3 = [], c3 = 0; c3 < 32; c3++)
          l3.push(new yv(0, 0));
        for (gv(l3, 0, 5, e3, 18); i3 < t3 && u3 > 0; ) {
          var f3, h3 = 0;
          if (n3.readMoreInput(), n3.fillBitWindow(), h3 += n3.val_ >>> n3.bit_pos_ & 31, n3.bit_pos_ += l3[h3].bits, (f3 = 255 & l3[h3].value) < 16)
            o3 = 0, r3[i3++] = f3, 0 !== f3 && (a3 = f3, u3 -= 32768 >> f3);
          else {
            var d3, p3, y3 = f3 - 14, g3 = 0;
            if (16 === f3 && (g3 = a3), s3 !== g3 && (o3 = 0, s3 = g3), d3 = o3, o3 > 0 && (o3 -= 2, o3 <<= y3), i3 + (p3 = (o3 += n3.readBits(y3) + 3) - d3) > t3)
              throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
            for (var v3 = 0; v3 < p3; v3++)
              r3[i3 + v3] = s3;
            i3 += p3, 0 !== s3 && (u3 -= p3 << 15 - s3);
          }
        }
        if (0 !== u3)
          throw new Error("[ReadHuffmanCodeLengths] space = " + u3);
        for (; i3 < t3; i3++)
          r3[i3] = 0;
      }(h2, e2, o2, n2);
    }
    if (0 === (i2 = gv(t2, r2, 8, o2, e2)))
      throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
    return i2;
  }
  function Iv(e2, t2, r2) {
    var n2, i2;
    return n2 = Cv(e2, t2, r2), i2 = sv.kBlockLengthPrefixCode[n2].nbits, sv.kBlockLengthPrefixCode[n2].offset + r2.readBits(i2);
  }
  function Ov(e2, t2, r2) {
    var n2;
    return e2 < 16 ? (r2 += bv[e2], n2 = t2[r2 &= 3] + mv[e2]) : n2 = e2 - 16 + 1, n2;
  }
  function Ev(e2, t2) {
    for (var r2 = e2[t2], n2 = t2; n2; --n2)
      e2[n2] = e2[n2 - 1];
    e2[0] = r2;
  }
  function Bv(e2, t2) {
    this.alphabet_size = e2, this.num_htrees = t2, this.codes = new Array(t2 + t2 * wv[e2 + 31 >>> 5]), this.htrees = new Uint32Array(t2);
  }
  function Tv(e2, t2) {
    var r2, n2, i2 = { num_htrees: null, context_map: null }, a2 = 0;
    t2.readMoreInput();
    var o2 = i2.num_htrees = xv(t2) + 1, s2 = i2.context_map = new Uint8Array(e2);
    if (o2 <= 1)
      return i2;
    for (t2.readBits(1) && (a2 = t2.readBits(4) + 1), r2 = [], n2 = 0; n2 < 1080; n2++)
      r2[n2] = new yv(0, 0);
    for (Pv(o2 + a2, r2, 0, t2), n2 = 0; n2 < e2; ) {
      var u2;
      if (t2.readMoreInput(), 0 === (u2 = Cv(r2, 0, t2)))
        s2[n2] = 0, ++n2;
      else if (u2 <= a2)
        for (var l2 = 1 + (1 << u2) + t2.readBits(u2); --l2; ) {
          if (n2 >= e2)
            throw new Error("[DecodeContextMap] i >= context_map_size");
          s2[n2] = 0, ++n2;
        }
      else
        s2[n2] = u2 - a2, ++n2;
    }
    return t2.readBits(1) && function(e3, t3) {
      var r3, n3 = new Uint8Array(256);
      for (r3 = 0; r3 < 256; ++r3)
        n3[r3] = r3;
      for (r3 = 0; r3 < t3; ++r3) {
        var i3 = e3[r3];
        e3[r3] = n3[i3], i3 && Ev(n3, i3);
      }
    }(s2, e2), i2;
  }
  function Lv(e2, t2, r2, n2, i2, a2, o2) {
    var s2, u2 = 2 * r2, l2 = r2, c2 = Cv(t2, 1080 * r2, o2);
    (s2 = 0 === c2 ? i2[u2 + (1 & a2[l2])] : 1 === c2 ? i2[u2 + (a2[l2] - 1 & 1)] + 1 : c2 - 2) >= e2 && (s2 -= e2), n2[r2] = s2, i2[u2 + (1 & a2[l2])] = s2, ++a2[l2];
  }
  function zv(e2, t2, r2, n2, i2, a2) {
    var o2, s2 = i2 + 1, u2 = r2 & i2, l2 = a2.pos_ & Rg.IBUF_MASK;
    if (t2 < 8 || a2.bit_pos_ + (t2 << 3) < a2.bit_end_pos_)
      for (; t2-- > 0; )
        a2.readMoreInput(), n2[u2++] = a2.readBits(8), u2 === s2 && (e2.write(n2, s2), u2 = 0);
    else {
      if (a2.bit_end_pos_ < 32)
        throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
      for (; a2.bit_pos_ < 32; )
        n2[u2] = a2.val_ >>> a2.bit_pos_, a2.bit_pos_ += 8, ++u2, --t2;
      if (l2 + (o2 = a2.bit_end_pos_ - a2.bit_pos_ >> 3) > Rg.IBUF_MASK) {
        for (var c2 = Rg.IBUF_MASK + 1 - l2, f2 = 0; f2 < c2; f2++)
          n2[u2 + f2] = a2.buf_[l2 + f2];
        o2 -= c2, u2 += c2, t2 -= c2, l2 = 0;
      }
      for (f2 = 0; f2 < o2; f2++)
        n2[u2 + f2] = a2.buf_[l2 + f2];
      if (t2 -= o2, (u2 += o2) >= s2) {
        e2.write(n2, s2), u2 -= s2;
        for (f2 = 0; f2 < u2; f2++)
          n2[f2] = n2[s2 + f2];
      }
      for (; u2 + t2 >= s2; ) {
        if (o2 = s2 - u2, a2.input_.read(n2, u2, o2) < o2)
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        e2.write(n2, s2), t2 -= o2, u2 = 0;
      }
      if (a2.input_.read(n2, u2, t2) < t2)
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      a2.reset();
    }
  }
  function Uv(e2) {
    var t2 = e2.bit_pos_ + 7 & -8;
    return 0 == e2.readBits(t2 - e2.bit_pos_);
  }
  function Dv(e2) {
    var t2 = new dv(e2), r2 = new Rg(t2);
    return Sv(r2), kv(r2).meta_block_length;
  }
  Bv.prototype.decode = function(e2) {
    var t2, r2 = 0;
    for (t2 = 0; t2 < this.num_htrees; ++t2)
      this.htrees[t2] = r2, r2 += Pv(this.alphabet_size, this.codes, r2, e2);
  };
  var jv = Dv;
  function Mv(e2, t2) {
    var r2 = new dv(e2);
    null == t2 && (t2 = Dv(e2));
    var n2 = new Uint8Array(t2), i2 = new pv(n2);
    return Rv(r2, i2), i2.pos < i2.buffer.length && (i2.buffer = i2.buffer.subarray(0, i2.pos)), i2.buffer;
  }
  var Fv = Mv;
  function Rv(e2, t2) {
    var r2, n2, i2, a2, o2, s2, u2, l2, c2, f2, h2 = 0, d2 = 0, p2 = 0, y2 = [16, 15, 11, 4], g2 = 0, v2 = 0, b2 = 0, m2 = [new Bv(0, 0), new Bv(0, 0), new Bv(0, 0)], w2 = 128 + Rg.READ_SIZE;
    i2 = (1 << (n2 = Sv(f2 = new Rg(e2)))) - 16, o2 = (a2 = 1 << n2) - 1, s2 = new Uint8Array(a2 + w2 + $g.maxDictionaryWordLength), u2 = a2, l2 = [], c2 = [];
    for (var S2 = 0; S2 < 3240; S2++)
      l2[S2] = new yv(0, 0), c2[S2] = new yv(0, 0);
    for (; !d2; ) {
      var x2, A2, k2, C2, P2, I2, O2, E2, B2, T2, L2, z2 = 0, U2 = [1 << 28, 1 << 28, 1 << 28], D2 = [0], j2 = [1, 1, 1], M2 = [0, 1, 0, 1, 0, 1], F2 = [0], R2 = null, N2 = null, q2 = 0, G2 = null, V2 = 0, _2 = 0, W2 = 0;
      for (r2 = 0; r2 < 3; ++r2)
        m2[r2].codes = null, m2[r2].htrees = null;
      f2.readMoreInput();
      var H2 = kv(f2);
      if (h2 + (z2 = H2.meta_block_length) > t2.buffer.length) {
        var Y2 = new Uint8Array(h2 + z2);
        Y2.set(t2.buffer), t2.buffer = Y2;
      }
      if (d2 = H2.input_end, x2 = H2.is_uncompressed, H2.is_metadata)
        for (Uv(f2); z2 > 0; --z2)
          f2.readMoreInput(), f2.readBits(8);
      else if (0 !== z2)
        if (x2)
          f2.bit_pos_ = f2.bit_pos_ + 7 & -8, zv(t2, z2, h2, s2, o2, f2), h2 += z2;
        else {
          for (r2 = 0; r2 < 3; ++r2)
            j2[r2] = xv(f2) + 1, j2[r2] >= 2 && (Pv(j2[r2] + 2, l2, 1080 * r2, f2), Pv(26, c2, 1080 * r2, f2), U2[r2] = Iv(c2, 1080 * r2, f2), F2[r2] = 1);
          for (f2.readMoreInput(), C2 = (1 << (A2 = f2.readBits(2))) - 1, P2 = (k2 = 16 + (f2.readBits(4) << A2)) + (48 << A2), R2 = new Uint8Array(j2[0]), r2 = 0; r2 < j2[0]; ++r2)
            f2.readMoreInput(), R2[r2] = f2.readBits(2) << 1;
          var X2 = Tv(j2[0] << 6, f2);
          O2 = X2.num_htrees, I2 = X2.context_map;
          var Z2 = Tv(j2[2] << 2, f2);
          for (B2 = Z2.num_htrees, E2 = Z2.context_map, m2[0] = new Bv(256, O2), m2[1] = new Bv(704, j2[1]), m2[2] = new Bv(P2, B2), r2 = 0; r2 < 3; ++r2)
            m2[r2].decode(f2);
          for (N2 = 0, G2 = 0, T2 = R2[D2[0]], _2 = av.lookupOffsets[T2], W2 = av.lookupOffsets[T2 + 1], L2 = m2[1].htrees[0]; z2 > 0; ) {
            var K2, J2, Q2, $2, ee2, te2, re2, ne2, ie2, ae2, oe2, se2;
            for (f2.readMoreInput(), 0 === U2[1] && (Lv(j2[1], l2, 1, D2, M2, F2, f2), U2[1] = Iv(c2, 1080, f2), L2 = m2[1].htrees[D2[1]]), --U2[1], (J2 = (K2 = Cv(m2[1].codes, L2, f2)) >> 6) >= 2 ? (J2 -= 2, re2 = -1) : re2 = 0, Q2 = sv.kInsertRangeLut[J2] + (K2 >> 3 & 7), $2 = sv.kCopyRangeLut[J2] + (7 & K2), ee2 = sv.kInsertLengthPrefixCode[Q2].offset + f2.readBits(sv.kInsertLengthPrefixCode[Q2].nbits), te2 = sv.kCopyLengthPrefixCode[$2].offset + f2.readBits(sv.kCopyLengthPrefixCode[$2].nbits), v2 = s2[h2 - 1 & o2], b2 = s2[h2 - 2 & o2], ie2 = 0; ie2 < ee2; ++ie2)
              f2.readMoreInput(), 0 === U2[0] && (Lv(j2[0], l2, 0, D2, M2, F2, f2), U2[0] = Iv(c2, 0, f2), N2 = D2[0] << 6, T2 = R2[D2[0]], _2 = av.lookupOffsets[T2], W2 = av.lookupOffsets[T2 + 1]), q2 = I2[N2 + (av.lookup[_2 + v2] | av.lookup[W2 + b2])], --U2[0], b2 = v2, v2 = Cv(m2[0].codes, m2[0].htrees[q2], f2), s2[h2 & o2] = v2, (h2 & o2) === o2 && t2.write(s2, a2), ++h2;
            if ((z2 -= ee2) <= 0)
              break;
            if (re2 < 0) {
              if (f2.readMoreInput(), 0 === U2[2] && (Lv(j2[2], l2, 2, D2, M2, F2, f2), U2[2] = Iv(c2, 2160, f2), G2 = D2[2] << 2), --U2[2], V2 = E2[G2 + (255 & (te2 > 4 ? 3 : te2 - 2))], (re2 = Cv(m2[2].codes, m2[2].htrees[V2], f2)) >= k2)
                se2 = (re2 -= k2) & C2, re2 = k2 + ((ue2 = (2 + (1 & (re2 >>= A2)) << (oe2 = 1 + (re2 >> 1))) - 4) + f2.readBits(oe2) << A2) + se2;
            }
            if ((ne2 = Ov(re2, y2, g2)) < 0)
              throw new Error("[BrotliDecompress] invalid distance");
            if (ae2 = h2 & o2, ne2 > (p2 = h2 < i2 && p2 !== i2 ? h2 : i2)) {
              if (!(te2 >= $g.minDictionaryWordLength && te2 <= $g.maxDictionaryWordLength))
                throw new Error("Invalid backward reference. pos: " + h2 + " distance: " + ne2 + " len: " + te2 + " bytes left: " + z2);
              var ue2 = $g.offsetsByLength[te2], le2 = ne2 - p2 - 1, ce2 = $g.sizeBitsByLength[te2], fe2 = le2 >> ce2;
              if (ue2 += (le2 & (1 << ce2) - 1) * te2, !(fe2 < fv))
                throw new Error("Invalid backward reference. pos: " + h2 + " distance: " + ne2 + " len: " + te2 + " bytes left: " + z2);
              var he2 = hv(s2, ae2, ue2, te2, fe2);
              if (h2 += he2, z2 -= he2, (ae2 += he2) >= u2) {
                t2.write(s2, a2);
                for (var de2 = 0; de2 < ae2 - u2; de2++)
                  s2[de2] = s2[u2 + de2];
              }
            } else {
              if (re2 > 0 && (y2[3 & g2] = ne2, ++g2), te2 > z2)
                throw new Error("Invalid backward reference. pos: " + h2 + " distance: " + ne2 + " len: " + te2 + " bytes left: " + z2);
              for (ie2 = 0; ie2 < te2; ++ie2)
                s2[h2 & o2] = s2[h2 - ne2 & o2], (h2 & o2) === o2 && t2.write(s2, a2), ++h2, --z2;
            }
            v2 = s2[h2 - 1 & o2], b2 = s2[h2 - 2 & o2];
          }
          h2 &= 1073741823;
        }
    }
    t2.write(s2, h2 & o2);
  }
  var Nv = Rv;
  $g.init(Mv);
  var qv = { BrotliDecompressedSize: jv, BrotliDecompressBuffer: Fv, BrotliDecompress: Nv }.BrotliDecompressBuffer;
  var Gv = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
    var i2 = n2.prototype;
    return i2._decode = function() {
      return this._font._transformedGlyphs[this.id];
    }, i2._getCBox = function() {
      return this.path.bbox;
    }, n2;
  }(Uy), Vv = { decode: function(e2) {
    for (var t2 = 0, r2 = [0, 1, 2, 3, 4], n2 = 0; n2 < r2.length; n2++) {
      var i2 = e2.readUInt8();
      if (3758096384 & t2)
        throw new Error("Overflow");
      if (t2 = t2 << 7 | 127 & i2, 0 == (128 & i2))
        return t2;
    }
    throw new Error("Bad base 128 number");
  } }, _v = ["cmap", "head", "hhea", "hmtx", "maxp", "name", "OS/2", "post", "cvt ", "fpgm", "glyf", "loca", "prep", "CFF ", "VORG", "EBDT", "EBLC", "gasp", "hdmx", "kern", "LTSH", "PCLT", "VDMX", "vhea", "vmtx", "BASE", "GDEF", "GPOS", "GSUB", "EBSC", "JSTF", "MATH", "CBDT", "CBLC", "COLR", "CPAL", "SVG ", "sbix", "acnt", "avar", "bdat", "bloc", "bsln", "cvar", "fdsc", "feat", "fmtx", "fvar", "gvar", "hsty", "just", "lcar", "mort", "morx", "opbd", "prop", "trak", "Zapf", "Silf", "Glat", "Gloc", "Feat", "Sill"], Wv = new wn.Struct({ flags: wn.uint8, customTag: new wn.Optional(new wn.String(4), function(e2) {
    return 63 == (63 & e2.flags);
  }), tag: function(e2) {
    return e2.customTag || _v[63 & e2.flags];
  }, length: Vv, transformVersion: function(e2) {
    return e2.flags >>> 6 & 3;
  }, transformed: function(e2) {
    return "glyf" === e2.tag || "loca" === e2.tag ? 0 === e2.transformVersion : 0 !== e2.transformVersion;
  }, transformLength: new wn.Optional(Vv, function(e2) {
    return e2.transformed;
  }) }), Hv = new wn.Struct({ tag: new wn.String(4), flavor: wn.uint32, length: wn.uint32, numTables: wn.uint16, reserved: new wn.Reserved(wn.uint16), totalSfntSize: wn.uint32, totalCompressedSize: wn.uint32, majorVersion: wn.uint16, minorVersion: wn.uint16, metaOffset: wn.uint32, metaLength: wn.uint32, metaOrigLength: wn.uint32, privOffset: wn.uint32, privLength: wn.uint32, tables: new wn.Array(Wv, "numTables") });
  Hv.process = function() {
    for (var e2 = {}, t2 = 0; t2 < this.tables.length; t2++) {
      var r2 = this.tables[t2];
      e2[r2.tag] = r2;
    }
    return this.tables = e2;
  };
  var Yv = function(e2) {
    var t2, r2;
    function n2() {
      return e2.apply(this, arguments) || this;
    }
    r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.probe = function(e3) {
      return "wOF2" === e3.toString("ascii", 0, 4);
    };
    var i2 = n2.prototype;
    return i2._decodeDirectory = function() {
      this.directory = Hv.decode(this.stream), this._dataPos = this.stream.pos;
    }, i2._decompress = function() {
      if (!this._decompressed) {
        this.stream.pos = this._dataPos;
        var e3 = this.stream.readBuffer(this.directory.totalCompressedSize), t3 = 0;
        for (var r3 in this.directory.tables) {
          var n3 = this.directory.tables[r3];
          n3.offset = t3, t3 += null != n3.transformLength ? n3.transformLength : n3.length;
        }
        var i3 = qv(e3, t3);
        if (!i3)
          throw new Error("Error decoding compressed data in WOFF2");
        this.stream = new wn.DecodeStream(new b(i3)), this._decompressed = true;
      }
    }, i2._decodeTable = function(t3) {
      return this._decompress(), e2.prototype._decodeTable.call(this, t3);
    }, i2._getBaseGlyph = function(t3, r3) {
      if (void 0 === r3 && (r3 = []), !this._glyphs[t3])
        return this.directory.tables.glyf && this.directory.tables.glyf.transformed ? (this._transformedGlyphs || this._transformGlyfTable(), this._glyphs[t3] = new Gv(t3, r3, this)) : e2.prototype._getBaseGlyph.call(this, t3, r3);
    }, i2._transformGlyfTable = function() {
      this._decompress(), this.stream.pos = this.directory.tables.glyf.offset;
      for (var e3 = Zv.decode(this.stream), t3 = [], r3 = 0; r3 < e3.numGlyphs; r3++) {
        var n3 = {}, i3 = e3.nContours.readInt16BE();
        if (n3.numberOfContours = i3, i3 > 0) {
          for (var a2 = [], o2 = 0, s2 = 0; s2 < i3; s2++) {
            o2 += Kv(e3.nPoints), a2.push(o2);
          }
          n3.points = Qv(e3.flags, e3.glyphs, o2);
          for (var u2 = 0; u2 < i3; u2++)
            n3.points[a2[u2] - 1].endContour = true;
          Kv(e3.glyphs);
        } else if (i3 < 0) {
          if (Uy.prototype._decodeComposite.call({ _font: this }, n3, e3.composites))
            Kv(e3.glyphs);
        }
        t3.push(n3);
      }
      this._transformedGlyphs = t3;
    }, n2;
  }(og), Xv = function() {
    function e2(e3) {
      this.length = e3, this._buf = new wn.Buffer(e3);
    }
    return e2.prototype.decode = function(e3, t2) {
      return new wn.DecodeStream(this._buf.decode(e3, t2));
    }, e2;
  }(), Zv = new wn.Struct({ version: wn.uint32, numGlyphs: wn.uint16, indexFormat: wn.uint16, nContourStreamSize: wn.uint32, nPointsStreamSize: wn.uint32, flagStreamSize: wn.uint32, glyphStreamSize: wn.uint32, compositeStreamSize: wn.uint32, bboxStreamSize: wn.uint32, instructionStreamSize: wn.uint32, nContours: new Xv("nContourStreamSize"), nPoints: new Xv("nPointsStreamSize"), flags: new Xv("flagStreamSize"), glyphs: new Xv("glyphStreamSize"), composites: new Xv("compositeStreamSize"), bboxes: new Xv("bboxStreamSize"), instructions: new Xv("instructionStreamSize") });
  function Kv(e2) {
    var t2 = e2.readUInt8();
    return 253 === t2 ? e2.readUInt16BE() : 255 === t2 ? e2.readUInt8() + 253 : 254 === t2 ? e2.readUInt8() + 506 : t2;
  }
  function Jv(e2, t2) {
    return 1 & e2 ? t2 : -t2;
  }
  function Qv(e2, t2, r2) {
    for (var n2, i2 = n2 = 0, a2 = [], o2 = 0; o2 < r2; o2++) {
      var s2 = 0, u2 = 0, l2 = e2.readUInt8(), c2 = !(l2 >> 7);
      if ((l2 &= 127) < 10)
        s2 = 0, u2 = Jv(l2, ((14 & l2) << 7) + t2.readUInt8());
      else if (l2 < 20)
        s2 = Jv(l2, ((l2 - 10 & 14) << 7) + t2.readUInt8()), u2 = 0;
      else if (l2 < 84) {
        s2 = Jv(l2, 1 + (48 & (f2 = l2 - 20)) + ((h2 = t2.readUInt8()) >> 4)), u2 = Jv(l2 >> 1, 1 + ((12 & f2) << 2) + (15 & h2));
      } else if (l2 < 120) {
        var f2;
        s2 = Jv(l2, 1 + ((f2 = l2 - 84) / 12 << 8) + t2.readUInt8()), u2 = Jv(l2 >> 1, 1 + (f2 % 12 >> 2 << 8) + t2.readUInt8());
      } else if (l2 < 124) {
        var h2 = t2.readUInt8(), d2 = t2.readUInt8();
        s2 = Jv(l2, (h2 << 4) + (d2 >> 4)), u2 = Jv(l2 >> 1, ((15 & d2) << 8) + t2.readUInt8());
      } else
        s2 = Jv(l2, t2.readUInt16BE()), u2 = Jv(l2 >> 1, t2.readUInt16BE());
      i2 += s2, n2 += u2, a2.push(new Ly(c2, false, i2, n2));
    }
    return a2;
  }
  function $v(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return eb(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return eb(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function eb(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  function tb(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  var rb = new wn.VersionedStruct(wn.uint32, { 65536: { numFonts: wn.uint32, offsets: new wn.Array(wn.uint32, "numFonts") }, 131072: { numFonts: wn.uint32, offsets: new wn.Array(wn.uint32, "numFonts"), dsigTag: wn.uint32, dsigLength: wn.uint32, dsigOffset: wn.uint32 } }), nb = function() {
    function e2(e3) {
      if (this.stream = e3, "ttcf" !== e3.readString(4))
        throw new Error("Not a TrueType collection");
      this.header = rb.decode(e3);
    }
    var t2, r2;
    return e2.probe = function(e3) {
      return "ttcf" === e3.toString("ascii", 0, 4);
    }, e2.prototype.getFont = function(e3) {
      for (var t3, r3 = $v(this.header.offsets); !(t3 = r3()).done; ) {
        var n2 = t3.value, i2 = new wn.DecodeStream(this.stream.buffer);
        i2.pos = n2;
        var a2 = new og(i2);
        if (a2.postscriptName === e3)
          return a2;
      }
      return null;
    }, t2 = e2, (r2 = [{ key: "fonts", get: function() {
      for (var e3, t3 = [], r3 = $v(this.header.offsets); !(e3 = r3()).done; ) {
        var n2 = e3.value, i2 = new wn.DecodeStream(this.stream.buffer);
        i2.pos = n2, t3.push(new og(i2));
      }
      return t3;
    } }]) && tb(t2.prototype, r2), e2;
  }();
  function ib(e2) {
    var t2 = 0;
    if ("undefined" == typeof Symbol || null == e2[Symbol.iterator]) {
      if (Array.isArray(e2) || (e2 = function(e3, t3) {
        if (!e3)
          return;
        if ("string" == typeof e3)
          return ab(e3, t3);
        var r2 = Object.prototype.toString.call(e3).slice(8, -1);
        "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
        if ("Map" === r2 || "Set" === r2)
          return Array.from(e3);
        if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
          return ab(e3, t3);
      }(e2)))
        return function() {
          return t2 >= e2.length ? { done: true } : { done: false, value: e2[t2++] };
        };
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (t2 = e2[Symbol.iterator]()).next.bind(t2);
  }
  function ab(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
      n2[r2] = e2[r2];
    return n2;
  }
  function ob(e2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var n2 = t2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
  }
  var sb = new wn.String(wn.uint8), ub = (new wn.Struct({ len: wn.uint32, buf: new wn.Buffer("len") }), new wn.Struct({ id: wn.uint16, nameOffset: wn.int16, attr: wn.uint8, dataOffset: wn.uint24, handle: wn.uint32 })), lb = new wn.Struct({ name: new wn.String(4), maxTypeIndex: wn.uint16, refList: new wn.Pointer(wn.uint16, new wn.Array(ub, function(e2) {
    return e2.maxTypeIndex + 1;
  }), { type: "parent" }) }), cb = new wn.Struct({ length: wn.uint16, types: new wn.Array(lb, function(e2) {
    return e2.length + 1;
  }) }), fb = new wn.Struct({ reserved: new wn.Reserved(wn.uint8, 24), typeList: new wn.Pointer(wn.uint16, cb), nameListOffset: new wn.Pointer(wn.uint16, "void") }), hb = new wn.Struct({ dataOffset: wn.uint32, map: new wn.Pointer(wn.uint32, fb), dataLength: wn.uint32, mapLength: wn.uint32 }), db = function() {
    function e2(e3) {
      this.stream = e3, this.header = hb.decode(this.stream);
      for (var t3, r3 = ib(this.header.map.typeList.types); !(t3 = r3()).done; ) {
        for (var n2, i2 = t3.value, a2 = ib(i2.refList); !(n2 = a2()).done; ) {
          var o2 = n2.value;
          o2.nameOffset >= 0 ? (this.stream.pos = o2.nameOffset + this.header.map.nameListOffset, o2.name = sb.decode(this.stream)) : o2.name = null;
        }
        "sfnt" === i2.name && (this.sfnt = i2);
      }
    }
    var t2, r2;
    return e2.probe = function(e3) {
      var t3 = new wn.DecodeStream(e3);
      try {
        var r3 = hb.decode(t3);
      } catch (e4) {
        return false;
      }
      for (var n2, i2 = ib(r3.map.typeList.types); !(n2 = i2()).done; ) {
        if ("sfnt" === n2.value.name)
          return true;
      }
      return false;
    }, e2.prototype.getFont = function(e3) {
      if (!this.sfnt)
        return null;
      for (var t3, r3 = ib(this.sfnt.refList); !(t3 = r3()).done; ) {
        var n2 = t3.value, i2 = this.header.dataOffset + n2.dataOffset + 4, a2 = new wn.DecodeStream(this.stream.buffer.slice(i2)), o2 = new og(a2);
        if (o2.postscriptName === e3)
          return o2;
      }
      return null;
    }, t2 = e2, (r2 = [{ key: "fonts", get: function() {
      for (var e3, t3 = [], r3 = ib(this.sfnt.refList); !(e3 = r3()).done; ) {
        var n2 = e3.value, i2 = this.header.dataOffset + n2.dataOffset + 4, a2 = new wn.DecodeStream(this.stream.buffer.slice(i2));
        t3.push(new og(a2));
      }
      return t3;
    } }]) && ob(t2.prototype, r2), e2;
  }();
  return xn.registerFormat(og), xn.registerFormat(Lg), xn.registerFormat(Yv), xn.registerFormat(nb), xn.registerFormat(db), xn;
});
